<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS 的组件化开发</title>
      <link href="/article/714/"/>
      <url>/article/714/</url>
      
        <content type="html"><![CDATA[<p>在一个APP开发过程中，如果项目较小且团队人数较少，使用最基本的MVC、MVVM开发就已经足够了，因为维护成本比较低。</p><p>但是当一个项目开发团队人数较多时，因为每个人都会负责相应组件的开发，常规开发模式耦合会越来越严重，而且导致大量代码冲突，会使后期维护和升级过程中代码“牵一发而动全身”，额外带来很大的工作量，并且会导致一些潜在的BUG。</p><p>在这时，组件化开发就派上很大用场了，所谓的组件化开发，就是把APP根据业务拆分为各独立的组件，各个组件相互写作，组成完整的APP。</p><h3 id="一、各组件的引入"><a href="#一、各组件的引入" class="headerlink" title="一、各组件的引入"></a>一、各组件的引入</h3><p>关于组件的拆分，就根据具体项目进行拆分，假如APP被拆分了AModule、BModule、CModule，那么，应该如何引入这些组件呢？你可能会想到APP的入口AppDelegate。在平时开发中，AppDelegate中往往初始化了好多组件，比如推送、统计等组件，这样就会导致AppDelegate的臃肿。</p><p>所以，我们可以增加一个ModuleManager，专门用来初始化各组件。<br>首先增加一个 ModuleProtocol：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">@import</span> <span class="built_in">UIKit</span>;</span><br><span class="line"><span class="keyword">@import</span> UserNotifications;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ModuleProtocol</span> &lt;<span class="title">UIApplicationDelegate</span>, <span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们在ModuleManager中hook住UIApplicationDelegate和 UNUserNotificationCenterDelegate中的方法，使相应的组件中实现了对应方法，在相应时机就会调用组建里的对应方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ModuleManager.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define ALL_MODULE [[ModuleManager sharedInstance] allModules]</span></span><br><span class="line"><span class="meta">#define SWIZZLE_METHOD(m) swizzleMethod(class, @selector(m),@selector(module_##m));</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModuleManager</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *modules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ModuleManager</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *)modules &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addModule:(<span class="keyword">id</span>&lt;ModuleProtocol&gt;) module &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loadModulesWithPlistFile:(<span class="built_in">NSString</span> *)plistFile &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *)allModules &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span> (<span class="title">Module</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SWIZZLE_METHOD(application:willFinishLaunchingWithOptions:);</span><br><span class="line">        SWIZZLE_METHOD(application:didFinishLaunchingWithOptions:);</span><br><span class="line">        ......</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)module_application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> module_application:application willFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;ModuleProtocol&gt; module <span class="keyword">in</span> ALL_MODULE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([module respondsToSelector:_cmd]) &#123;</span><br><span class="line">            [module application:application willFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)module_application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> module_application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;ModuleProtocol&gt; module <span class="keyword">in</span> ALL_MODULE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([module respondsToSelector:_cmd]) &#123;</span><br><span class="line">            [module application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>ModuleManager.h:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ModuleProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModuleManager</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loadModulesWithPlistFile:(<span class="built_in">NSString</span> *)plistFile;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *)allModules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后我们通过一个 ModulesRegister.plist文件管理需要引入的组件：</p><p>如上图，假如我们要引入AModule、BModule、CModule，那么这三个Module只需要实现协议ModuleProtocol，然后实现AppDelegate中对应的方法，在对应方法中初始化自身即可：<br>AModule.h:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ModuleProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AModule</span> : <span class="title">NSObject</span>&lt;<span class="title">ModuleProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AModule.m:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AModule.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AModule</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions&#123;</span><br><span class="line">    <span class="comment">//初始化AModule</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后在AppDelegate的load方法中通过ModulesRegister.plist引入各组件即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">//load modules</span></span><br><span class="line">    <span class="built_in">NSString</span>* plistPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"ModulesRegister"</span> ofType:<span class="string">@"plist"</span>];</span><br><span class="line">    [[ModuleManager sharedInstance] loadModulesWithPlistFile:plistPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样，各组件的开发者在自己的组件中初始化自己，其他人需要使用时只需要加入ModulesRegister.plist文件中即可。</p><h3 id="二、组件间协作"><a href="#二、组件间协作" class="headerlink" title="二、组件间协作"></a>二、组件间协作</h3><p>简单来看，假设APP的每个页面就是一个组件，假如我们的APP有AViewController、BViewController、CViewController、DViewController、EViewController，各ViewController必然设置各种相互跳转。那么，我们APP的跳转逻辑可能是下面这个样子：</p><p>为了解决这种复杂的耦合关系，我们可以增加一个Router中间层去管理各ViewController之间的跳转关系（也就是实际开发中组件间相互调用的关系）。</p><p>所以，根据需要，我开发并开源了一个支持URL Rewrite的iOS路由库— <a href="https://github.com/imlifengfeng/FFRouter" target="_blank" rel="noopener">FFRouter</a>，通过<a href="https://github.com/imlifengfeng/FFRouter" target="_blank" rel="noopener">FFRouter</a>去管理各ViewController之间的跳转关系：</p><p>这样，各ViewController之间的跳转关系就变的清晰了许多。</p><p>FFRouter通过提前注册对应的URL，之后就直接通过打开URL去控制各ViewController之间的跳转（或各组件间的调用）。<br>FFRouter支持组件间传递非常规对象，如UIImage等，并支持获取组件返回值。<br>基本使用如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 注册 url</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> routeURL 要注册的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> handlerBlock URL 被 Route 后的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">registerRouteURL:</span>(NSString *)routeURL <span class="string">handler:</span>(FFRouterHandler)handlerBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 注册 URL,通过该方式注册的 URL 被 Route 后可返回一个 Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> routeURL 要注册的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> handlerBlock URL 被 Route 后的回调,可在回调中返回一个 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">registerObjectRouteURL:</span>(NSString *)routeURL <span class="string">handler:</span>(FFObjectRouterHandler)handlerBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断 URL 是否可被 Route（是否已经注册）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要判断的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 是否可被 Route</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)<span class="string">canRouteURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">routeURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL，并带上额外参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> parameters 额外参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">routeURL:</span>(NSString *)URL <span class="string">withParameters:</span>(NSDictionary&lt;NSString *, id&gt; *)parameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL，可获得返回的 Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 返回的 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (id)<span class="string">routeObjectURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL，并带上额外参数，可获得返回的 Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> parameters 额外参数</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 返回的 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (id)<span class="string">routeObjectURL:</span>(NSString *)URL <span class="string">withParameters:</span>(NSDictionary&lt;NSString *, id&gt; *)parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个未注册 URL 时回调</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> handler 回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">routeUnregisterURLHandler:</span>(FFRouterUnregisterURLHandler)handler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取消注册某个 URL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要被取消注册的 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">unregisterRouteURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取消注册所有 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)unregisterAllRoutes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否显示 Log，用于调试</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> enable YES or NO，默认为 NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">setLogEnabled:</span>(BOOL)enable;</span><br></pre></td></tr></table></figure><p>而且参考天猫的方案增加了URL Rewrite功能：</p><p>可以使用正则添加一条 Rewrite 规则，例如：<br>要实现打开 URL:<a href="https://www.taobao.com/search/原子弹时，将其拦截，改用本地已注册的" target="_blank" rel="noopener">https://www.taobao.com/search/原子弹时，将其拦截，改用本地已注册的</a> URL:protocol://page/routerDetails?product=原子弹打开。<br>首先添加一条 Rewrite 规则：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FFRouterRewrite <span class="string">addRewriteMatchRule:</span>@<span class="string">"(?:https://)?www.taobao.com/search/(.*)"</span> <span class="string">targetRule:</span>@<span class="string">"protocol://page/routerDetails?product=$1"</span>];</span><br></pre></td></tr></table></figure><p>之后在打开URL:<a href="https://www.taobao.com/search/原子弹时，将会" target="_blank" rel="noopener">https://www.taobao.com/search/原子弹时，将会</a> Rewrite 到URL:protocol://page/routerDetails?product=原子弹。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">FFRouter</span> routeURL:@<span class="string">"https://www.taobao.com/search/原子弹"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>可以通过以下方法同时增加多个规则：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)addRewriteRules:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *)rules;</span><br></pre></td></tr></table></figure><p>其中 rules 格式必须为以下格式：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@[</span><span class="meta">@&#123;</span><span class="meta">@"matchRule":</span><span class="meta">@"YourMatchRule1",</span><span class="meta">@"targetRule":</span><span class="meta">@"YourTargetRule1"&#125;,</span></span><br><span class="line">  <span class="meta">@&#123;</span><span class="meta">@"matchRule":</span><span class="meta">@"YourMatchRule2",</span><span class="meta">@"targetRule":</span><span class="meta">@"YourTargetRule2"&#125;,</span></span><br><span class="line">  <span class="meta">@&#123;</span><span class="meta">@"matchRule":</span><span class="meta">@"YourMatchRule3",</span><span class="meta">@"targetRule":</span><span class="meta">@"YourTargetRule3"&#125;,]</span></span><br></pre></td></tr></table></figure><p>Rewrite 规则中的保留字：</p><ul><li>通过 <em><strong>$scheme</strong></em>、<em><strong>$host</strong></em>、<em><strong>$port</strong></em>、<em><strong>$path</strong></em>、<em><strong>$query</strong></em>、<em><strong>$fragment</strong></em> 获取标准 URL 中的相应部分。通过<em><strong>$url</strong></em>获取完整 URL</li></ul><ul><li>通过 <em><strong>$1</strong></em>、<em><strong>$2</strong></em>、<em><strong>$3</strong></em>…获取matchRule的正则中使用圆括号取出的参数</li></ul><ul><li><em><strong>$</strong></em>：原变量的值、<em><strong>$$</strong></em>：原变量URL Encode后的值、<em><strong>$#</strong></em>：原变量URL Decode后的值</li></ul><p>例如：<br><a href="https://www.taobao.com/search/原子弹对于Rewrite" target="_blank" rel="noopener">https://www.taobao.com/search/原子弹对于Rewrite</a> 规则(?:https://)?<a href="http://www.taobao.com/search/(.*)" target="_blank" rel="noopener">www.taobao.com/search/(.*)</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$1=原子弹</span><br><span class="line">$$<span class="number">1</span>=%e5%8e%9f%e5%ad%90%e5%bc%b9</span><br></pre></td></tr></table></figure><p>同样，<a href="https://www.taobao.com/search/%e5%8e%9f%e5%ad%90%e5%bc%b9对于Rewrite" target="_blank" rel="noopener">https://www.taobao.com/search/%e5%8e%9f%e5%ad%90%e5%bc%b9对于Rewrite</a> 规则(?:https://)?<a href="http://www.taobao.com/search/(.*)" target="_blank" rel="noopener">www.taobao.com/search/(.*)</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$1=%e5%8e%9f%e5%ad%90%e5%bc%b9</span><br><span class="line">$#1=原子弹</span><br></pre></td></tr></table></figure><p>考虑到经常用路由配置UIViewController之间的跳转，所以增加了额外的工具FFRouterNavigation来更方便地控制UIViewController之间的跳转。</p><h3 id="三、其他组件化方案"><a href="#三、其他组件化方案" class="headerlink" title="三、其他组件化方案"></a>三、其他组件化方案</h3><p>目前这种组件化方案参考了蘑菇街、天猫、京东的的实现方案。除这种方案外，Casa（<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">查看文章</a>）之前提出了解耦程度更高的方案，这种方案组件仍然使用中间件通信，但中间件通过 runtime 接口解耦，然后使用 target-action 简化写法，通过 category 分离组件接口代码。<br>但是，这种方案虽然解耦程度更高，但是也增加了组件化的成本，综合考虑，直接使用中间件通信的方式更好一点。具体哪种方案好，也就仁者见仁、智者见智了～</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS逆向工程之fishhook</title>
      <link href="/article/692/"/>
      <url>/article/692/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>峰哥在<a href="http://www.imlifengfeng.com/blog/?p=677" target="_blank" rel="noopener">上一篇文章</a>整理了在插件开发中如何HOOK 动态语言 Objective-C 中的方法，实际上静态语言 C 语言中的函数也是有办法 HOOK 的，这也说明了绝对的静态语言是不存在的。</p><p>为了实现HOOK C 语言中的函数，我们需要用到 Facebook 的一个开源框架 fishhook，通过 fishhook 我们可以很轻松的 HOOK C 语言中的函数，从而达到修改函数功能的目的。</p><p>我在参考了 fishhook 官方 demo 和 Draveness 的文章后，发现对 C 函数的 HOOK 也是非常简单的。</p><p>在开始之前需要先简单了解两个概念：</p><p>Mach-O：对于每个操作系统中的可执行程序都是有格式的，如 ELF 是 Linux 下可执行文件的格式，PE32／PE32+ 是 windows 的可执行文件的格式，那么对于 OS X 和 iOS 来说 Mach-O 是其可执行文件的格式。 OS X 和 iOS 开发中的可执行文件、库文件、Dsym文件、动态库、动态连接器都是这种格式的。</p><p>镜像：在 Mach-O 文件系统中，所有的可执行文件、dylib 以及 Bundle 都是镜像。</p><p>二、<strong>fishhook的使用</strong></p><p>我们先通过一个简单的 demo 去了解一下 fishhook 的使用，fishhook GitHub链接：<a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">https://github.com/facebook/fishhook</a></p><p>下载下来 fishhook 后你会发现这个框架非常简单，只有两个文件“fishhook.h”和“fishhook.c”。</p><p>我们打开文件“fishhook.h”会发现只有一个结构体和两个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">void</span> *replacement;</span><br><span class="line">  <span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line"></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                         struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure><p>我们先看 rebinding 结构体，结构体中 name 是一个原始函数（要被替换的函数）名字符串，replacement 是替换后的新的函数指针，replaced 是我们自己创建的一个与原始函数签名相同（参数的个数、类型、顺序相同）的函数的指针的指针。关于 rebinding 暂且先不要纠结，后面看过代码就知道如何使用了。</p><p>rebind_symbols 函数和 rebind_symbols_image 函数是用来 HOOK 函数的两个方法，只不过参数不同而已，前者比较简单，两个参数一个是 rebinding 数组，一个是数组中 rebinding 个数。后者就稍微复杂点，根据源码中的注释说明，该函数是在仅指定镜像的时候使用。所以，我们这里直接使用 rebind_symbols 函数就可以了。</p><p>C 语言中有个 strlen 函数，用来获取字符串的长度，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  FishHookDemo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">"imlifengfeng"</span>;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结果:%ld\n"</span>,result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/2017/07/Snip20170702_1.png" alt="Snip20170702_1"></p><p>接下来我们就修改 strlen 函数的返回值，使无论字符串真实长度是什么，都返回 666。我们使用前面说到的 rebind_symbols 函数去实现。</p><p>首先我们要声明一个与 strlen 函数签名相同的函数，方法名任意，我们定义为 original_strlen，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*original_strlen)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span></span>;</span><br></pre></td></tr></table></figure><p>然后再定义一个替换后的函数，使其不管参数是什么直接返回 666，方法名也任意，我们定义为 new_strlen，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就使用 rebind_symbols 函数进行绑定：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> strlen_rebinding = </span>&#123; <span class="string">"strlen"</span>, new_strlen, (<span class="keyword">void</span> *)&amp;original_strlen &#125;;</span><br><span class="line">rebind_symbols((<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span>[1])</span>&#123;strlen_rebinding&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上面这些操作完成之后再调用 strlen 函数无论字符串真实长度是什么都会直接返回 666。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  FishHookDemo2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*original_strlen)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">strlen_rebinding</span> = &#123;</span> <span class="string">"strlen"</span>, new_strlen, (<span class="keyword">void</span> *)&amp;original_strlen &#125;;</span><br><span class="line">        rebind_symbols((struct rebinding[<span class="number">1</span>])&#123;strlen_rebinding&#125;, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">"imlifengfeng"</span>;</span><br><span class="line">        <span class="keyword">long</span> test = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结果:%ld\n"</span>,test);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/2017/07/Snip20170702_2.png" alt="Snip20170702_2"></p><p>可以看到我们已经达到了 HOOK C函数的目的，已经理解的可以自己尝试 HOOK 一些其他的函数去实现一些更复杂的功能。</p><p>三、<strong>fishhook的原理</strong></p><p>1、Mach-O</p><p>前面峰哥也说了 Mach-O 是 OS X 和 iOS 可执行文件的格式，我们这里再来简单看下 Mach-O 文件格式的结构，无需深究。</p><p>每一个 Mach-O 文件都会被分为不同的 Segments，比如 <code>__TEXT</code>, <code>__DATA</code>, <code>__LINKEDIT</code>：</p><p><img src="/images/2017/07/2016-07-26-fishhook-mach-o.png.jpeg" alt="2016-07-26-fishhook-mach-o.png"></p><p>Mach-O 中的 <code>segment_command</code>（32 位与 64 位不同）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment name */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;     <span class="comment">/* memory address of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;     <span class="comment">/* memory size of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;    <span class="comment">/* file offset of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;   <span class="comment">/* amount to map from the file */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;    <span class="comment">/* maximum VM protection */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;   <span class="comment">/* initial VM protection */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;     <span class="comment">/* number of sections in segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;      <span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个 <code>segment_command</code> 中又包含了不同的 <code>section</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* name of this section */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment this section goes in */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;       <span class="comment">/* memory address of this section */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;       <span class="comment">/* size in bytes of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;     <span class="comment">/* file offset of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;      <span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;     <span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;     <span class="comment">/* number of relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;      <span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;  <span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;  <span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;  <span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、dyld 与动态链接</p><p>dyld（the dynamic link editor）是 Apple 的动态链接器（GitHub地址：<strong><a href="https://github.com/opensource-apple/dyld" target="_blank" rel="noopener">dyld</a></strong>），系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，关于其作用顺序，可参考文章《<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="noopener">dyld: Dynamic Linking On OS X</a>》，相关部分翻译内容如下：<br>（1）从kernel留下的原始调用栈引导和启动自己<br>（2）将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制<br>（3）non-lazy符号立即link到可执行文件，lazy的存表里<br>（4）运行可执行文件的静态初始化程序<br>（5）找到可执行文件的main函数，准备参数并调用<br>（6）程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口<br>（7）程序main函数return后执行static terminator<br>（8）某些场景下main函数结束后调libSystem的_exit函数</p><p>一句话总结就是：负责将各种各样程序需要的镜像加载到程序运行的内存空间中！</p><p>其作用的时间是 OC 运行时初始化之前！</p><p>dyld 加载镜像后会执行相关回调函数，当一个镜像被动态链接时，都会执行回调 <code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的 <code>mach_header</code> 以及一个虚拟内存地址 <code>intptr_t</code>。</p><p>我们先使用 Xcode 新建一个简单的 C 项目，项目名为 test ,项目新建后默认 main.c 文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/4.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打开终端 cd 到 main.c 文件目录，使用 gcc 命令编译  main.c 源文件生成可执行文件，执行完成后会生成名为 a.out 的可执行文件。之后通过 nm 命令查看可执行文件中的符号：</p><p><img src="/images/2017/07/Snip20170705_3.png" alt="Snip20170705_3"></p><p>从上图可以看出，<code>_printf</code> 这个符号是未定义（undefined）的，换句话说，编译器还不知道这个符号对应什么东西。</p><p>那如果我们自己增加一个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/4.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那结果是什么样的呢？如下：</p><p><img src="/images/2017/07/Snip20170705_1.png" alt="Snip20170705_1"></p><p>可见我们手动添加的 test 函数所对应的符号 _test 并不是为定义的，它包含一个内存地址以及 <code>__TEXT</code> 段。</p><p>为了更深入理解，我们需要用到一个神器 Hopper Disassembler ，这是一个类似于 IDA 的反汇编工具，个人感觉它比 IDA 好用的多，感兴趣的可以自己从网上下载，它最新图标是下面这样的：</p><p><img src="/images/2017/07/Snip20170705_2-1.png" alt="Snip20170705_2"></p><p>我们使用该工具分析一下之前的 a.out 的可执行文件：</p><p><img src="/images/2017/07/Snip20170705_3-1.png" alt="Snip20170705_3"></p><p><code>可以发现 nm</code> 打印出的另一个符号 <code>dyld_stub_binder</code> 对应另一个同名函数。<code>dyld_stub_binder</code> 会在目标符号（例如 <code>printf</code>）被调用时，将其链接到指定的动态链接库 <code>libSystem</code>，再执行 <code>printf</code> 的实现（<code>printf</code> 符号位于 <code>__DATA</code> 端中的 lazy 符号表中）。</p><p>每一个镜像中的 <code>__DATA</code> 端都包含两个与动态链接有关的表，其中一个是 <code>__nl_symbol_ptr</code>，另一个是 <code>__la_symbol_ptr</code>：</p><ul><li><code>__nl_symbol_ptr</code> 中的 non-lazy 符号是在动态链接库绑定的时候进行加载的</li></ul><ul><li><code>__la_symbol_ptr</code> 中的符号会在该符号被第一次调用时，通过 dyld 中的 <code>dyld_stub_binder</code> 过程来进行加载</li></ul><p>在上述代码调用 printf 时，由于符号是没有被加载的，就会通过 dyld_stub_binder 动态绑定符号：</p><p><img src="/images/2017/07/Snip20170705_4.png" alt="Snip20170705_4"></p><p>3、fishhook 的原理</p><p>dyld 通过更新 Mach-O 二进制文件 <strong>DATA 段中的一些指针来绑定 lazy 和 non-lazy 的符号；而 fishhook 先确定某一个符号在 </strong>DATA 段中的位置，然后保存原符号对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定。</p><p>对于前面我们 HOOK strlen 函数的例子，过程如下图示：</p><p><img src="/images/2017/07/Snip20170705_6.png" alt="Snip20170705_6"></p><p>其中最复杂的部分就是从二进制文件中寻找某个符号的位置，在 fishhook 的 README 中，有这样一张图：</p><p><img src="/images/2017/07/2016-07-26-fishhook-imp.png" alt="2016-07-26-fishhook-imp"></p><p>这张图初看很复杂，不过它演示的是寻找符号的过程，我们根据这张图来分析一下这个过程：</p><ol><li>从 __DATA 段中的 lazy 符号指针表中查找某个符号，获得这个符号的偏移量 1061，然后在每一个 section_64 中查找 reserved1，通过这两个值找到 Indirect Symbol Table 中符号对应的条目</li></ol><ol start="2"><li>在 Indirect Symbol Table 找到符号表指针以及对应的索引 16343 之后，就需要访问符号表</li></ol><ol start="3"><li>然后通过符号表中的偏移量，获取字符串表中相关函数的符号</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 逆向工程 </tag>
            
            <tag> fishhook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS逆向工程之插件开发</title>
      <link href="/article/677/"/>
      <url>/article/677/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>iOS逆向工程是指在软件层面上进行逆向分析的一个过程，基于iOS逆向工程技术，我们可以监控甚至改变App的运行逻辑，从而达到获取核心信息，了解软件设计原理等战术目的。通过一段时间对iOS逆向工程的研究发现很有趣，会在博客记录学习开发过程中的心得和笔记。首先从基本插件的开发开始，后面会对微信、QQ等App进行逆向开发与修改，做一些有趣的事情～</p><p>二、<strong>用到的设备或工具</strong></p><p>1、一台越狱设备：iPhone手机越狱和Android手机ROOT一样非常简单，具体的越狱方法网上很多，这里不在讨论。</p><p>2、Cydia：一般越狱过的手机都会自动被安装该软件，相当于App Store，可以搜索安装越狱app，也可以用来管理（卸载）我们开发的插件。</p><p>3、Theos：越狱开发工具包。</p><p>4、ldid：模拟给iPhone签名的流程，使我们能够在真实的设备上安装越狱的apps/hacks。</p><p>5、dkpg：一个Debian的一个命令行工具，它可以用来安装、删除、构建和管理Debian的软件包。</p><p>三、<strong>软件或工具的介绍与安装</strong></p><p>1、Theos</p><p>越狱开发中除了Thoes外还有一个叫iOSOpenDev的工具，功能和Thoes是一样的，不同点是iOSOpenDev是整合到Xcode中使用的，通过本人亲身实践发现使用Thoes开发更简单方便，感兴趣的可以去了解下iOSOpenDev，这里不再讲解，个人建议使用Thoes，本文也将以Thoes为基础进行开发。</p><p>安装Thoes方法如下：</p><p>首先设置环境变量，我们将Thoes安装在/opt/theos中，打开terminal然后输入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS</span>=/opt/theos</span><br></pre></td></tr></table></figure><p>通过在命令行执行 echo $THEOS可以看到这个变量是否正确设置。每次你打开terminal都需要重新设置一下。</p><p><img src="/images/2017/06/Snip20170623_4.png" alt="Snip20170623_4"></p><p>然后下载Theos：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/DHowett/</span>theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure><p>之后会提示输入密码，输入密码等待下载完成即可。</p><p>2、ldid</p><p>ldid是一个用来给iOS可执行程序签名的工具，使我们开发的越狱APP或者插件能够安装到越狱手机上。</p><p>我们可以从<a href="http://joedj.net/ldid" target="_blank" rel="noopener">http://joedj.net/ldid</a>上下载ldid后拷贝到“/opt/theos/bin/”目录中，然后使用下面命令行赋予可执行权限：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod <span class="number">777</span> <span class="regexp">/opt/</span>theos<span class="regexp">/bin/</span>ldid</span><br></pre></td></tr></table></figure><p>3、dkpg</p><p>Dpkg能够把你的app打包成Debian Package,可以分发的Cydia的存储目录中。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>dpkg</span><br></pre></td></tr></table></figure><p>4、配置libsubstrate.dylib</p><p>在开始开发之前，还需要下载libsubstrate.dylib，然后copy到“/opt/theos/lib”目录下即可，点击下载：<a href="http://www.mediafire.com/?2upm53uzzj0488u" target="_blank" rel="noopener">libsubstrate.dylib</a></p><p> 由于“你懂的”的原因，访问国外网站需要翻墙，上面下载链接不翻墙可能无法下载，如果你没有梯子，可以从我网盘下载：</p><p><a href="http://pan.baidu.com/s/1hsL0llM" target="_blank" rel="noopener">http://pan.baidu.com/s/1hsL0llM</a></p><p>最后我们在开发之前可以看下Theos中的模板，执行如下命令可以看到默认存在的模板：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span><span class="regexp">/bin/</span>nic.pl</span><br></pre></td></tr></table></figure><p>有的人会在使用模板创建项目的时候会有如下提示：</p><p><img src="/images/2017/06/Snip20170625_10.png" alt="Snip20170625_10"></p><p>原因是没有执行如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS</span>=/opt/theos</span><br></pre></td></tr></table></figure><p>上面已经说了，每次都要执行一次，如果不想每次都执行也可以直接使用如下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>theos<span class="regexp">/bin/</span>nic.pl</span><br></pre></td></tr></table></figure><p><img src="/images/2017/06/Snip20170625_11.png" alt="Snip20170625_11"></p><p>可以看到上面一共有17个模板。</p><p>实际上安装 后默认只有12个模板，想要添加更多模板，可以从<a href="https://github.com/DHowett/theos-nic- templates/archive/master.zip55.tar" target="_blank" rel="noopener">https://github.com/DHowett/theos-nic- templates/archive/master.zip55.tar</a>下载额外的5个模板，下载后解压得到的5个.tar文件复制到“/opt/theos/templates/iphone/”目录下即可。</p><p> 四、<strong>创建工程</strong></p><p>首先介绍一下本教程所写插件实现的功能：“修改”设备信息。实际上对于系统硬件信息是不能修改的，但是我们可以修改获取设备信息的方法的返回值，比如我们获取系统版本用如下方法：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">UIDevice</span> currentDevice] systemVersion]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>如果我们的系统是10.0.2版本，该方法会返回字符串“10.0.2”，我们要做的就是当别的App调用上面方法时，我们拦截住并返回一个我们设定的任意值，比如我们让上面方法返回“11.0.2”，这就是传说中的HOOK。</p><p>首先我们新建一个文件夹MyDemo，cd到该文件夹中，然后按照上面所说的，我们使用如下命令查看与选择模板：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span><span class="regexp">/bin/</span>nic.pl</span><br></pre></td></tr></table></figure><p><img src="/images/2017/06/Snip20170625_11.png" alt="Snip20170625_11"></p><p>我们选择模板15（iphone/tweak），之后根据提示输入Project Name（tweak工程名）、Package Name（de b包的名字，类似于bundle identifier）、Author（作者）、Bundle filter（tweak作用对象的bundle identifier）即可，具体的根据实际情况填写。</p><p><img src="/images/2017/06/Snip20170625_12.png" alt="Snip20170625_12"></p><p>最后在MyDemo目录中生成的文件如下：</p><p><img src="/images/2017/06/Snip20170625_13.png" alt="Snip20170625_13"></p><p>介绍一下上面的几个文件：<br>（1）control文件</p><p>主要记录的deb包管理系统所需要的基本信息，会被打包进deb包中，该文件中主要是我们创建工程时所填写的信息，如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Package:</span> <span class="keyword">com</span>.imlifengfeng.tweakdemo</span><br><span class="line"><span class="symbol">Name:</span> tweakdemo</span><br><span class="line"><span class="symbol">Depends:</span> mobilesubstrate</span><br><span class="line"><span class="symbol">Version:</span> <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"><span class="symbol">Architecture:</span> iphoneos-arm</span><br><span class="line"><span class="symbol">Description:</span> An awesome MobileSubstrate tweak!</span><br><span class="line"><span class="symbol">Maintainer:</span> imlifengfeng</span><br><span class="line"><span class="symbol">Author:</span> imlifengfeng</span><br><span class="line"><span class="symbol">Section:</span> Tweaks</span><br></pre></td></tr></table></figure><p>（2）Makefile文件</p><p>用于指定工程用到的文件、框架、库等信息，将整个过程自动化，文件默认内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(THEOS)</span>/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = tweakdemo</span><br><span class="line">tweakdemo_FILES = Tweak.xm</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(THEOS_MAKE_PATH)</span>/tweak.mk</span><br><span class="line"></span><br><span class="line"><span class="section">after-install::</span></span><br><span class="line">install.exec <span class="string">"killall -9 SpringBoard"</span></span><br></pre></td></tr></table></figure><p>注意一下上面第一行，如果在使用命令行做操作（如打包、安装）时，如果没有执行下面命令会报错：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS</span>=/opt/theos</span><br></pre></td></tr></table></figure><p>这个是新手容易犯的错误，还是一样，想省事也可以把上面第一行直接改成：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="regexp">/opt/</span>theos<span class="regexp">/makefiles/</span>common.mk</span><br></pre></td></tr></table></figure><p>我们需要在Makefile文件中做一些配置：</p><p>设置我们用到的框架：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tweakDemo_FRAMEWORKS</span> = UIKit CoreGraphics</span><br></pre></td></tr></table></figure><p>注意一下前缀tweakDemo，这是你的项目名，根据自己项目名填写。</p><p>指定iOS SDK版本（这里指定采用最新版SDK，插件适用最低版本9.0）：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET = <span class="string">iphone:</span><span class="string">latest:</span><span class="number">9.0</span></span><br></pre></td></tr></table></figure><p>上面的latest可以也设置成具体版本，如10.0。</p><p>已链接目标真机的IP：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOS_DEVICE_IP=<span class="number">192.168</span><span class="number">.2</span><span class="number">.61</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里使用的ssh连接的，关于连接真机，有个注意的一点是最新的越狱方法已经不再需要手机安装OpenSSH插件了，安装后反而无法连接。但是OpenSSH功能是默认禁用的，需要手动开启。开启方法也很简单，在 Cydia 中搜索 Filza 并安装，进入以下路径：/private/var/containers/Bundle/Application/yalu102/yalu102.app/，用文本编辑器打开 dropbear.plist 文件，替换 127.0.0.1:22 为 22，重启设备，重新使用越狱工具恢复越狱即可。</p><p>最终配置完后的文件内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /opt/theos/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = tweakDemo</span><br><span class="line">tweakDemo_FILES = Tweak.xm</span><br><span class="line">tweakDemo_FRAMEWORKS = UIKit CoreGraphics</span><br><span class="line">TARGET = iphone:latest:9.0</span><br><span class="line">THEOS_DEVICE_IP=192.168.2.61</span><br><span class="line"><span class="keyword">include</span> /opt/theos/makefiles/tweak.mk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">after-install::</span></span><br><span class="line">install.exec <span class="string">"killall -9 SpringBoard"</span></span><br></pre></td></tr></table></figure><p>（3）Tweak.xm文件</p><p>该文件就是我们写相关代码的文件，使用的是Logos语言，看到这里别害怕，Logos其实非常非常简单的，简单到3分钟从入门到精通，没多少内容，这个后面具体再讲。</p><p>（4）tweakdemo.plist文件</p><p>这个文件主要用来设置插件的作用范围，对哪些App有效，比如可以设置哪些App调用我们HOOK的方法时返回我们设定的值。</p><p>用Xcode打开其内容如下：<br><img src="/images/2017/06/Snip20170625_14.png" alt="Snip20170625_14"></p><p>用Sublime等编辑器打开内容如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in"> Filter </span>= &#123; Bundles = ( <span class="string">"com.apple.springboard"</span> ); &#125;; &#125;</span><br></pre></td></tr></table></figure><p>写完相关的代码记得把作用的App的bundle identifier加上。</p><p>五、<strong>插件代码编写</strong></p><p>上面介绍了生成的几个文件，可以知道我们在Tweak.xm文件中写Tweak代码。我们要实现的功能就是HOOK获取设备信息的方法，为了验证效果，我们先写一个App（bundle identifier为imlifengfeng.InfoGetter）用来获取设备信息，界面如下：<br><img src="/images/2017/06/IMG_7383.png" alt="IMG_7383"></p><p>核心代码为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  InfoGetter</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/6/20.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *infoLabel;<span class="comment">//信息显示Label</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)nameBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *deviceName = [[<span class="built_in">UIDevice</span> currentDevice] name];</span><br><span class="line">    _infoLabel.text = deviceName;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)versionBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *sysVersion = [[<span class="built_in">UIDevice</span> currentDevice] systemVersion];</span><br><span class="line">    _infoLabel.text = sysVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)modelBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *deviceModel = [[<span class="built_in">UIDevice</span> currentDevice] model];</span><br><span class="line">    _infoLabel.text = deviceModel;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说我们要HOOK住的三个方法为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[UIDevice currentDevice] name]</span><br><span class="line">[[UIDevice currentDevice] systemVersion]</span><br><span class="line">[[UIDevice currentDevice] model]</span><br></pre></td></tr></table></figure><p>开始写之前我们先学一下Logos语言，非常简单：<br>（1）%hook</p><p>指定需要hook的class，必须以%end结尾</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">_menuButtonDown:</span>(id)down</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    NSLog(@<span class="string">"你好"</span>);</span></span><br><span class="line"><span class="ruby">    %orig;<span class="regexp">//call</span> the original _menuButtonDown;</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>这段代码的意思是勾住(hook) <em>SpringBoard</em> 类里的__menuButtonDown:_ 函数，先将一句话写入 <em>syslog</em> , 再执行函数的原有操作。</p><p>（2）%log</p><p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hoot</span></span> SpringBoard</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">_menubuttonDown:</span>(id)down</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    %log((NSString *)@<span class="string">"iOSRE"</span>,(NSString *)@<span class="string">"Debug"</span>);</span></span><br><span class="line"><span class="ruby">    %orig;<span class="regexp">//call</span> the original _menuButtonDown;</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>（3）%orig</p><p>该指令在<em>%hook</em>内部使用，执行被勾住(hook)的方法的原始代码。例如：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">_menuButtonDown:</span>(id)down</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    NSLog(@<span class="string">"你好"</span>);</span></span><br><span class="line"><span class="ruby">    %orig; <span class="regexp">//</span> </span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>如果去掉 _%orig _那么原始方法不会执行：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hook SpringBoard</span><br><span class="line">- <span class="params">(void)</span>_menuButtonDown:<span class="params">(id)</span>down</span><br><span class="line">&#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"你好"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>还可以利用 <em>%orig</em> 更改原始行数的参数：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SBLockScreenDateViewController</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">setCustomSubtitleText:</span>(id)arg1 <span class="symbol">withColor:</span>(id)arg2</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    %orig(@<span class="string">"Re"</span>,arg2);</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>这个方法会改变锁屏界面的日期显示。</p><p>（4）%group</p><p>该指令用于将_ %hook _分组，便于代码管理及按条件初始化分组，必须以 <em>%end</em> 结尾；一个_ %group <em>可以包含多个</em> %hook <em>, 所有不属于某个自定义</em> group _的_ %hook <em>会被隐式归类到</em> %group_ungroupes _中。用法如下：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">group</span></span> iOS7Hook</span><br><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> iOS7Class </span><br><span class="line">-<span class="ruby"> (id)iOS7Method &#123;</span></span><br><span class="line"><span class="ruby">     id result = %orig; </span></span><br><span class="line"><span class="ruby">     NSLog(@<span class="string">"This class &amp; method only exist in iOS 7."</span>); </span></span><br><span class="line"><span class="ruby">     <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="ruby"> &#125; %<span class="keyword">end</span> </span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span> /<span class="regexp">/ iOS7Hook</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">%group iOS8Hook </span></span><br><span class="line"><span class="ruby">%hook iOS8Class </span></span><br><span class="line"><span class="ruby">- (id)iOS8Method &#123;</span></span><br><span class="line"><span class="ruby">   id result = %orig; </span></span><br><span class="line"><span class="ruby">   NSLog(@<span class="string">"This class &amp; method only exist in iOS 8."</span>); <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="ruby"> &#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span> /<span class="regexp">/ iOS8Hook</span></span></span><br></pre></td></tr></table></figure><p>（5）%init</p><p>该指令用于初始化某个 _%group <em>,必须在</em> %hook _或_ %ctor <em>内调用;如果带参数,则初始化指定的 group,如果不带参数,则初始化 __ungrouped</em> ,如下:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0 </span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 #endif</span><br><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard </span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">applicationDidFinishLaunching:</span>(id)application &#123;</span></span><br><span class="line"><span class="ruby">    %orig; </span></span><br><span class="line"><span class="ruby">    %init; <span class="regexp">//</span> Equals to %init(_ungrouped)</span></span><br><span class="line"><span class="ruby">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_<span class="number">0</span> &amp;&amp; kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_<span class="number">0</span>)</span></span><br><span class="line"><span class="ruby">      %init(iOS7Hook);</span></span><br><span class="line"><span class="ruby">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_<span class="number">0</span>)</span></span><br><span class="line"><span class="ruby">      %init(iOS8Hook);</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>只有调用了 %init,对应的 %group 才能起作用。</p><p>（6）%new</p><p>在 <em>%hook</em> 内部使用,给一个现有 <em>class</em> 加新函数,功能与 _class_addMethod_ 相同。它的用法如下:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard </span><br><span class="line"><span class="tag">%<span class="selector-tag">new</span></span> </span><br><span class="line">-<span class="ruby"> (void)namespaceNewMethod &#123;</span></span><br><span class="line"><span class="ruby">     NSLog(@<span class="string">"We've added a new method to SpringBoard."</span>); </span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>（7）%c</p><p>该指令的作用等同于 _objc_getClass_ 或 <em>NSClassFromString</em>,即动态获 一个类的定义,在 <em>%hook</em> 或 <em>%ctor</em> 内使用。</p><p>由于我们只是要HOOK住三个方法，所以我们只能用到%hook。</p><p>具体怎么实现呢？非常简单，我们要HOOK的方法是UIDevice类中的name、systemVersion、model三个方法，所以我们在Tweak.xm文件中直接写代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;SpringBoard/SpringBoard.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">%hook <span class="built_in">UIDevice</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">@"我是假name"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)systemVersion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"我是假systemVersion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)model</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"我是假model"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>然后在tweakdemo.plist文件中加上上面我们写的测试App的bundle identifier，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in"> Filter </span>= &#123; Bundles = ( <span class="string">"com.apple.springboard"</span>,<span class="string">"imlifengfeng.InfoGetter"</span>); &#125;; &#125;</span><br></pre></td></tr></table></figure><p>最后就可以安装插件到手机了，cd进入项目目录，依次执行三个命令：make、make package、make install即可将插件安装到手机。</p><p>如果在安装（make install）时出现如下错误：<br><img src="/images/2017/06/Snip20170625_15.png" alt="Snip20170625_15"></p><p>只需要配置一下设备IP环境即可，用如下命令行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS_DEVICE_IP</span>=192.168.2.61</span><br></pre></td></tr></table></figure><p>注意将上面IP改成你真机的IP。</p><p>安装后在手机桌面是看不到插件的，可以通过Cydia查看或卸载：<br><img src="/images/2017/06/Snip20170625_16.png" alt="Snip20170625_16"></p><p>之后就可以通过我们的测试App进行测试了，测试结果如下：<br><strong>安装插件前：</strong><br><img src="/images/2017/06/1.png" alt="1"></p><p><strong>安装插件后：</strong><br><img src="/images/2017/06/2.png" alt="2"></p><p>以上就是这个简单插件开发的整个过程，虽然这个插件很简单，但是对于新手来说这个入门过程是非常复杂的，其中仅仅安装软件配置环境就花了好长时间，<a href="http://www.imlifengfeng.com" target="_blank" rel="noopener">峰哥</a>自己刚研究的时候就是由于网上找不到一个完整的教程，所以比较费脑，也进了不少坑，所以我这里写了一个特别详细的笔记，希望给新生一个帮助，这个教程应该是全网最详细最完整的一个教程了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 插件开发 </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之归并排序</title>
      <link href="/article/674/"/>
      <url>/article/674/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。归并操作也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><p>二、<strong>实现思路及代码</strong></p><p>首先来看一下归并操作，和之前一样，仍然按照个人习惯使用递归的方法（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li></ol><ol start="2"><li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li></ol><ol start="3"><li>重复步骤2，直到所有元素排序完毕</li></ol><p>例如对于序列[6, 202, 100, 301, 38, 8, 1]，其归并步骤如下：</p><p><img src="/images/2017/04/Snip20170403_3.png" alt="Snip20170403_3"></p><p>下面是从网上找的一张归并排序gif图：</p><p><img src="/images/2017/01/20160917001326254.gif" alt="20160917001326254"></p><p>Swift实现：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">func mergeSort(_ array: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数组中的每一个元素放入一个数组中</span></span><br><span class="line">    <span class="selector-tag">var</span> tempArray: Array&lt;Array&lt;Int&gt;&gt; = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="selector-tag">var</span> subArray: Array&lt;Int&gt; = []</span><br><span class="line">        subArray.append(item)</span><br><span class="line">        tempArray.append(subArray)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对这个数组中的数组进行合并，直到合并完毕为止</span></span><br><span class="line">    while tempArray<span class="selector-class">.count</span> != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span></span><br><span class="line">        while <span class="selector-tag">i</span> &lt; tempArray<span class="selector-class">.count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            tempArray[i] = _mergeArray(tempArray[i], tempArray[<span class="selector-tag">i</span> + <span class="number">1</span>])</span><br><span class="line">            tempArray.remove(at: <span class="selector-tag">i</span> + <span class="number">1</span>)</span><br><span class="line">            <span class="selector-tag">i</span> = <span class="selector-tag">i</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return tempArray.first!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个有序数组进行合并</span></span><br><span class="line">func _mergeArray(_ firstArray: Array&lt;Int&gt;, _ secondArray: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">    <span class="selector-tag">var</span> resultArray: Array&lt;Int&gt; = []</span><br><span class="line">    <span class="selector-tag">var</span> firstIndex = <span class="number">0</span></span><br><span class="line">    <span class="selector-tag">var</span> secondIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    while firstIndex &lt; firstArray<span class="selector-class">.count</span> &amp;&amp; secondIndex &lt; secondArray<span class="selector-class">.count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> firstArray[firstIndex] &lt; secondArray[secondIndex] &#123;</span><br><span class="line">            resultArray.append(firstArray[firstIndex])</span><br><span class="line">            firstIndex += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultArray.append(secondArray[secondIndex])</span><br><span class="line">            secondIndex += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while firstIndex &lt; firstArray<span class="selector-class">.count</span> &#123;</span><br><span class="line">        resultArray.append(firstArray[firstIndex])</span><br><span class="line">        firstIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while secondIndex &lt; secondArray<span class="selector-class">.count</span> &#123;</span><br><span class="line">        resultArray.append(secondArray[secondIndex])</span><br><span class="line">        secondIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return resultArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之快速排序</title>
      <link href="/article/672/"/>
      <url>/article/672/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>快速排序又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n² )次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>二、<strong>实现思路及代码</strong></p><p>假设对下面数组排序：</p><p><img src="/images/2017/03/1.png" alt="1"></p><p>我们设置两个变量 l、r，并且 l=0、r=n-1，在此数组中 r=5。</p><p>再设置个基准数字 p ，起始时 p 为数组第一个元素，在此数组中 p=6；</p><p>现在开始查找，从 r 开始往前查找比 p 小的元素，即r—，当找到第一个比 p 小的的元素后交换 p 和这个元素。</p><p>在上面数组中，r 往前查找找到的第一个比 p 小的元素为3（下标也为3），交换3和6。如下：</p><p><img src="/images/2017/03/2.png" alt="2"></p><p>此时l=0、r=3、p=6。</p><p>下一步从l往后查找比 p 大的元素，即 l++，当找到第一个比 p 大的元素后交换 p 和这个元素。</p><p>在上面数组中，l往后查找找到的第一个比 p 大的元素为7（下标为2），交换7和6。如下：</p><p><img src="/images/2017/03/3.png" alt="3"></p><p>此时 l=2、r=3、p=6。</p><p>上面两次查找为一个查找循环。</p><p>仔细思考会发现上面l和r是有规律的，即 <strong>l 之前的元素永远小于 r 之后的元素</strong>，因为l之前的元素小于 p，而 r 之后的元素大于 p。所以，<strong>查找结束的标志为 l &gt;= r</strong>。</p><p>但是一次查找结束后数组还并不是有序的，这时候可以发现 p 把数组分成了两部分，我们对 p 两边的数据，再分别进行上述的过程，直到不能再分组为止，等不能再分组的时候，数组就已经排序完成了。</p><p>我从维基百科拿了一张快速排序的GIF图，如下（下图中选取的每部分最后一个元素作为基准数字 p）：</p><p><img src="/images/2017/04/Sorting_quicksort_anim.gif" alt="Sorting_quicksort_anim"></p><p>接下来就是使用 Swift 去实现快速排序，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">right</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l &lt; r  &#123;</span><br><span class="line">        <span class="keyword">while</span> l &lt; r &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> arr[r] &gt;= arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> arr[l] &lt; arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">                _swap(&amp;arr, l, r)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        _swap(&amp;arr, <span class="keyword">left</span>, l)</span><br><span class="line">        <span class="built_in">quickSort</span>(&amp;arr,<span class="keyword">left</span>,l)</span><br><span class="line">        <span class="built_in">quickSort</span>(&amp;arr,l+<span class="number">1</span>,<span class="keyword">right</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_swap</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[<span class="keyword">left</span>]</span><br><span class="line">    arr[<span class="keyword">left</span>] = arr[<span class="keyword">right</span>]</span><br><span class="line">    arr[<span class="keyword">right</span>] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之翻转二叉树</title>
      <link href="/article/669/"/>
      <url>/article/669/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong><br>HomeBrew作者、天才程序员Max Howell兴致盎然地去Google面试，结果却因不会在白板上翻转二叉树被Google粗鲁地拒绝了，重要的是 Google 中90%的员工都在使用HomeBrew，Max Howell的被拒一时间舆论甚是哗然。在知乎（<a href="https://www.zhihu.com/question/31202353" target="_blank" rel="noopener">点击查看</a>）上也曾展开过激烈的讨论。虽然如此，也阻挡不了我对Max Howell的敬佩。</p><p>二、<strong>实现思路及代码</strong><br>翻转二叉树就是要实现下图：</p><p><img src="/images/2017/03/Snip20170331_2.png" alt="Snip20170331_2"></p><p>其实这和翻转字符串差不多，个人习惯使用递归，接下来就直接上代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻转二叉树</span></span><br><span class="line">    func invertBinaryTree(_ note:BinaryTreeNote) &#123;</span><br><span class="line">        </span><br><span class="line">        let tempLeftChild = note.leftChild</span><br><span class="line">        note<span class="selector-class">.leftChild</span> = note.rightChild</span><br><span class="line">        note<span class="selector-class">.rightChild</span> = tempLeftChild</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> let leftChild = note<span class="selector-class">.leftChild</span> &#123;</span><br><span class="line">            invertBinaryTree(leftChild)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> let rightChild = note<span class="selector-class">.rightChild</span> &#123;</span><br><span class="line">            invertBinaryTree(rightChild)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之二叉树</title>
      <link href="/article/661/"/>
      <url>/article/661/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>二叉树的结构一般是以二叉链表的形式来存储的。二叉链表的结构类似于双向链表，二叉链表的节点也是有两个结点指针的，一个指向左子树，一个指向右子树。二叉树主要有四种遍历方式：先序遍历、中序遍历、后序遍历、层次遍历。关于二叉树的内容网上有很多，这里不再做过多的陈述。</p><p>本文将用Swift去实现二叉树的创建、四种遍历方式等。<em>下面的实现部分内容参考了青玉伏案和唐巧两位大神相关的文章</em>。</p><p>二、<strong>实现思路及代码</strong></p><p>以下面二叉树为例：</p><p><img src="/images/2017/03/545446-20160929150423203-118885735.png" alt="545446-20160929150423203-118885735"></p><p>先序遍历：先遍历根节点然后再遍历左子树，最后遍历右子树。</p><p><img src="/images/2017/03/Snip20170331_6.png" alt="Snip20170331_6"></p><p>故上面先序遍历的顺序为： A B D E C F</p><p>不过为了看到更详细的步骤可以把上面 C 结点的左子节点的 value 值打印为#号，类似的D、E、F也一样，他们的左右子节点的 value 值都打印为#号，则打印结果为：A B D # # E # # C # F # #</p><p>中序遍历：先遍历左子树，然后遍历根节点，最后遍历右子树。</p><p><img src="/images/2017/03/Snip20170331_7.png" alt="Snip20170331_7"></p><p>故上面先序遍历的顺序为：# D # B # E # A # C # F #</p><p>后序遍历：后序遍历是先遍历左子树，然后再遍历右子树，最后遍历根节点</p><p><img src="/images/2017/03/Snip20170331_8.png" alt="Snip20170331_8"></p><p>故上面先序遍历的顺序为：# # D # # E B # # # F C A</p><p>层次遍历：层次遍历相对上面的几个遍历实现起来要稍微复杂，层次遍历就是图中以二叉树的根节点为起始节点的广度搜索（BFS）</p><p><img src="/images/2017/03/Snip20170331_9.png" alt="Snip20170331_9"></p><p>故上面先序遍历的顺序为：A B C D E # F # # # # # #</p><p>下面为上述几种遍历的Swift实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNote</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> value:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> leftChild:<span class="type">BinaryTreeNote</span>?</span><br><span class="line">    <span class="keyword">var</span> rightChild:<span class="type">BinaryTreeNote</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeHelper</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> array:[<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">var</span> index = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> array:[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.array = array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createTree</span><span class="params">()</span></span> -&gt; <span class="type">BinaryTreeNote</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.index = <span class="keyword">self</span>.index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.array.<span class="built_in">count</span> &amp;&amp; index &gt;= <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">self</span>.array[index]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">""</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> note = <span class="type">BinaryTreeNote</span>(value)</span><br><span class="line">                note.leftChild = createTree()</span><br><span class="line">                note.rightChild = createTree()</span><br><span class="line">                <span class="keyword">return</span> note</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="number">_</span> note:BinaryTreeNote?)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> note == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(note!.value)</span><br><span class="line">        preOrderTraverse(note!.leftChild)</span><br><span class="line">        preOrderTraverse(note!.rightChild)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inOrderTraverse</span> <span class="params">(<span class="number">_</span> note: BinaryTreeNote?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> note == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraverse(note!.leftChild)</span><br><span class="line">        <span class="built_in">print</span>(note!.value)</span><br><span class="line">        inOrderTraverse(note!.rightChild)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">afterOrderTraverse</span> <span class="params">(<span class="number">_</span> note: BinaryTreeNote?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> note == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        afterOrderTraverse(note!.leftChild)</span><br><span class="line">        afterOrderTraverse(note!.rightChild)</span><br><span class="line">        <span class="built_in">print</span>(note!.value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//层次遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(<span class="number">_</span> root: BinaryTreeNote?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = [[<span class="type">BinaryTreeNote</span>]]()</span><br><span class="line">        <span class="keyword">var</span> level = [<span class="type">BinaryTreeNote</span>]()</span><br><span class="line">        </span><br><span class="line">        level.append(root!)</span><br><span class="line">        <span class="keyword">while</span> level.<span class="built_in">count</span> != <span class="number">0</span> &#123;</span><br><span class="line">            result.append(level)</span><br><span class="line">            <span class="keyword">var</span> nextLevel = [<span class="type">BinaryTreeNote</span>]()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> leftNode = node.leftChild &#123;</span><br><span class="line">                    nextLevel.append(leftNode)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> rightNode = node.rightChild &#123;</span><br><span class="line">                    nextLevel.append(rightNode)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level = nextLevel</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ans = result.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.value &#125;&#125;</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之栈和队列</title>
      <link href="/article/658/"/>
      <url>/article/658/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>栈和队列在数据结构中是比较重要的一个数据结构。其实对于栈和队列并不需要太深入的介绍，栈和队列的核心内容是栈是先进后出、队列是先进先出。在实际开发中有些场景也可能会用到，比如 APP 中用户可以撤销操作，比如下棋 APP 中的悔棋操作，返回上一步就是先进后出（后进先出），也就是栈的特性。比如在售票 APP 中，为先下订单的用户先出票，就需要用到队列。当然这两个只是在简单场景下的情况，实际开发中情况可能更复杂，比如售票 APP 为会员用户优先出票等。</p><p><img src="/images/2017/03/Snip20170328_5.png" alt="Snip20170328_5"></p><p>接下来就通过 Swift 去实现栈和队列。</p><p>二、<strong>实现思路及代码</strong></p><p>直接上代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> stack: [<span class="type">AnyObject</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">stack = [<span class="type">AnyObject</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">stack.append(object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">if</span> !isEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> stack.removeLast()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">return</span> stack.last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stack.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> queue: [<span class="type">AnyObject</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">queue = [<span class="type">AnyObject</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">queue.append(object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">if</span> !isEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> queue.removeFirst()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> queue.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">return</span> queue.first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> queue.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之查找第K大的元素</title>
      <link href="/article/654/"/>
      <url>/article/654/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>这道算法题是《编程之美》中比较经典的一题，解法也有很多，《编程之美》里面基本上介绍了五种解法:</p><p>（a）排序O(NlogN) 或者O(KN)</p><p>（b）快速排序，平均时间O(N)，最坏的可以是O(N^2)，这里书里面是不管怎么样都两边都排序, 所以书里面的平均时间复杂度是O(NlogN)，但是对于这道题没必要两边都排序，具体的后面会讲，这也是本文使用的一种解法</p><p>（c） 二分搜索第K个元素，在数据分布比较好的情况下也是O(NlogN)</p><p>（d）建立一个大小是K的堆，然后线性扫每个元素， 并且根据大小情况更新堆， 时间复杂度O(NlogK)</p><p>（e）哈希统计每个数字的频率，时间复杂度和最大的数有关</p><p>题目：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一个大小为 <span class="built_in">n</span> 的无序数组，求其中第k大的数</span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>我们使用上面提到的方法  b 去实现。首先先看下什么是快速排序，已经对快速排序很了解的可以忽略。</p><p>假设对下面数组排序：</p><p><img src="/images/2017/03/1.png" alt="1"></p><p>我们设置两个变量 l、r，并且 l=0、r=n-1，在此数组中 r=5。</p><p>再设置个基准数字 p ，起始时 p 为数组第一个元素，在此数组中 p=6；</p><p>现在开始查找，从 r 开始往前查找比 p 小的元素，即r—，当找到第一个比 p 小的的元素后交换 p 和这个元素。</p><p>在上面数组中，r 往前查找找到的第一个比 p 小的元素为3（下标也为3），交换3和6。如下：</p><p><img src="/images/2017/03/2.png" alt="2"></p><p>此时l=0、r=3、p=6。</p><p>下一步从l往后查找比 p 大的元素，即 l++，当找到第一个比 p 大的元素后交换 p 和这个元素。</p><p>在上面数组中，l往后查找找到的第一个比 p 大的元素为7（下标为2），交换7和6。如下：</p><p><img src="/images/2017/03/3.png" alt="3"></p><p>此时 l=2、r=3、p=6。</p><p>上面两次查找为一个查找循环。</p><p>仔细思考会发现上面l和r是有规律的，即 <strong>l 之前的元素永远小于 r 之后的元素</strong>，因为l之前的元素小于 p，而 r 之后的元素大于 p。所以，<strong>查找结束的标志为 l &gt;= r</strong>。</p><p>但是一次查找结束后数组还并不是有序的，这时候可以发现 p 把数组分成了两部分，我们对 p 两边的数据，再分别进行上述的过程，直到不能再分组为止，等不能再分组的时候，数组就已经排序完成了。</p><p>注意，一次查找结束后数组可能不是有序的，但是 p 已经处在了排序后的正确位置，这个是我们解决本题的关键！</p><p>我们可以先用快速排序将数组排好序，然后在取出第 k 大的数，但是这并不是最好的解决办法，因为我们压根没有必要对数组进行排序。题目要求是找出第 k 大的数，并不是要求一定先排序。</p><p>上面说了，一次查找结束 p 已经处在了正确的位置，假设一次查找结束时 k 的下标为 pos ，那么：</p><ol><li>当 pos == k，说明p就是第k大的，直接返回；</li></ol><ol start="2"><li>当 pos &gt; k, 说明第k大的一定在p左边，继续对左边 [left, pos - 1] 进行搜索；</li></ol><ol start="3"><li>当 pos &lt; k, 说明第k大的在p右边了，继续对右边 [pos + 1, right] 进行搜索。</li></ol><p>下面为上述思路的Swift实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求数组第K大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(<span class="number">_</span> arr:[Int],<span class="number">_</span> k:Int)</span></span>-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arr = arr</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = arr.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="comment">//升序排列下第k大的数下标不是k而是arr.count - k，比如6个元素的数组，第1大的数字下标为6-1=5</span></span><br><span class="line">    <span class="keyword">let</span> k = arr.<span class="built_in">count</span> - k</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = _partion(&amp;arr,<span class="keyword">left</span>,<span class="keyword">right</span>)</span><br><span class="line">        <span class="keyword">if</span> pos == k &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[pos]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> pos &gt; k&#123;</span><br><span class="line">            <span class="comment">//在左边</span></span><br><span class="line">            <span class="keyword">right</span> = pos - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> pos &lt; k&#123;</span><br><span class="line">            <span class="comment">//在右边</span></span><br><span class="line">            <span class="keyword">left</span> = pos + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_partion</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span>-&gt;<span class="type">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">right</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l &lt; r &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> arr[r] &gt;= arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> arr[l] &lt; arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">            _swap(&amp;arr, l, r)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    _swap(&amp;arr, <span class="keyword">left</span>, l)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_swap</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[<span class="keyword">left</span>]</span><br><span class="line">    arr[<span class="keyword">left</span>] = arr[<span class="keyword">right</span>]</span><br><span class="line">    arr[<span class="keyword">right</span>] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之数组中出现次数超过一半的数字</title>
      <link href="/article/652/"/>
      <url>/article/652/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>这也是剑指 Offer 上的一道很经典的题，对于这道题，我们得分两种情况来讨论：有序和无序。如果数组是有序的，那就非常简单了，数组中间的那个数字一定是我们要求的那个出现次数超过一半的数字。如果数组是无序的，当然可以先将数组进行排序，然后去求中间的那位数字，除此之外是不是还有更简单的方法呢？</p><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个无序数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>对于此题可能有多种解法。</p><p>解法1：</p><p>先将数组进行排序，排过序之后求数组中间的那个数字，该数字就是那个出现次数超过一半的数字。</p><p>解法2：</p><p>借助 hash 表实现，hash 表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。然后直接遍历整个 hash 表 ，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可。</p><p>解法3：</p><p>遍历数组，比较相邻的两个数字，如果这两个数字<strong>不相等则同时删除这两个数字</strong>（不管是不是我们要查找的那个出现次数超过一半的数字），如果<strong>相等则保留这两个数字，从这两个数字中的后一个数字继续往后遍历</strong>，最后剩余的数字就是那个出现次数超过一半的数字。</p><p>例如下面数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>其变化为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>则 1 就是那个出现次数超过一半的数字。</p><p>解法4：</p><p>在遍历数组的时候保存两个值：num（用来保存数组中遍历到的某个数字）和count（用来表示当前数字的出现次数），count初始化为1。当我们遍历到数组中下一个数字的时候：</p><ul><li>如果下一个数字与之前num保存的数字相同，则count加1；</li></ul><ul><li>如果下一个数字与之前num保存的数字不同，则count减1；</li></ul><ul><li>每当出现次数count变为0后，用num保存下一个数字，并把count重新设为1。 直到遍历完数组中的所有数字为止。</li></ul><p>例如下面数组：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="string">[Int]</span> = <span class="string">[1, 1, 2, 1]</span></span><br></pre></td></tr></table></figure><p>（1）开始时num = data[0] = 1，count = 1</p><p>（2）遍历到data[1]，由于data[1] = num = 1，所以此时num = 1，count = count + 1 = 2</p><p>（3）遍历到data[2]，由于data[2] = 2 ≠ num，所以此时count = count - 1 = 1，由于count ≠ 0，故此时num不变，即num = 1</p><p>（4）遍历到data[3]，由于data[3] = num =1，所以此时count = count + 1 = 2，num = 1。遍历结束！</p><p>故出现次数超过一半的数字为num= 1</p><p>比较上面四种解法，解法1需要排序，如果使用效率较高的快速排序的话时间复杂度为O(n·logn)。解法2需要借助 Hash 表，不仅需要O(n)的空间开销还需要设计 hash 函数（当然也可以直接使用 Swift 中的字典）。可以明显发现解法3和解法4要比前两种解法更好一点。解法3和解法4差别不大，基本思想都是类似的，所以接下来使用 Swift 去实现解法4的算法。</p><p>上面已经给出了解法4的原理和思想，这里就直接上代码了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moreHalfNumber</span><span class="params">(data:[Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;data.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            num = data[i]</span><br><span class="line">            <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num == data[i] &#123;</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之链表倒数第k个结点</title>
      <link href="/article/648/"/>
      <url>/article/648/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>求链表倒数第k个结点是剑指 offer 上一道经典的算法题，并且还有很多类似的算法题，比如求链表的中间结点等，他们的解题思路都是一样的。解类似的题目，最笨的一个方法是先遍历一下整个链表，确定链表结点的数量后再根据数量找出倒数第k个结点或中间的那个结点。不过，本文并不去考虑这种笨办法，还有更好的实现方法。</p><p>题目描述：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第<span class="number">0</span>个节点为链表的尾指针。</span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>对于解决此类问题，最好的方法是使用两个指针实现，首先将第一个指针pNode前进 k 步，然后qNode才开始前进，后面pNode、qNode同时往前移动，当pNode指向尾结点时，pNode指向的结点就是倒数第k个结点。如下图：</p><p><img src="/images/2017/03/Snip20170322_6-1.png" alt="Snip20170322_6"></p><p>当然，链表和上篇文章一样（以后如果不特别说明则链表不变）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: LinkList?</span><br><span class="line">    <span class="keyword">init</span>(_ <span class="keyword">val</span>: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        value = <span class="keyword">val</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求链表倒数第k个结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">theKthLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> k:Int)</span></span>-&gt;<span class="type">LinkList</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pNode = linkList</span><br><span class="line">    <span class="keyword">var</span> tempK = k</span><br><span class="line">    <span class="comment">//pNode先前进k步</span></span><br><span class="line">    <span class="keyword">while</span> tempK &gt; <span class="number">0</span> &amp;&amp; pNode.next != <span class="literal">nil</span>&#123;</span><br><span class="line">        tempK -= <span class="number">1</span></span><br><span class="line">        pNode = pNode.next!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果到这里仍然tempK &gt; 0说明k大于结点总数</span></span><br><span class="line">    <span class="keyword">if</span>(tempK &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"k的值过大不合法！"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//之后qNode从头结点开始跟着pNode一起前进，直到pNode为尾结点</span></span><br><span class="line">    <span class="keyword">var</span> qNode = linkList</span><br><span class="line">    <span class="keyword">while</span> pNode.next != <span class="literal">nil</span>&#123;</span><br><span class="line">        pNode = pNode.next!</span><br><span class="line">        qNode = qNode.next!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> qNode</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是就链表倒数第k个结点的方法。</p><p>对于求链表中间的那个结点（<em>题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点</em>），实现方法还是类似的。也是使用pNode和qNode两个指针实现，方法是。用两个指针pNode和qNode从链表头节点开始，pNode每次向后移动两步，qNode每次移动一步，直到pNode移到到尾节点，那么qNode就是中间结点。</p><p>还有一题类似的是判断单链表是否存在环（<em>题目描述：输入一个单向链表，判断链表是否有环？</em>），解题思想还是一样的，通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p><p>感兴趣的可以自己敲着试下。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之链表</title>
      <link href="/article/645/"/>
      <url>/article/645/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p>本文将用Swift去实现链表的增删改查：</p><p>（1）查找链表：按序号查找、按值查找定位</p><p>（2）插入结点</p><p>（3）删除结点</p><p>（4）修改结点</p><p>二、<strong>实现思路及代码</strong></p><p>首先先定义一下链表结点的数据结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: LinkList?</span><br><span class="line">    <span class="keyword">init</span>(_ <span class="keyword">val</span>: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        value = <span class="keyword">val</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于链表的查找，其实很简单，无外乎就是链表的遍历，所以不做过多描述，直接上代码。下面两个查找（按序号查找、按值查找定位）算法时间复杂度都为O(n)</p><p>1、查找链表</p><p>（1）按序号查找</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、按序号查找：查找第index位置上的结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> index:Int)</span></span>-&gt;<span class="type">LinkList</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> linkList = linkList</span><br><span class="line">    <span class="keyword">var</span> tempIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> linkList.next != <span class="literal">nil</span> &amp;&amp; tempIndex &lt; index &#123;</span><br><span class="line">        linkList = linkList.next!</span><br><span class="line">        tempIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> tempIndex == index &#123;</span><br><span class="line">        <span class="keyword">return</span> linkList</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）按值查找定位</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、按值查找定位：获取指定value值的结点在链表中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">locLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> value:Int)</span></span>-&gt;<span class="type">Int</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> linkList = linkList</span><br><span class="line">    <span class="keyword">var</span> tempIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> linkList.value != value &amp;&amp; linkList.next != <span class="literal">nil</span>&#123;</span><br><span class="line">        linkList = linkList.next!</span><br><span class="line">        tempIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> linkList.value == value &#123;</span><br><span class="line">        <span class="keyword">return</span> tempIndex</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、插入结点</p><p>想要在index位置插入结点，首先就要拿到index位置结点的前驱结点，然后通过改变结点的next值去实现结点的插入，如下图：</p><p><img src="/images/2017/03/Snip20170322_1.png" alt="Snip20170322_1"></p><p>算法实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入结点：在index位置插入指定value值的结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> value:Int,<span class="number">_</span> index:Int)</span></span>-&gt;<span class="type">LinkList</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pNode = getLinkList(linkList,index-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> pNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="type">LinkList</span>(value)</span><br><span class="line">        newNode.next = pNode?.next</span><br><span class="line">        pNode?.next = newNode</span><br><span class="line">        <span class="keyword">return</span> linkList</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、删除结点</p><p>删除结点的原理和插入结点类似，也是拿到index位置结点的前驱结点，然后重置该前驱结点的next值为要删除结点的后一个结点，如下图：</p><p><img src="/images/2017/03/Snip20170322_2.png" alt="Snip20170322_2"></p><p>算法实现如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//删除结点：删除<span class="built_in">index</span>位置的结点</span><br><span class="line">func delLinkList(_ linkLis<span class="variable">t:LinkList</span>,_ <span class="built_in">index</span>:Int)-&gt;LinkList?&#123;</span><br><span class="line">    </span><br><span class="line">    //如果是头结点，则直接返回头结点的下一个结点</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkList.<span class="keyword">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //先拿到要删除的结点的上一个结点</span><br><span class="line">    <span class="keyword">let</span> pNode = getLinkList(linkList, <span class="built_in">index</span>-<span class="number">1</span>)</span><br><span class="line">    //不存在<span class="built_in">index</span>位置结点直接<span class="keyword">return</span> nil</span><br><span class="line">    <span class="keyword">if</span> pNode?.<span class="keyword">next</span> == nil &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"不存在index位置结点！"</span>)</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">    pNode?.<span class="keyword">next</span> = pNode?.<span class="keyword">next</span>?.<span class="keyword">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> linkList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改结点</p><p>修改结点要比插入、删除简单一点，只要拿到该结点然后修改其value值即可。</p><p>算法实现如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改结点：修改index位置的结点</span></span><br><span class="line">func updateLinkList(<span class="literal">_</span> linkList:<span class="type">LinkList</span>,<span class="literal">_</span> index:<span class="type">Int</span>,<span class="literal">_</span> <span class="keyword">new</span><span class="type">Value</span>:<span class="keyword">Int</span>)-&gt;LinkList?&#123;</span><br><span class="line"></span><br><span class="line">    let pNode = getLinkList(linkList, index)</span><br><span class="line">    pNode?.value = <span class="keyword">new</span><span class="type">Value</span></span><br><span class="line"><span class="type"></span>    </span><br><span class="line">    <span class="keyword">return</span> linkList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是用Swift实现的链表的增删改查，大家如果感兴趣可以试着实现删除指定value值的结点和修改指定value值的结点算法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之逐字翻转字符串</title>
      <link href="/article/643/"/>
      <url>/article/643/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>翻转字符串在字符串算法中算是比较常见的，而且被很多公司用作笔试题。”逐字翻转字符串”是翻转字符串的翻版，也是之前Google的面试题，原题是这样的：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="keyword">an</span> input <span class="keyword">string</span>, reverse <span class="keyword">the</span> <span class="keyword">string</span> <span class="built_in">word</span> <span class="keyword">by</span> <span class="built_in">word</span>.</span><br><span class="line">A <span class="built_in">word</span> is defined <span class="keyword">as</span> <span class="keyword">a</span> sequence <span class="keyword">of</span> non-<span class="literal">space</span> <span class="keyword">characters</span>.</span><br><span class="line">The input <span class="keyword">string</span> does <span class="keyword">not</span> contain leading <span class="keyword">or</span> trailing spaces <span class="keyword">and</span> <span class="keyword">the</span> <span class="keyword">words</span> are always separated <span class="keyword">by</span> <span class="keyword">a</span> single <span class="literal">space</span>.</span><br><span class="line">For example,</span><br><span class="line">Given s = <span class="string">"the sky is blue"</span>,</span><br><span class="line"><span class="literal">return</span> <span class="string">"blue is sky the"</span>.</span><br><span class="line">Could you <span class="built_in">do</span> <span class="keyword">it</span> <span class="keyword">in</span>-place <span class="keyword">without</span> allocating extra <span class="literal">space</span>?</span><br></pre></td></tr></table></figure><p>简而言之就是：”the sky is blue”—&gt;”blue is sky the”</p><p>所以，对于本文，要解决的算法是：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逐字翻转字符串，例如：<span class="comment">"the sky is blue"</span>—&gt;<span class="comment">"blue is sky the"</span></span><br></pre></td></tr></table></figure><p>接下来看下实现思路和代码。</p><p>二、<strong>实现思路及代码</strong></p><p>既然是字符串翻转的翻版，我们就可以利用之前翻版字符串的思路去解决就可以了，不过这道题要有两次翻转：</p><p>第一次翻转，整体翻转：”the sky is blue” -&gt; “eulb si yks eht”</p><p>第二次翻转，单词翻转：”eulb si yks eht” -&gt; “blue is sky the”</p><p>所以，首先可以实现一个可以翻转局部和全部字符串的算法，传入字符数组、startIndex 和 endIndex ，其中 startIndex 和 endIndex 分别为要翻转的字符串的起始下标和结束下标，也就是要翻转 startIndex 和 endIndex 之间（包含）的字符，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_reverseStr</span><span class="params">( <span class="number">_</span> chars:<span class="keyword">inout</span> [Character], <span class="number">_</span> startIndex:Int, <span class="number">_</span> endIndex:Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> startIndex = startIndex</span><br><span class="line">    <span class="keyword">var</span> endIndex = endIndex</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> startIndex &lt;= endIndex &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> tempChar = chars[endIndex]</span><br><span class="line">        chars[endIndex] = chars[startIndex]</span><br><span class="line">        chars[startIndex] = tempChar</span><br><span class="line">        </span><br><span class="line">        startIndex += <span class="number">1</span></span><br><span class="line">        endIndex -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        _reverseStr(&amp;chars,startIndex,endIndex)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以利用上面的算法去完成前面说的两次翻转：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(<span class="number">_</span> str:String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chars = [<span class="type">Character</span>](str.characters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先翻转整个字符串所有字符,"the sky is blue" -&gt; "eulb si yks eht"</span></span><br><span class="line">    _reverseStr(&amp;chars,<span class="number">0</span>,chars.<span class="built_in">count</span>-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后翻转每个单词中的字符，"eulb si yks eht" -&gt; "blue is sky the"</span></span><br><span class="line">    <span class="keyword">var</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> endIndex <span class="keyword">in</span> <span class="number">0</span> ..&lt; chars.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> endIndex == chars.<span class="built_in">count</span> - <span class="number">1</span> || chars[endIndex + <span class="number">1</span>] == <span class="string">" "</span> &#123;</span><br><span class="line">            _reverseStr(&amp;chars, startIndex, endIndex)</span><br><span class="line">            startIndex = endIndex + <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(chars)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整算法代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻转指定范围的字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_reverseStr</span><span class="params">( <span class="number">_</span> chars:<span class="keyword">inout</span> [Character], <span class="number">_</span> startIndex:Int, <span class="number">_</span> endIndex:Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> startIndex = startIndex</span><br><span class="line">    <span class="keyword">var</span> endIndex = endIndex</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> startIndex &lt;= endIndex &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> tempChar = chars[endIndex]</span><br><span class="line">        chars[endIndex] = chars[startIndex]</span><br><span class="line">        chars[startIndex] = tempChar</span><br><span class="line">        </span><br><span class="line">        startIndex += <span class="number">1</span></span><br><span class="line">        endIndex -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        _reverseStr(&amp;chars,startIndex,endIndex)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐字翻转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(<span class="number">_</span> str:String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chars = [<span class="type">Character</span>](str.characters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先翻转整个字符串所有字符,"the sky is blue" -&gt; "eulb si yks eht"</span></span><br><span class="line">    _reverseStr(&amp;chars,<span class="number">0</span>,chars.<span class="built_in">count</span>-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后翻转每个单词中的字符，"eulb si yks eht" -&gt; "blue is sky the"</span></span><br><span class="line">    <span class="keyword">var</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> endIndex <span class="keyword">in</span> <span class="number">0</span> ..&lt; chars.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> endIndex == chars.<span class="built_in">count</span> - <span class="number">1</span> || chars[endIndex + <span class="number">1</span>] == <span class="string">" "</span> &#123;</span><br><span class="line">            _reverseStr(&amp;chars, startIndex, endIndex)</span><br><span class="line">            startIndex = endIndex + <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(chars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseWords(<span class="string">"the sky is blue"</span>) <span class="comment">//return "blue is sky the"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift算法实现之字符串转数字</title>
      <link href="/article/641/"/>
      <url>/article/641/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>学完Swift之后一直没有机会实战，由于Swift发展历史原因，目前网上大部分的算法都是使用C、Java或其他语言实现的，几乎没有使用Swift实现的，所以自己打算使用Swift去实现一些主流的算法，既是对自己Swift的回顾，也是对自己算法方面的提高。</p><p>首先是用Swift实现字符串转数字，当然，肯定是不能使用Swift自带的字符串转数字的api。</p><p>题目：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用Swift实现一个方法，输入字符串，输出该字符串转换成的数字。</span><br><span class="line">例如，输入字符串“<span class="number">125</span>”，输出数字<span class="number">125</span></span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>首先先考虑可能输入情况，包括非法输入：</p><ul><li>情况1：所有字符均可直接转换成数字，如”125”</li></ul><ul><li>情况2：包含一个或多个正负号，如”-125”、”–+125”</li></ul><ul><li>情况3：包含非法字符，如”125lff”</li></ul><p>如果是情况1，处理起来将会非常简单：首先利用ASCII编码将字符串“125”的每个字符转换为数字，之后转换成数字后直接用乘法和加法即可：1<em>100+2</em>10+3=123。</p><p>但是实际情况并不那么简单，由于情况2和情况3的存在，上面直接用乘法和加法肯定不可行的，中间还得加上相应的判断。最佳的方式是我们直接遍历字符串中的字符，先假设没有正负号和非法字符的存在，当遍历到第一个字符”1”的时候，intStr=1，当遍历到第二个字符”2”的时候，intStr = intStr<em>10+2=12，当遍历到最后一个字符”3”的时候,intStr = intStr</em>10+3=123。</p><p>关于”+”和”-“，只有当它们在字符串的开头的时候才表示正负，在字符串中间存在就是非法字符。我们可以通过ASCII编码判断”+”和”-“（对应的值分别为43和45），设个变量s表示多个”+”和”-“累积之后的正负。最后结果为intStr = s * intStr。当遍历字符串过程中发现了非法字符，则终止后续遍历，并给出提示。</p><p>实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrToInt</span><span class="params">(str:String)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串不能为空</span></span><br><span class="line">    <span class="keyword">guard</span> str.isEmpty == <span class="literal">false</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"字符串不能为空~"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> strInt:<span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> characterInt <span class="keyword">in</span> str.unicodeScalars &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只能包含数字或正负号</span></span><br><span class="line">        <span class="keyword">let</span> tempStrInt = characterInt.hashValue  - <span class="string">"0"</span>.unicodeScalars.first!.hashValue</span><br><span class="line">        <span class="keyword">guard</span> (tempStrInt &lt;= <span class="number">9</span> &amp;&amp; tempStrInt &gt;= <span class="number">0</span>) || (characterInt.hashValue == <span class="number">43</span> || characterInt.hashValue == <span class="number">45</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"包含非法字符！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正负号只能存在于字符串开头</span></span><br><span class="line">        <span class="keyword">if</span> characterInt.hashValue == <span class="number">43</span> || characterInt.hashValue == <span class="number">45</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> strInt == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"正负号只能存在于字符串开头！"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//既然走到这一步，说明字符串合法</span></span><br><span class="line">        <span class="comment">//判断正负数</span></span><br><span class="line">        <span class="keyword">if</span> characterInt.hashValue == <span class="number">43</span> || characterInt.hashValue == <span class="number">45</span>&#123;</span><br><span class="line">            s = s * ( <span class="number">44</span> - characterInt.hashValue )</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> strInt == <span class="literal">nil</span> &#123;</span><br><span class="line">                strInt = characterInt.hashValue - <span class="string">"0"</span>.unicodeScalars.first!.hashValue</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//使用溢出运算符&amp;*和&amp;+避免数值过大导致溢出崩溃</span></span><br><span class="line">                strInt = strInt! &amp;* <span class="number">10</span> &amp;+ ( characterInt.hashValue - <span class="string">"0"</span>.unicodeScalars.first!.hashValue )  </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result:<span class="type">Int</span>? = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> strInt != <span class="literal">nil</span> &#123;</span><br><span class="line">        result = s * strInt!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现的算法中：</p><p>输入”125”，输出125</p><p>输入”+-125”，输出-125</p><p>输入”1-25”，提示”正负号只能存在于字符串开头！”</p><p>输入”1m25”，提示”包含非法字符”</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 LLDB 调试 APP</title>
      <link href="/article/622/"/>
      <url>/article/622/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>LLDB全称 [ Low Level Debugger ], 默认内置于Xcode中的动态调试工具。标准的 LLDB 提供了一组广泛的命令，旨在与熟悉的 GDB 命令兼容。 除了使用标准配置外，还可以很容易地自定义 LLDB 以满足实际需要。</p><p>二、<strong>LLDB调试命令</strong></p><p>首先先通过一个简单的例子体验下 LLDB 调试：</p><p><img src="/images/2017/03/Snip20170313_1.png" alt="Snip20170313_1"></p><p>我们在上面第25行添加了断点，运行后程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。我们使用 _print _命令打印 age 的值：</p><p><img src="/images/2017/03/Snip20170313_2.png" alt="Snip20170313_2"></p><p>如上图，输入 _print age _命令回车即可打印出 age 的值，结果前的 $0 可以用来指向这个结果。例如我们使用 _print $0 + 5 _命令测试一下：</p><p><img src="/images/2017/03/Snip20170313_3.png" alt="Snip20170313_3"></p><p>如上图可知 _print $0 + 5 _相当于 _print age + 5 _。</p><p>LLBD 语法结构：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;command&gt;</span> [<span class="symbol">&lt;subcommand&gt;</span> [<span class="symbol">&lt;subcommand&gt;</span>...]] <span class="symbol">&lt;action&gt;</span> [-<span class="keyword">options</span> [option-value]] [<span class="keyword">argument</span> [<span class="keyword">argument</span>...]]</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">command</span>&gt;</span>(命令)和<span class="tag">&lt;<span class="name">subcommand</span>&gt;</span>(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</span><br><span class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span>：执行命令的操作</span><br><span class="line"><span class="tag">&lt;<span class="name">options</span>&gt;</span>：命令选项</span><br><span class="line"><span class="tag">&lt;<span class="name">arguement</span>&gt;</span>：命令的参数</span><br><span class="line">[]：表示命令是可选的，可以有也可以没有</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint <span class="keyword">set</span> -f <span class="comment">main.m -l 16</span></span><br></pre></td></tr></table></figure><p>与上面语法结构对应的是：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">command:</span> breakpoint 添加断点命令</span><br><span class="line"><span class="symbol">action:</span> <span class="keyword">set</span> 表示设置断点</span><br><span class="line"><span class="symbol">option:</span> -f 表示在某文件添加断点</span><br><span class="line"><span class="symbol">arguement:</span> mian.m 表示要添加断点的文件名为mian.m</span><br><span class="line"><span class="symbol">option:</span> -l 表示某一行</span><br><span class="line"><span class="symbol">arguement:</span> <span class="number">16</span> 表示第<span class="number">16</span>行</span><br></pre></td></tr></table></figure><p>Commands，subcommands，options，option values和arguments都是以空格分隔的，双引号用于保护选项值和参数中的空格。 如果需要将反斜杠或双引号字符放入参数中，则在该参数前面加上反斜杠。 LLDB使用单引号和双引号是等价的。例如：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command <span class="string">[subcommand]</span> -option <span class="string">"some \"</span>quoted\<span class="string">" string"</span></span><br></pre></td></tr></table></figure><p>也可以这样写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">command</span> [subcommand] -<span class="keyword">option</span> 'some <span class="string">"quoted"</span> <span class="keyword">string</span>'</span><br></pre></td></tr></table></figure><p>上面的print命令只是LLDB调试中的一个很简单但很常用的命令，除此之外还有很多有可能用到的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">调试器命令:</span><br><span class="line"></span><br><span class="line">  apropos           <span class="comment">-- 列出与单词或主题相关的调试器命令</span></span><br><span class="line">  breakpoint        <span class="comment">-- 在断点上操作的命令 (详情使用'help b'查看)</span></span><br><span class="line">  bugreport         <span class="comment">-- 用于创建指定域的错误报告</span></span><br><span class="line">  command           <span class="comment">-- 用于管理自定义LLDB命令的命令</span></span><br><span class="line">  disassemble       <span class="comment">-- 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span></span><br><span class="line">  expression        <span class="comment">-- 求当前线程上的表达式的值。 以LLDB默认格式显示返回的值</span></span><br><span class="line">  frame             <span class="comment">-- 用于选择和检查当前线程的堆栈帧的命令</span></span><br><span class="line">  gdb-remote        <span class="comment">-- 通过远程GDB服务器连接到进程。 如果未指定主机，则假定为localhost</span></span><br><span class="line">  gui               <span class="comment">-- 切换到基于curses的GUI模式</span></span><br><span class="line">  <span class="keyword">help</span>              <span class="comment">-- 显示所有调试器命令的列表，或提供指定命令的详细信息</span></span><br><span class="line">  kdp-remote        <span class="comment">-- 通过远程KDP服务器连接到进程。 如果没有指定UDP端口，则假定端口41139</span></span><br><span class="line">  <span class="keyword">language</span>          <span class="comment">-- 指定源语言</span></span><br><span class="line">  <span class="keyword">log</span>               <span class="comment">-- 控制LLDB内部日志记录的命令</span></span><br><span class="line">  <span class="keyword">memory</span>            <span class="comment">-- 用于在当前目标进程的内存上操作的命令</span></span><br><span class="line">  platform          <span class="comment">-- 用于管理和创建平台的命令</span></span><br><span class="line">  <span class="keyword">plugin</span>            <span class="comment">-- 用于管理LLDB插件的命令</span></span><br><span class="line">  process           <span class="comment">-- 用于与当前平台上的进程交互的命令</span></span><br><span class="line">  quit              <span class="comment">-- 退出LLDB调试器</span></span><br><span class="line">  <span class="keyword">register</span>          <span class="comment">-- 命令访问当前线程和堆栈帧的寄存器</span></span><br><span class="line">  script            <span class="comment">-- 使用提供的代码调用脚本解释器并显示任何结果。 如果没有提供代码，启动交互式解释器。</span></span><br><span class="line">  <span class="keyword">settings</span>          <span class="comment">-- 用于管理LLDB设置的命令</span></span><br><span class="line">  <span class="keyword">source</span>            <span class="comment">-- 检查当前目标进程的调试信息所描述的源代码的命令</span></span><br><span class="line">  target            <span class="comment">-- 用于在调试器目标上操作的命令</span></span><br><span class="line">  <span class="keyword">thread</span>            <span class="comment">-- 用于在当前进程中的一个或多个线程上操作的命令</span></span><br><span class="line">  <span class="keyword">type</span>              <span class="comment">-- 在类型系统上操作的命令</span></span><br><span class="line">  <span class="keyword">version</span>           <span class="comment">-- 显示LLDB调试器版本</span></span><br><span class="line">  watchpoint        <span class="comment">-- 在观察点上操作的命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩写命令 (使用 <span class="string">'help command alias'</span>查看更多信息):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">add</span>-dsym  <span class="comment">-- ('target symbols add')  通过指定调试符号文件的路径，或使用选项指定下载符号的模块，将调试符号文件添加到目标的当前模块中的一个</span></span><br><span class="line">  attach    <span class="comment">-- ('_regexp-attach')  通过ID或名称附加到进程</span></span><br><span class="line">  b         <span class="comment">-- ('_regexp-break')  使用几种简写格式之一设置断点</span></span><br><span class="line">  bt        <span class="comment">-- ('_regexp-bt')  显示当前线程的调用堆栈。通过数字参数设置最多显示帧数。参数“all”显示所有线程</span></span><br><span class="line">  c         <span class="comment">-- ('process continue')  继续执行当前进程中的所有线程</span></span><br><span class="line">  <span class="keyword">call</span>      <span class="comment">-- ('expression --')  计算当前线程上的表达式,使用LLDB的默认格式显示返回的值</span></span><br><span class="line">  continue  <span class="comment">-- ('process continue')  继续执行当前进程中的所有线程</span></span><br><span class="line">  detach    <span class="comment">-- ('process detach')  脱离当前目标进程</span></span><br><span class="line">  di        <span class="comment">-- ('disassemble')  拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span></span><br><span class="line">  dis       <span class="comment">-- ('disassemble')  同上</span></span><br><span class="line">  display   <span class="comment">-- ('_regexp-display')  在每次停止时计算表达式（请参阅'help target stop-hook'）</span></span><br><span class="line">  down      <span class="comment">-- ('_regexp-down')  选择一个新的堆栈帧。默认为移动一个帧，数字参数可以指定值</span></span><br><span class="line">  env       <span class="comment">-- ('_regexp-env')  查看和设置环境变量的简写</span></span><br><span class="line">  <span class="keyword">exit</span>      <span class="comment">-- ('quit')  退出LLDB调试器</span></span><br><span class="line">  f         <span class="comment">-- ('frame select')  从当前线程中通过索引选择当前堆栈帧（参见'thread backtrace'）</span></span><br><span class="line">  <span class="keyword">file</span>      <span class="comment">-- ('target create')  使用参数作为主要可执行文件创建目标</span></span><br><span class="line">  <span class="keyword">finish</span>    <span class="comment">-- ('thread step-out')  完成当前堆栈帧的执行并返回后停止。 默认为当前线程</span></span><br><span class="line">  image     <span class="comment">-- ('target modules')  用于访问一个或多个目标模块的信息的命令</span></span><br><span class="line">  j         <span class="comment">-- ('_regexp-jump')  将程序计数器设置为新地址</span></span><br><span class="line">  jump      <span class="comment">-- ('_regexp-jump')  同上</span></span><br><span class="line">  <span class="keyword">kill</span>      <span class="comment">-- ('process kill')  终止当前目标进程</span></span><br><span class="line">  l         <span class="comment">-- ('_regexp-list')  使用几种简写格式之一列出相关的源代码</span></span><br><span class="line">  <span class="keyword">list</span>      <span class="comment">-- ('_regexp-list')  同上</span></span><br><span class="line">  n         <span class="comment">-- ('thread step-over')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  <span class="keyword">next</span>      <span class="comment">-- ('thread step-over')  同上</span></span><br><span class="line">  nexti     <span class="comment">-- ('thread step-inst-over')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  ni        <span class="comment">-- ('thread step-inst-over')  同上</span></span><br><span class="line">  p         <span class="comment">-- ('expression --')  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  parray    <span class="comment">-- ('expression -Z %1   --')  同上</span></span><br><span class="line">  po        <span class="comment">-- 计算当前线程上的表达式。显示由类型作者控制的格式的返回值。</span></span><br><span class="line">  poarray   <span class="comment">-- ('expression -O -Z %1    --')  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  print     <span class="comment">-- ('expression --')  同上</span></span><br><span class="line">  q         <span class="comment">-- ('quit')  退出LLDB调试器</span></span><br><span class="line">  r         <span class="comment">-- ('process launch -X true --')  在调试器中启动可执行文件</span></span><br><span class="line">  rbreak    <span class="comment">-- ('breakpoint set -r %1')  在可执行文件中设置断点或断点集</span></span><br><span class="line">  repl      <span class="comment">-- ('expression -r  -- ')  E计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  run       <span class="comment">-- ('process launch -X true --')  在调试器中启动可执行文件</span></span><br><span class="line">  s         <span class="comment">-- ('thread step-in')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  si        <span class="comment">-- ('thread step-inst')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  sif       <span class="comment">-- 遍历当前块，如果直接步入名称与TargetFunctionName匹配的函数，则停止</span></span><br><span class="line">  step      <span class="comment">-- ('thread step-in')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  stepi     <span class="comment">-- ('thread step-inst')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  t         <span class="comment">-- ('thread select')  更改当前选择的线程</span></span><br><span class="line">  tbreak    <span class="comment">-- ('_regexp-tbreak')  使用几种简写格式之一设置单次断点</span></span><br><span class="line">  undisplay <span class="comment">-- ('_regexp-undisplay')  每次停止时停止显示表达式（由stop-hook索引指定）</span></span><br><span class="line">  up        <span class="comment">-- ('_regexp-up')  选择较早的堆栈帧。 默认为移动一个帧，数值参数可以指定任意数字</span></span><br><span class="line">  x         <span class="comment">-- ('memory read')  从当前目标进程的内存中读取</span></span><br></pre></td></tr></table></figure><p>当然，上面大部分命令是不经常使用的，不用全部记住，需要查找想要的命令时可以直接使用”help”命令显示所有调试器命令的列表，或查询指定命令的详细信息。</p><p>三、<strong>LLDB调试示例</strong></p><p>1、打印命令</p><p>打印命令是在实际开发中是经常使用的，在前面的例子中就测试了使用<em>print</em>命令去打印 age 的值，除了 _print <em>命令外，还有多种打印命令：</em> p、po、call_。我们可以通过实际测试看下他们的区别：</p><p><img src="/images/2017/03/Snip20170313_5.png" alt="Snip20170313_5"></p><p>可以看到 _po _命令只是打印数值，而 _print、p、call _命令还打印了变量的类型。所以，在实际开发中根据需要选择合适的打印命令。</p><p>在打印变量的值的时候，我们还可以使用_ print/<fmt>_ 或者简化的 <em>p/<fmt></fmt></em>指定打印格式，例如打印十六进制:</fmt></p><p><img src="/images/2017/03/Snip20170313_7.png" alt="Snip20170313_7"></p><p>x 代表十六进制格式、t 代表二进制格式，其他格式类型请<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">点击这里</a>查看。</p><p>从前面的命令列表可以看到 _print、p、po、call _都是 _expression _命令的简写，而 _expression _的作用是“求当前线程上的表达式的值”，也就是说我们可以利用它们更改变量的值，例如我们将 age 的值修改为100：</p><p><img src="/images/2017/03/Snip20170313_6.png" alt="Snip20170313_6"></p><p>2、断点操作</p><p>要在调试器中创建断点，可以使用_ breakpoint set _命令:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">breakpoint <span class="keyword">set</span></span><br><span class="line">   -M &lt;<span class="function"><span class="keyword">method</span>&gt; <span class="params">( --<span class="keyword">method</span> &lt;<span class="keyword">method</span>&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">S</span> &lt;<span class="title">selector</span>&gt; <span class="params">( --<span class="keyword">selector</span> &lt;<span class="keyword">selector</span>&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">b</span> &lt;<span class="title">function</span>-<span class="title">name</span>&gt; <span class="params">( --basename &lt;<span class="keyword">function</span>-name&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">f</span> &lt;<span class="title">filename</span>&gt; <span class="params">( --file &lt;filename&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">l</span> &lt;<span class="title">linenum</span>&gt; <span class="params">( --line &lt;linenum&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">n</span> &lt;<span class="title">function</span>-<span class="title">name</span>&gt; <span class="params">( --name &lt;<span class="keyword">function</span>-name&gt; )</span></span></span><br><span class="line"><span class="function">…</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="builtin-name">set</span> -f ViewController.m -l 25</span><br><span class="line">Breakpoint 2: where = LLDBTest`-[ViewController lldbTest] + 50 at ViewController.m:25,<span class="built_in"> address </span>= 0x0000000102c90752</span><br></pre></td></tr></table></figure><p>上面含义为在 ViewController.m 文件的第25行添加断点。</p><p>也可以使用缩写形式  _br_。虽然 _b_ 是一个完全不同的命令 ( _regexp-break 的缩写)，但恰好也可以实现和上面同样的效果。</p><p>如果给当前的文件设置断点可以用下面的命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b 25</span><br><span class="line">Breakpoint 3: where = LLDBTest`-[ViewController lldbTest] + 50 at ViewController.m:25,<span class="built_in"> address </span>= 0x0000000102c90752</span><br></pre></td></tr></table></figure><p>也可以通过方法名设置断点：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="builtin-name">set</span> -n lldbTest</span><br><span class="line">Breakpoint 5: where = LLDBTest`-[ViewController lldbTest] + 23 at ViewController.m:23,<span class="built_in"> address </span>= 0x0000000102c90737</span><br></pre></td></tr></table></figure><p>上面 _-n _表示根据方法名设置断点。</p><p>查看所有断点：<em>breakpoint list</em> (或者 <em>br li</em>)</p><p>开启和关闭断点：<em>breakpoint enable <breakpointid></breakpointid></em> 和 <em>breakpoint disable <breakpointid>；</breakpointid></em></p><p>删除断点：<em>breakpoint delete <breakpointid></breakpointid></em></p><p>单步进入：<em>thread step-in</em>（或 <em>step</em> 或 _s_ ）</p><p>单步跳过：<em>thread step-over</em>（或 <em>next</em> 或 _n_）</p><p>继续运行：<em>thread continue</em>（或 <em>continue</em> 或 _c_）</p><p>3、设置观察点</p><p>通过上面的命令列表可以知道设置观察点使用 _watchpoint _命令，如果说 breakpoint 是对方法生效的断点，watchpoint就是对地址生效的断点，可以用他观察这个属性的地址。如果地址里面的东西改变了，就让程序中断。设置观察点可以用来观察变量或者属性值的变化。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">set</span> <span class="keyword">variable</span></span><br></pre></td></tr></table></figure><p>例如，我们要观察一个名为city的属性值：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">set</span> <span class="keyword">variable</span> <span class="comment">self-&gt;_city</span></span><br></pre></td></tr></table></figure><p>要特别注意，上面的”self-&gt;_city”不可以改为”self.city”，因为”self.city”是调用city的getter方法！</p><p>如下，我们新增一个city属性并设置观察点：</p><p><img src="/images/2017/03/Snip20170313_9.png" alt="Snip20170313_9"></p><p>由于在第27行我们修改（设置）了 city 的值，所以继续运行程序会中断并且打印提示：</p><p><img src="/images/2017/03/Snip20170313_10.png" alt="Snip20170313_10"></p><p>我们也可以使用下面命令直接观察某个地址的变化：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="builtin-name">set</span> expression</span><br></pre></td></tr></table></figure><p>比如我们要观察上面 city 属性的地址变化，应该怎么获取 city 的地址呢？可以使用上面的打印命令，通过打印命令获取到地址之后就可以观察地址的变化了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp; _city</span><br><span class="line">(NSString **) <span class="variable">$0</span> = 0x00007ffc80e100c8</span><br><span class="line">(lldb) watchpoint <span class="builtin-name">set</span> expression 0x00007ffc80e100c8</span><br><span class="line">Watchpoint created: Watchpoint 1: addr = 0x7ffc80e100c8 size = 8 state = enabled<span class="built_in"> type </span>= w</span><br><span class="line">    new value: 0</span><br></pre></td></tr></table></figure><p>_watchpoint _的查询、删除等命令与 _breakpoint _的命令使用一样，就不再一一列举用法了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">delete</span> </span><br><span class="line">watchpoint <span class="keyword">list</span></span><br><span class="line">watchpoint <span class="keyword">disable</span></span><br><span class="line">watchpoint <span class="keyword">enable</span></span><br></pre></td></tr></table></figure><p>4、打印线程堆栈信息</p><p>可以使用 thread backtrace（或_ bt_ ）命令打印线程堆栈信息：</p><p><img src="/images/2017/03/Snip20170313_11.png" alt="Snip20170313_11"></p><p>_thread backtrace _后面可以添加命令选项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c：设置打印堆栈的帧数(frame) </span></span><br><span class="line"><span class="deletion">-s：设置从哪个帧(frame)开始打印 </span></span><br><span class="line"><span class="deletion">-e：是否显示额外的回溯</span></span><br></pre></td></tr></table></figure><p>Debug 的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。可以使用 _thread return _命令：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="keyword">return</span> <span class="string">'要返回的值'</span></span><br></pre></td></tr></table></figure><p><em>thread return</em> 不让代码执行某个方法，可以在某个方法的开始位置设置一个断点，当程序运行到断点的位置时直接返回我们设置的返回值。</p><p>thread其他命令：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread</span> <span class="built_in">list</span> <span class="comment">//打印所有线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread</span> <span class="keyword">select</span> <span class="comment">//跳到某一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread</span> info <span class="comment">//输出当前线程的信息</span></span><br></pre></td></tr></table></figure><p>5、查看帧栈</p><p>打印当前帧栈所有变量：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame <span class="keyword">variable</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame <span class="keyword">variable</span></span><br><span class="line">(ViewController <span class="comment">*) self = 0x00007fc0684085f0</span></span><br><span class="line">(SEL) _cmd <span class="comment">=</span> <span class="comment">"lldbTest"</span></span><br><span class="line">(__NSCFConstantString <span class="comment">*) name = 0x0000000102a2f068 @</span><span class="comment">"lifengfeng"</span></span><br><span class="line">(NSInteger) age <span class="comment">= 25</span></span><br></pre></td></tr></table></figure><p>打印某个变量：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame <span class="keyword">variable</span> <span class="string">'变量名'</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame variable <span class="built_in">name</span></span><br><span class="line">(<span class="variable">__NSCFConstantString</span> *) <span class="built_in">name</span> = <span class="number">0</span>x0000000102a2f068 @<span class="string">"lifengfeng"</span></span><br></pre></td></tr></table></figure><p>查看当前帧栈的信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame info</span><br><span class="line">frame #0: 0x0000000102a2d63f LLDBTest`-[<span class="string">ViewController lldbTest</span>](<span class="link">self=0x00007fc0684085f0, _cmd="lldbTest"</span>) + 79 at ViewController.m:28</span><br></pre></td></tr></table></figure><p>跳转到指定帧栈：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span> <span class="literal">select</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame select 0</span><br><span class="line">frame #0: 0x0000000102a2d63f LLDBTest`-[<span class="string">ViewController lldbTest</span>](<span class="link">self=0x00007fc0684085f0, _cmd="lldbTest"</span>) + 79 at ViewController.m:28</span><br><span class="line">   25      NSString *name = @"lifengfeng";</span><br><span class="line">   26      NSInteger age = 25;</span><br><span class="line">   27      _city = @"BJ";</span><br><span class="line">-&gt; 28      NSLog(@"%@ age is %ld，city is %@",name,(long)age,_city);</span><br><span class="line">   29      </span><br><span class="line">   30  &#125;</span><br><span class="line">   31</span><br></pre></td></tr></table></figure><p>6、动态改变程序的运行轨迹</p><p>expression命令用来执行一个命令，并将表达式的结果输出。除此之外，expression还可以动态改变程序的运行轨迹。例如，我们上面例子中就是一个空白的ViewController，我们可以利用expression命令来改变UI的显示，如self.view的颜色等。</p><p>expression的完整语法如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression <span class="comment">--</span></span><br></pre></td></tr></table></figure><p>上面的”–”是命令选项结束符，表示所有的命令选项已经设置完毕，如果没有命令选项，–可以省略。</p><p>例如，我们改变self.view的颜色：</p><p><img src="/images/2017/03/Snip20170313_16.png" alt="Snip20170313_16"></p><p>其中，下面的命令用于刷新UI。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression -- (<span class="keyword">void</span>)[CATransaction <span class="built_in">flush</span>]</span><br></pre></td></tr></table></figure><p>以上就是LLDB调试常用用法，其他更多用法可以去研究下官方文档，总之LLDB调试对iOS开发者来说是一个非常重要的技能。</p><p>参考：<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html" target="_blank" rel="noopener">Getting Started with LLDB</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> LLDB </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Notification与多线程</title>
      <link href="/article/620/"/>
      <url>/article/620/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在多线程中，无论在哪个线程注册了观察者，Notification接收和处理都是在发送Notification的线程中的。所以，当我们需要在接收到Notification后作出更新UI操作的话，就需要考虑线程的问题了，如果在子线程中发送Notification，想要在接收到Notification后更新UI的话就要切换回到主线程。先看一个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *NOTIFICATION_NAME = <span class="string">@"NOTIFICATION_NAME"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:NOTIFICATION_NAME object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Post notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:NOTIFICATION_NAME object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Receive notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-03-11</span> <span class="number">17</span>:<span class="number">56:33.898</span> NotificationTest[<span class="number">23457</span>:<span class="number">1615587</span>] Current thread = &lt;NSThread: <span class="number">0</span>x6<span class="number">08000078080</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">17</span>:<span class="number">56:33.899</span> NotificationTest[<span class="number">23457</span>:<span class="number">1615738</span>] Post notification，Current thread = &lt;NSThread: <span class="number">0</span>x600<span class="number">00026c500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">17</span>:<span class="number">56:33.899</span> NotificationTest[<span class="number">23457</span>:<span class="number">1615738</span>] Receive notification，Current thread = &lt;NSThread: <span class="number">0</span>x600<span class="number">00026c500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>上面我们在主线程注册观察者，在子线程发送Notification，最后Notification的接收和处理也是在子线程。</p><p>二、<strong>重定向Notification到指定线程</strong></p><p>当然，想要在子线程发送Notification、接收到Notification后在主线程中做后续操作，可以用一个很笨的方法，在 handleNotification 里面强制切换线程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Receive notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在简单情况下可以使用这种方法，但是当我们发送了多个Notification并且有多个观察者的时候，难道我们要在每个地方都手动切换线程？所以，这种方法并不是一个有效的方法。</p><p>最好的方法是在Notification所在的默认线程中捕获发送的通知，然后将其重定向到指定的线程中。关于Notification的重定向官方文档给出了一个方法：</p><p><img src="/images/2017/03/Snip20170311_1.png" alt="Snip20170311_1"></p><p>翻译成中文：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种重定向的实现思路是自定义一个通知队列(不是NSNotificationQueue对象)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像之前一样去注册一个通知的观察者，当Notification到达时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，就将这个Notification放到我们的队列中，然后发送一个信号(<span class="keyword">signal</span><span class="string">)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程收到这个信号</span>(<span class="keyword">signal</span><span class="string">)后，将Notification从队列中移除，并进行后续处理。</span></span><br></pre></td></tr></table></figure><p>我们根据官方文档中的教程测试一下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/11.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>    *notifications;         <span class="comment">// 通知队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span>          *notificationThread;    <span class="comment">// 想要处理通知的线程（目标线程）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span>            *notificationLock;      <span class="comment">// 用于对通知队列加锁的锁对象，避免线程冲突</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMachPort</span>        *notificationPort;      <span class="comment">// 用于向目标线程发送信号的通信端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *NOTIFICATION_NAME = <span class="string">@"NOTIFICATION_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setUpThreadingSupport];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册观察者</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processNotification:) name:NOTIFICATION_NAME object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送Notification</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Post notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:NOTIFICATION_NAME object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在注册任何通知之前，需要先初始化属性。下面方法初始化了队列和锁定对象，保留对当前线程对象的引用，并创建一个Mach通信端口，将其添加到当前线程的运行循环中。</span></span><br><span class="line"><span class="comment">    此方法运行后，发送到notificationPort的任何消息都会在首次运行此方法的线程的run loop中接收。如果接收线程的run loop在Mach消息到达时没有运行，则内核保持该消息，直到下一次进入run loop。接收线程的run loop将传入消息发送到端口delegate的handleMachMessage：方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setUpThreadingSupport &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.notifications) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.notifications      = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationLock   = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.notificationPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort</span><br><span class="line">                                forMode:(__bridge <span class="built_in">NSString</span>*)kCFRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 端口的代理方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span> processNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是不是目标线程，不是则转发到目标线程</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != _notificationThread) &#123;</span><br><span class="line">        <span class="comment">// 将Notification转发到目标线程</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                   components:<span class="literal">nil</span></span><br><span class="line">                                         from:<span class="literal">nil</span></span><br><span class="line">                                     reserved:<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处理通知</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Receive notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Process notification"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.788</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665269</span>] Current thread = &lt;NSThread: <span class="number">0</span>x608<span class="number">00006d4c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.789</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665396</span>] Post notification，Current thread = &lt;NSThread: <span class="number">0</span>x60800026bc40&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.795</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665269</span>] Receive notification，Current thread = &lt;NSThread: <span class="number">0</span>x608<span class="number">00006d4c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.795</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665269</span>] Process notification</span><br></pre></td></tr></table></figure><p>可以看到，运行结果结果我们想要的：在子线程中发送Notification，在主线程中接收与处理Notification。</p><p>上面的实现方法也不是绝对完美的，苹果官方指出了这种方法的限制：</p><p>（1）所有线程的Notification的处理都必须通过相同的方法（processNotification :)。</p><p>（2）每个对象必须提供自己的实现和通信端口。</p><p>更好但更复杂的方法是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。</p><p>除了上面苹果官方给我们提供的方法外，我们还可以利用基于block的NSNotification去实现，apple 从 ios4 之后提供了带有 block 的 NSNotification。使用方式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (id&lt;NSObject&gt;)<span class="selector-tag">addObserverForName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span></span><br><span class="line">                           <span class="selector-tag">object</span><span class="selector-pseudo">:(id)obj</span></span><br><span class="line">                            <span class="selector-tag">queue</span><span class="selector-pseudo">:(NSOperationQueue</span> *)<span class="selector-tag">queue</span></span><br><span class="line">                       <span class="selector-tag">usingBlock</span><span class="selector-pseudo">:(void</span> (^)(NSNotification *note))<span class="selector-tag">block</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>观察者就是当前对象</li></ul><ul><li>queue 定义了 block 执行的线程，nil 则表示 block 的执行线程和发通知在同一个线程</li></ul><ul><li>block 就是相应通知的处理函数</li></ul><p>这个 API 已经能够让我们方便的控制通知的线程切换。但是，这里有个问题需要注意。就是其 remove 操作。</p><p>原来的 NSNotification 的 remove 方式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">removeObservers</span> &#123;</span><br><span class="line">    <span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">name</span><span class="selector-pseudo">:POST_NOTIFICATION</span> <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是带 block 方式的 remove 便不能像上面这样处理了。其方式如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObservers &#123;</span><br><span class="line">    <span class="keyword">if</span>（_observer）&#123;</span><br><span class="line">        [<span class="meta">[NSNotificationCenter defaultCenter</span>] removeObserver:_observer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 _observer 是 addObserverForName 方式的 api 返回观察者对象。这也就意味着，你需要为每一个观察者记录一个成员对象，然后在 remove 的时候依次删除。试想一下，你如果需要 10 个观察者，则需要记录 10 个成员对象，这个想想就是很麻烦，而且它还不能够方便的指定 observer 。因此，理想的做法就是自己再做一层封装，将这些细节封装起来。</p><p>参考：<a href="http://lifengfengs-macbook-pro.local:63320/Dash/rlftdmxv/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="noopener">Delivering Notifications To Particular Threads</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 多线程 </tag>
            
            <tag> Notification </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 开发大胸器之 PaintCode</title>
      <link href="/article/602/"/>
      <url>/article/602/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>首先原谅我为文章起了个污污的标题，今天整理下iOS开发辅助神器PaintCode的使用，虽然标题很污，但是胸的确很大，PaintCode能够让我们像使用Photoshop一样去设计界面，主要用途是可以将矢量图轻松地转换成CoreGraphics代码，减少了图片使用量，做动效也容易很多。先来看下它的界面：</p><p><img src="/images/2017/03/Snip20170310_6.png" alt="Snip20170310_6"></p><p><img src="/images/2017/03/Snip20170310_8.png" alt="Snip20170310_8"></p><p>它可以将我们在Canvas上绘制的图形直接转换成如下类型的代码：</p><p><img src="/images/2017/03/Snip20170310_9.png" alt="Snip20170310_9"></p><p>虽然不能保证其生成的代码百分百是最佳实现方式，但是毫无疑问的是它可以大大提高我们的开发效率，接下来通过一个示例简单介绍下PaintCode的使用。</p><p>二、<strong>PaintCode的使用</strong></p><p>通过PaintCode预设的一些样式（左上角绿色的那些按钮）我们可以很快的绘制出矩形、圆形、文字、五角形等，同时我们一些图形合并、调整顺序等，具体的功能见顶部一栏的功能菜单。在右侧的属性栏我们可以为图形设置圆角、大小、旋转、填充色、描边、阴影等。</p><p>我从网上找到一张炫酷进度条图片：</p><p><img src="/images/2017/03/9b36d04efc9075faf289a5a75be131d9.png" alt="9b36d04efc9075faf289a5a75be131d9"></p><p>接下来我们就用PaintCode去实现上面风格的进度条。</p><p>首先我们在Canvas上绘制进度条的进度槽（进度条背景），点一下左上角的”Rect”，在Canvas画出进度槽，在右侧设置进度槽的圆角、颜色，可以根据自己需求去设置其他更多属性：</p><p><img src="/images/2017/03/Snip20170310_10.png" alt="Snip20170310_10"></p><p>以类似的方法绘制出表示进度的彩色进度条，方法还是类似，不过要在右侧属性栏设置一下阴影等效果，最终效果如下：</p><p><img src="/images/2017/03/Snip20170310_12.png" alt="Snip20170310_12"></p><p>彩色进度条我设置了这些内容：</p><p><img src="/images/2017/03/Snip20170310_13_1.png" alt="Snip20170310_13_1"></p><p>最后在PaintCode最底部一栏可以看到生成的代码：</p><p><img src="/images/2017/03/Snip20170310_14.png" alt="Snip20170310_14"></p><p>我们新建一个iOS工程，在工程中新建一个继承自UIView的PCProgressView文件（<em>我这里PCProgressView中的PC是PaintCode的简写，别误以为是PC个人电脑的PC了</em>），将PaintCode为我们生成的代码拷贝到PCProgressView的drawRect:方法中，可以发现绘制的图形的frame都是固定值（为了理解方便就直接截图了）：</p><p><img src="/images/2017/03/Snip20170311_15.png" alt="Snip20170311_15"></p><p>所以我们需要根据实际情况修改frame，首先我们PCProgressView.h文件中公开一个属性用来动态设置进度：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PCProgressView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> progress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>重写该属性的setter方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setProgress:(<span class="built_in">CGFloat</span>)progress&#123;</span><br><span class="line">    </span><br><span class="line">    _progress = progress;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置根据实际情况修改绘制图形的frame：</p><p><img src="/images/2017/03/Snip20170311_17.png" alt="Snip20170311_17"></p><p>然后我们将其添加到ViewController的View之中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CGFloat progressX = <span class="number">20</span><span class="comment">;</span></span><br><span class="line">    CGFloat progressY = <span class="number">100</span><span class="comment">;</span></span><br><span class="line">    CGFloat progressW = [UIScreen mainScreen].<span class="keyword">bounds.size.width </span>- <span class="number">2</span> * progressX<span class="comment">;</span></span><br><span class="line">    CGFloat progressH = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    PCProgressView *pcProgress = [[PCProgressView alloc]initWithFrame:CGRectMake(progressX, progressY, progressW, progressH)]<span class="comment">;</span></span><br><span class="line">    pcProgress.<span class="keyword">backgroundColor </span>= [UIColor whiteColor]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    pcProgress.progress = <span class="number">0</span>.<span class="number">5</span>f<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    [self.view <span class="keyword">addSubview:pcProgress];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/03/Snip20170311_20.png" alt="Snip20170311_20"></p><p>接下来我们让进度条改变进度看下效果，ViewController中代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  PaintCodeTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/10.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"PCProgressView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)PCProgressView *pcProgress;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIButton</span> *btn;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将我们自定义的进度条PCProgressView添加到ViewController中</span></span><br><span class="line">    <span class="built_in">CGFloat</span> progressX = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> progressY = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> progressW = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - <span class="number">2</span> * progressX;</span><br><span class="line">    <span class="built_in">CGFloat</span> progressH = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.pcProgress = [[PCProgressView alloc]initWithFrame:<span class="built_in">CGRectMake</span>(progressX, progressY, progressW, progressH)];</span><br><span class="line">    <span class="keyword">self</span>.pcProgress.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="keyword">self</span>.pcProgress.progress = <span class="number">0</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.pcProgress];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一个Button</span></span><br><span class="line">    <span class="built_in">CGFloat</span> btnW = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> btnH = <span class="number">40</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> btnX = ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - btnW)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> btnY = progressY + <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.btn = [[<span class="built_in">UIButton</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(btnX, btnY, btnW, btnH)];</span><br><span class="line">    [<span class="keyword">self</span>.btn setTitle:<span class="string">@"Start"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [<span class="keyword">self</span>.btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.btn];</span><br><span class="line">    <span class="keyword">self</span>.btn.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//btn按钮点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)btnClick&#123;</span><br><span class="line">    <span class="keyword">self</span>.btn.enabled = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.pcProgress.progress = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">0.1</span></span><br><span class="line">                                         target:<span class="keyword">self</span></span><br><span class="line">                                       selector:<span class="keyword">@selector</span>(updateProgressView)</span><br><span class="line">                                       userInfo:<span class="literal">nil</span></span><br><span class="line">                                        repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.timer fire];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新进度</span></span><br><span class="line">-(<span class="keyword">void</span>)updateProgressView &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pcProgress.progress &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pcProgress.progress += <span class="number">0.01</span>f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">        <span class="keyword">self</span>.btn.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/03/2017-03-11-00.48.52.gif" alt="2017-03-11 00.48.52"></p><p>以上就是PaintCode的简单用法，其实PaintCode使用是非常简单的，上面我也没有把每步操作都截图出来，或许看完这篇文章你再打开PaintCode就瞬间明白PaintCode的用法了。合理使用PaintCode可以大大提高我们的开发效率，可以节约更多时间去用在核心功能上。后面我还会整理其他几个iOS开发“胸器”的用法。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> PaintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 触摸事件</title>
      <link href="/article/598/"/>
      <url>/article/598/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在APP的开发过程中，可能需要利用手势操作去实现一些功能或者效果。UIKit框架提供了检测常见手势的预定义手势识别器。 在手势开发上，最好尽可能使用预定义的手势识别器，因为它们的简单性减少了我们的的代码量。当然，我们也可以自定义一些特殊的手势，具体的可以查看官方文档学习：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW44" target="_blank" rel="noopener">Creating a Custom Gesture Recognizer</a>。iOS中的事件可以分为3大类型：触摸事件、加速计事件、远程控制事件，如下图：</p><p><img src="/images/2017/03/events_to_app_2x.png" alt="events_to_app_2x"></p><p>二、<strong>UIResponder</strong></p><p>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“<strong>响应者对象</strong>”，UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件。</p><p>继承了UIResponder就可以处理事件。UIResponder内部提供了以下方法来处理事件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸事件：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加速计事件：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">motionBegan:</span>(UIEventSubtype)motion <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">motionEnded:</span>(UIEventSubtype)motion <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">motionCancelled:</span>(UIEventSubtype)motion <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//远程控制事件：</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">remoteControlReceivedWithEvent:</span>(UIEvent *)event;</span><br></pre></td></tr></table></figure><p>UIView的触摸事件处理:</p><p>UIView是UIResponder的子类，可以重写下列4个方法处理不同的触摸事件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一根或者多根手指开始触摸view，系统会自动调用view的下面方法：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一根或者多根手指离开view，系统会自动调用view的下面方法：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br></pre></td></tr></table></figure><p>例如，使UIView随手指移动：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前触摸点，设置以自己为参照，坐标原点为自己（self）的左上角</span></span><br><span class="line">    <span class="built_in">CGPoint</span> current = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 上一个触摸点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> previous = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改当前view的位置(中点)</span></span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span>.center;</span><br><span class="line">    center.x += current.x - previous.x;</span><br><span class="line">    center.y += current.y - previous.y;</span><br><span class="line">    <span class="keyword">self</span>.center = center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三：<strong>UITouch</strong></p><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象，一根手指对应一个UITouch对象。</p><p>UITouch保存着跟手指相关的信息，比如触摸的位置、时间、阶段：</p><p>（1）当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置。</p><p>（2）当手指离开屏幕时，系统会销毁相应的UITouch对象。</p><p>UITouch的属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸产生时所处的窗口：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIWindow</span>    *window;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸产生时所处的视图：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span>    *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span>    tapCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了触摸事件产生或变化时的时间，单位是秒：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>    timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前触摸事件所处的状态：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span>    phase;</span><br></pre></td></tr></table></figure><p>UITouchPhase是一个枚举类型，包含：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITouchPhaseBegan</span>（触摸开始）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseMoved</span>（接触点移动）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseStationary</span>（接触点无移动）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseEnded</span>（触摸结束）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseCancelled</span>（触摸取消）</span><br></pre></td></tr></table></figure><p>UITouch的方法:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (CGPoint)<span class="selector-tag">locationInView</span><span class="selector-pseudo">:(UIView</span> *)<span class="selector-tag">view</span>;  <span class="comment">//返回值表示触摸在view上的位置，这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)），调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (CGPoint)<span class="selector-tag">previousLocationInView</span><span class="selector-pseudo">:(UIView</span> *)<span class="selector-tag">view</span>;  <span class="comment">//该方法记录了前一个触摸点的位置</span></span><br></pre></td></tr></table></figure><p>四、<strong>UIEvent</strong></p><p>每产生一个事件，就会产生一个UIEvent对象，称为事件对象，记录事件产生的时刻和类型。</p><p>常见属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件类型：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventType</span>    type;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventSubtype</span>    subtype;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件产生的时间：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>    timestamp;</span><br></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventType</span>) &#123;</span><br><span class="line">    <span class="type">UIEventTypeTouches</span>,</span><br><span class="line">    <span class="type">UIEventTypeMotion</span>,</span><br><span class="line">    <span class="type">UIEventTypeRemoteControl</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventSubtype</span>) &#123;</span><br><span class="line">    // available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeNone</span>                              = 0,</span><br><span class="line">    </span><br><span class="line">    // for <span class="type">UIEventTypeMotion</span>, available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeMotionShake</span>                       = 1,</span><br><span class="line">    </span><br><span class="line">    // for <span class="type">UIEventTypeRemoteControl</span>, available in iOS 4.0</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPlay</span>                 = 100,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPause</span>                = 101,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlStop</span>                 = 102,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlTogglePlayPause</span>      = 103,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlNextTrack</span>            = 104,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPreviousTrack</span>        = 105,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = 106,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = 107,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = 108,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingForward</span>    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次完整的触摸过程，会经历3个状态：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸开始：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸移动：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸结束：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸取消（可能会经历）：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br></pre></td></tr></table></figure><p>4个触摸事件处理方法中，都有NSSet <em>touches和UIEvent </em>event两个参数：</p><p>（1）一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数</p><p>（2）如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p><p>（3）如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象</p><p>（4）根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸</p><p>五、<strong>事件的产生和传递</strong></p><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理。通常，先发送事件给应用程序的主窗口（keyWindow），主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，也就是说keyWindow最先收到触摸事件。这也是整个事件处理过程的第一步，找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理：</p><p><em>touchesBegan…</em></p><p><em>touchesMoved…</em></p><p><em>touchedEnded…</em></p><p>这些touches方法的默认做法是将事件顺着响应者链条（后面会讲解）<strong>向上</strong>传递，将事件交给上一个响应者进行处理。</p><p>事件传递示例：</p><p><img src="/images/2017/03/图片-1.png" alt="图片 1"></p><p>触摸事件的传递是从父控件传递到子控件：</p><p>（1）点击了绿色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 绿色</p><p>（2）点击了蓝色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色</p><p>（3）点击了黄色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色 -&gt; 黄色</p><p>注意：<strong>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件</strong></p><p>UIView不接收触摸事件的三种情况：</p><p>（1）不接收用户交互</p><p>userInteractionEnabled = NO</p><p>（2）隐藏</p><p>hidden = YES</p><p>（3）透明</p><p>alpha = 0.0 ~ 0.01</p><p>UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。</p><p>六、<strong>响应者链条</strong></p><p>响应者链条示意图：</p><p><img src="/images/2017/03/iOS_responder_chain_2x.png" alt="iOS_responder_chain_2x"></p><p>响应者链的事件传递过程：</p><p>（1）如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图。</p><p>（2）在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。</p><p>（3）如果window对象也不处理，则其将事件或消息传递给UIApplication对象。</p><p>（4）如果UIApplication也不能处理该事件或消息，则将其丢弃。</p><p>触摸事件完整处理过程：</p><p>（1）先将事件对象由上往下传递（由父控件传递给子控件），找到最合适的控件来处理事件。</p><p>（2）调用最合适控件的touches…方法。</p><p>（3）如果这个控件调用了[super touches…];就会将事件顺着相应链条往下传递，传递给上一个响应者。</p><p>（4）接着就会调用上一个响应者的touches…方法。</p><p>（5）事件还可以继续往上传递，直到UIApplication，如果UIApplication也不处理该事件或消息，则将其丢弃。</p><p>上一个响应者：</p><p>如果当前这个View是控制器的View，那么控制器就是上一个响应者。</p><p>如果当前这个View不是控制器的View，那么父控件就是上一个响应者。</p><p>对上面进行总结：</p><p>发生触摸事件后，keyWindow最先拿到事件，keyWindow会在视图层次结构中找到一个最合适的视图来处理触摸事件。假设这个最合适的视图为myView，myView处理这个事件的方式为将该事件传递给自己的父View，如果父View不处理则继续往上传递，直到UIApplication。如果连UIApplication也不处理则丢弃该事件。</p><p>七、<strong>UIGestureRecognizer</strong></p><p>为了完成手势识别，必须借助于手势识别器——UIGestureRecognizer，利用UIGestureRecognizer，能轻松识别用户在某个view上面做的一些常见手势，UIGestureRecognizer是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//敲击</span></span><br><span class="line"><span class="built_in">UITapGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//捏合，可用于缩放</span></span><br><span class="line"><span class="built_in">UIPinchGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拖拽</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//轻扫</span></span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转</span></span><br><span class="line"><span class="built_in">UIRotationGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//长按</span></span><br><span class="line"><span class="built_in">UILongPressGestureRecognizer</span></span><br></pre></td></tr></table></figure><p>手势识别器的用法：</p><p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建手势识别器对象</span></span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置手势识别器对象的具体属性</span></span><br><span class="line"><span class="comment">// 连续敲击2次</span></span><br><span class="line">tap.numberOfTapsRequired = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 需要2根手指一起敲击</span></span><br><span class="line">tap.numberOfTouchesRequired = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加手势识别器到对应的view上</span></span><br><span class="line">[self.iconView <span class="string">addGestureRecognizer:</span>tap];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听手势的触发</span></span><br><span class="line">[tap <span class="string">addTarget:</span>self <span class="string">action:</span><span class="meta">@selector</span>(<span class="string">tapIconView:</span>)];</span><br></pre></td></tr></table></figure><p>手势识别的状态：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIGestureRecognizerState</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有触摸事件发生，所有手势识别的默认状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStatePossible</span>,</span><br><span class="line">    <span class="comment">// 一个手势已经开始但尚未改变或者完成时</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateBegan</span>,</span><br><span class="line">    <span class="comment">// 手势状态改变</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateChanged</span>,</span><br><span class="line">    <span class="comment">// 手势完成</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateEnded</span>,</span><br><span class="line">    <span class="comment">// 手势取消，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateCancelled</span>,</span><br><span class="line">    <span class="comment">// 手势失败，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateFailed</span>,</span><br><span class="line">    <span class="comment">// 识别到手势识别</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateRecognized</span> = <span class="built_in">UIGestureRecognizerStateEnded</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如：</p><p>添加长按手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILongPressGestureRecognizer</span> *longP = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longP:)];</span><br><span class="line">[<span class="keyword">self</span>.imageV addGestureRecognizer:longP];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当长按时调用这个方法会调用很多次,</span></span><br><span class="line"><span class="comment">// 当手指长按在上面不松,来回移动时,会持续调用,所以要判断它的状态.</span></span><br><span class="line">- (<span class="keyword">void</span>)longP:(<span class="built_in">UILongPressGestureRecognizer</span> *)longP&#123;</span><br><span class="line">    <span class="keyword">if</span>(longP.state == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始长按"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(longP.state == <span class="built_in">UIGestureRecognizerStateChanged</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"长按时手指移动"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(longP.state == <span class="built_in">UIGestureRecognizerStateEnded</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"手指离开屏幕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加轻扫手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加轻扫手势1</span></span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span> *swipe = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(swipe:)];</span><br><span class="line"><span class="comment">// 轻扫手势默认是向右边称轻扫,可以设置轻扫的方法.</span></span><br><span class="line"><span class="comment">// 一个轻扫手势只能设置一个方法的轻扫.想要让它有多个方向的手势,必须得要设置的</span></span><br><span class="line">  swipe.direction =  <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">  [<span class="keyword">self</span>.imageV addGestureRecognizer:swipe];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加轻扫手势2</span></span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span> *swipe2 = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(swipe:)];</span><br><span class="line">swipe2.direction =  <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>; [<span class="keyword">self</span>.imageV addGestureRecognizer:swipe2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轻扫手势的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)swipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)swipe&#123;</span><br><span class="line">    <span class="comment">// 判断的轻扫的方向</span></span><br><span class="line">    <span class="keyword">if</span> (swipe.direction == <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"向左轻扫"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(swipe.direction == <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"向上轻扫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加拖动手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加拖动手势</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br><span class="line">[<span class="keyword">self</span>.imageV addGestureRecognizer:pan];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指拖动时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan&#123;</span><br><span class="line">    <span class="comment">// 拖动手势也有状态</span></span><br><span class="line">    <span class="keyword">if</span>(pan.state == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</span><br><span class="line">        <span class="comment">//  开始拖动</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan.state == <span class="built_in">UIGestureRecognizerStateChanged</span>)&#123;</span><br><span class="line">     <span class="comment">//   获取当前手指移动的距离，是相对于最原始的点</span></span><br><span class="line">        <span class="built_in">CGPoint</span> transP = [pan translationInView:<span class="keyword">self</span>.imageV];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    清空上一次的形变</span></span><br><span class="line">        <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(transP.x,transP.y);</span><br><span class="line">        <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span>.imageV.transform, transP.x, transP.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    复位,让它相对于上一次.</span></span><br><span class="line">        [pan setTranslation:<span class="built_in">CGPointZero</span> inView:<span class="keyword">self</span>.imageV];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan.state == <span class="built_in">UIGestureRecognizerStateEnded</span>)&#123;</span><br><span class="line">     <span class="comment">//   结束拖动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加捏合手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加捏合手势</span></span><br><span class="line"><span class="built_in">UIPinchGestureRecognizer</span> *pinGes = [[<span class="built_in">UIPinchGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pinGes:)];</span><br><span class="line"><span class="comment">// 设置代理使其能够同时支持多个手势</span></span><br><span class="line">pinGes.delegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.imageV addGestureRecognizer:pinGes];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捏合时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)pinGes:(<span class="built_in">UIPinchGestureRecognizer</span> *)pin&#123;</span><br><span class="line">    <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformScale</span>(<span class="keyword">self</span>.imageV.transform, pin.scale, pin.scale);</span><br><span class="line">    <span class="comment">// 复位</span></span><br><span class="line">    [pin setScale:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加旋转手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加旋转手势</span></span><br><span class="line"> <span class="built_in">UIRotationGestureRecognizer</span> *rotation = [[<span class="built_in">UIRotationGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(rotation:)];</span><br><span class="line"> <span class="comment">// 设置代理使其能够同时支持多个手势</span></span><br><span class="line"> rotation.delegate = <span class="keyword">self</span>;</span><br><span class="line"> [<span class="keyword">self</span>.imageV addGestureRecognizer:rotation];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指开始旋转时调用.</span></span><br><span class="line">- (<span class="keyword">void</span>)rotation:(<span class="built_in">UIRotationGestureRecognizer</span> *)rotation&#123;</span><br><span class="line">    <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformRotate</span>(<span class="keyword">self</span>.imageV.transform, rotation.rotation);</span><br><span class="line">    <span class="comment">// 复位.</span></span><br><span class="line">    [rotation setRotation:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW44" target="_blank" rel="noopener">Creating a Custom Gesture Recognizer</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 手势 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS的离屏渲染</title>
      <link href="/article/593/"/>
      <url>/article/593/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>OpenGL ES是一套多功能开放标准的用于嵌入系统的C-based的图形库，用于2D和3D数据的可视化。OpenGL被设计用来转换一组图形调用功能到底层图形硬件（GPU），由GPU执行图形命令，用来实现复杂的图形操作和运算，从而能够高性能、高帧率利用GPU提供的2D和3D绘制能力。iOS系统默认支持OpenGl ES1.0、ES2.0以及ES3.0 3个版本，三者之间并不是简单的版本升级，设计理念甚至完全不同。GPU屏幕渲染方式中有一种方式为离屏渲染，处理不好离屏渲染往往会对APP的性能产生较大的影响。</p><p>二、<strong>当前屏幕渲染与离屏渲染</strong></p><p>OpenGL中，GPU屏幕渲染有两种方式:</p><p>（1）On-Screen Rendering (当前屏幕渲染) </p><p>指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。</p><p>（2）Off-Screen Rendering (离屏渲染)</p><p>指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。</p><p>当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。但是受当前屏幕渲染的局限因素限制(只有自身上下文、屏幕缓存有限等)，当前屏幕渲染有些情况下的渲染解决不了的，就使用到离屏渲染。</p><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p><p>（1）创建新缓冲区</p><p>要想进行离屏渲染，首先要创建一个新的缓冲区。</p><p>（2）上下文切换</p><p>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen），等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p><p>特殊的“离屏渲染”：CPU渲染</p><p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap(位图)最后再交由GPU用于显示。</p><p><a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance" target="_blank" rel="noopener">Designing for iOS: Graphics &amp; Performance</a> 这篇文章也提到了使用 Core Graphics API 会触发离屏渲染。 苹果 iOS 4.1-8 时期的 UIKit 组成员Andy Matuschak也曾对这个说法进行解释：「Core Graphics 的绘制 API 的确会触发离屏渲染，但不是那种 GPU 的离屏渲染。使用 Core Graphics 绘制 API 是在 CPU 上执行，触发的是 CPU 版本的离屏渲染。」</p><p>三、<strong>为什么要有离屏渲染</strong></p><p>大家高中物理应该学过显示器是如何显示图像的：需要显示的图像经过CRT电子枪以极快的速度一行一行的扫描，扫描出来就呈现了一帧画面，随后电子枪又会回到初始位置循环扫描，形成了我们看到的图片或视频。<br>为了让显示器的显示跟视频控制器同步，当电子枪新扫描一行的时候，准备扫描的时发送一个水平同步信号(HSync信号)，显示器的刷新频率就是HSync信号产生的频率。然后CPU计算好frame等属性，将计算好的内容交给GPU去渲染，GPU渲染好之后就会放入帧缓冲区。然后视频控制器会按照HSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器，就显示出来了。具体的大家自行查找资料或询问相关专业人士，这里只参考网上资料做一个简单的描述。<br>离屏渲染的代价很高，想要进行离屏渲染，首选要创建一个新的缓冲区，屏幕渲染会有一个上下文环境的一个概念，离屏渲染的整个过程需要切换上下文环境，先从当前屏幕切换到离屏，等结束后，又要将上下文环境切换回来。这也是为什么会消耗性能的原因了。<br>由于垂直同步的机制，如果在一个 HSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><p>既然离屏渲染这么耗性能,为什么有这套机制呢?</p><p>有些效果被认为不能直接呈现于屏幕，而需要在别的地方做额外的处理预合成。图层属性的混合体没有预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p><p>下面的情况或操作会引发离屏渲染：</p><ul><li>为图层设置遮罩（layer.mask）</li></ul><ul><li>将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</li></ul><ul><li>将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</li></ul><ul><li>为图层设置阴影（layer.shadow *）。</li></ul><ul><li>为图层设置layer.shouldRasterize=true</li></ul><ul><li>具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层</li></ul><ul><li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）。</li></ul><ul><li>使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。</li></ul><p>四、<strong>优化方案</strong></p><p>官方对离屏渲染产生性能问题也进行了优化：</p><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染。</p><p>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p><p>1、圆角优化</p><p>在APP开发中，圆角图片还是经常出现的。如果一个界面中只有少量圆角图片或许对性能没有非常大的影响，但是当圆角图片比较多的时候就会APP性能产生明显的影响。</p><p>我们设置圆角一般通过如下方式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageView.layer.cornerRadius = CGFloat(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">imageView.layer.masksToBounds = YES<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样处理的渲染机制是GPU在当前屏幕缓冲区外新开辟一个渲染缓冲区进行工作，也就是离屏渲染，这会给我们带来额外的性能损耗，如果这样的圆角操作达到一定数量，会触发缓冲区的频繁合并和上下文的的频繁切换，性能的代价会宏观地表现在用户体验上——掉帧。</p><p>优化方案1：使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)]; </span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImg"</span>]; </span><br><span class="line"><span class="comment">//开始对imageView进行画图 </span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageView.bounds.size, <span class="literal">NO</span>, <span class="number">1.0</span>); </span><br><span class="line"><span class="comment">//使用贝塞尔曲线画出一个圆形图 </span></span><br><span class="line">[[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];</span><br><span class="line">[imageView drawRect:imageView.bounds];</span><br><span class="line">imageView.image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line"><span class="comment">//结束画图 </span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br></pre></td></tr></table></figure><p>优化方案2：使用CAShapeLayer和UIBezierPath设置圆角</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)]; </span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImg"</span>]; </span><br><span class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:<span class="built_in">UIRectCornerAllCorners</span> cornerRadii:imageView.bounds.size];</span><br><span class="line"><span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc]init]; </span><br><span class="line"><span class="comment">//设置大小 </span></span><br><span class="line">maskLayer.frame = imageView.bounds; </span><br><span class="line"><span class="comment">//设置图形样子 </span></span><br><span class="line">maskLayer.path = maskPath.CGPath;</span><br><span class="line">imageView.layer.mask = maskLayer; </span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br></pre></td></tr></table></figure><p>对于方案2需要解释的是：</p><ul><li>CAShapeLayer继承于CALayer,可以使用CALayer的所有属性值；</li></ul><ul><li>CAShapeLayer需要贝塞尔曲线配合使用才有意义（也就是说才有效果）</li></ul><ul><li>使用CAShapeLayer(属于CoreAnimation)与贝塞尔曲线可以实现不在view的drawRect（继承于CoreGraphics走的是CPU,消耗的性能较大）方法中画出一些想要的图形</li></ul><ul><li>CAShapeLayer动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言，其效率极高，能大大优化内存使用情况。</li></ul><p>总的来说就是用CAShapeLayer的内存消耗少，渲染速度快，建议使用优化方案2。</p><p>2、shadow优化</p><p>对于shadow，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置shadowPath来优化性能，能大幅提高性能。示例如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imageView.layer.<span class="keyword">shadowColor </span>= [UIColor grayColor].CGColor<span class="comment">;</span></span><br><span class="line">imageView.layer.<span class="keyword">shadowOpacity </span>= <span class="number">1</span>.<span class="number">0</span><span class="comment">;</span></span><br><span class="line">imageView.layer.<span class="keyword">shadowRadius </span>= <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span></span><br><span class="line">UIBezierPath *path = [UIBezierPath <span class="keyword">bezierPathWithRect:imageView.frame];</span></span><br><span class="line"><span class="keyword">imageView.layer.shadowPath </span>= path.CGPath<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>我们还可以通过设置shouldRasterize属性值为YES来强制开启离屏渲染。其实就是光栅化（Rasterization）。既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于UITableViewCell中，cell的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是2.5个屏幕尺寸。在100ms之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。</p><p>3、其他的一些优化建议</p><ul><li>当我们需要圆角效果时，可以使用一张中间透明图片蒙上去</li></ul><ul><li>使用ShadowPath指定layer阴影效果路径</li></ul><ul><li>使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit）</li></ul><ul><li>设置layer的opaque值为YES，减少复杂图层合成</li></ul><ul><li>尽量使用不包含透明（alpha）通道的图片资源</li></ul><ul><li>尽量设置layer的大小值为整形值</li></ul><ul><li>直接让美工把图片切成圆角进行显示，这是效率最高的一种方案</li></ul><ul><li>很多情况下用户上传图片进行显示，可以让服务端处理圆角</li></ul><ul><li>使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片</li></ul><p>五、<strong>Core Animation工具检测离屏渲染</strong></p><p>对于离屏渲染的检测，苹果为我们提供了一个测试工具Core Animation。可以在Xcode-&gt;Open Develeper Tools-&gt;Instruments中找到，如下图：</p><p><img src="/images/2017/03/201703080040.png" alt="201703080040"></p><p>Core Animation工具用来监测Core Animation性能，提供可见的FPS值，并且提供几个选项来测量渲染性能。如下图：</p><p><img src="/images/2017/03/201703080041.png" alt="201703080041"></p><p>下面我们来说明每个选项的功能：<br>Color Blended Layers：这个选项如果勾选，你能看到哪个layer是透明的，GPU正在做混合计算。显示红色的就是透明的，绿色就是不透明的。</p><p>Color Hits Green and Misses Red：如果勾选这个选项，且当我们代码中有设置shouldRasterize为YES，那么红色代表没有复用离屏渲染的缓存，绿色则表示复用了缓存。我们当然希望能够复用。</p><p>Color Copied Images：按照官方的说法，当图片的颜色格式GPU不支持的时候，Core Animation会<br>拷贝一份数据让CPU进行转化。例如从网络上下载了TIFF格式的图片，则需要CPU进行转化，这个区域会显示成蓝色。还有一种情况会触发Core Animation的copy方法，就是字节不对齐的时候。如下图：</p><p><img src="/images/2017/03/201703080043.png" alt="201703080043"></p><p>Color Immediately：默认情况下Core Animation工具以每毫秒10次的频率更新图层调试颜色，如果勾选这个选项则移除10ms的延迟。对某些情况需要这样，但是有可能影响正常帧数的测试。</p><p>Color Misaligned Images：勾选此项，如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。像素对齐我们已经在上面有所介绍。</p><p>Color Offscreen-Rendered Yellow：用来检测离屏渲染的，如果显示黄色，表示有离屏渲染。当然还要结合Color Hits Green and Misses Red来看，是否复用了缓存。</p><p>Color OpenGL Fast Path Blue：这个选项对那些使用OpenGL的图层才有用，像是GLKView或者 CAEAGLLayer，如果不显示蓝色则表示使用了CPU渲染，绘制在了屏幕外，显示蓝色表示正常。</p><p>Flash Updated Regions：当对图层重绘的时候回显示黄色，如果频繁发生则会影响性能。可以用增加缓存来增强性能。</p><p>具体的使用截图就不发出来了，大家自己可以试试。</p><p>参考：<a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/WorkingwithEAGLContexts/WorkingwithEAGLContexts.html" target="_blank" rel="noopener">Drawing to Other Rendering Destinations</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 离屏渲染 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS XCTest单元测试</title>
      <link href="/article/588/"/>
      <url>/article/588/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在Xcode中新建项目的时候会默认勾选单元测试，勾选后每个XCode新建的iOS的项目中都有一个叫做”项目名Tests”的分组，这个分组里就是XCTestCase的子类，XCTest中的测试类都是继承自XCTestCase。当我们为项目增加了新的功能时，可以使用单元测试针对该模块进行测试。</p><p>二、<strong>单元测试的使用</strong></p><p>1、常规测试</p><p>首先新建一个名为“MyDemo”的项目，我们会看到会自动生成如下的文件：</p><p><img src="/images/2017/03/Snip20170306_5.png" alt="Snip20170306_5"></p><p>MyDemoTests中代码为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">    [<span class="keyword">super</span> tearDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">    <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">        <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面最重要的两个方法为setUp和tearDown，setUp方法在XCTestCase的测试方法调用之前调用。当测试全部结束之后调用tearDown方法。上面的另外两个方法是系统自动创建的功能测试用例的示例。我们可以自己创建测试方法，不过测试方法必须testXXX的格式，且不能有参数，不然不会识别为测试方法。</p><p>setUp方法可以在测试之前创建在test case方法中需要用到的一些对象等。tearDown方法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等。</p><p>例如，我们去除系统系统创建的两个测试用例的示例，我们自己创建一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyDemoTests.m</span></span><br><span class="line"><span class="comment">//  MyDemoTests</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/6.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setUp-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    [<span class="keyword">super</span> tearDown];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tearDown-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyFun&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMyFun-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>按快捷键Command + U进行单元测试，打印结果（去除了其他暂不关注的打印）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-06</span> 15<span class="selector-pseudo">:35</span><span class="selector-pseudo">:35.336</span> <span class="selector-tag">MyDemo</span><span class="selector-attr">[48088:5078800]</span> <span class="selector-tag">setUp-----------------</span></span><br><span class="line">2017<span class="selector-tag">-03-06</span> 15<span class="selector-pseudo">:35</span><span class="selector-pseudo">:35.336</span> <span class="selector-tag">MyDemo</span><span class="selector-attr">[48088:5078800]</span> <span class="selector-tag">testMyFun-----------------</span></span><br><span class="line">2017<span class="selector-tag">-03-06</span> 15<span class="selector-pseudo">:35</span><span class="selector-pseudo">:35.337</span> <span class="selector-tag">MyDemo</span><span class="selector-attr">[48088:5078800]</span> <span class="selector-tag">tearDown-----------------</span></span><br></pre></td></tr></table></figure><p>接下来我们新建一个类MyClass，在MyClass中声明和实现一个getNum的方法，方法实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(NSInteger)getNum&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们MyDemoTests的testMyFun写相关单元测试代码（代码中用到了断言，断言的使用后面再讲）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyDemoTests.m</span></span><br><span class="line"><span class="comment">//  MyDemoTests</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/6.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setUp-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    [<span class="keyword">super</span> tearDown];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tearDown-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyFun&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMyFun-----------------"</span>);</span><br><span class="line">    </span><br><span class="line">    MyClass *myClass = [[MyClass alloc]init];</span><br><span class="line">    <span class="built_in">NSInteger</span> num = [myClass getNum];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssert</span>(num &lt; <span class="number">10</span>,<span class="string">@"num should less than 10"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面加了断言，只有当num&lt;10的使用才能通过测试，由于此时num=5，所以可以顺利通过测试。</p><p>按快捷键Command + U进行单元测试，结果如下：</p><p><img src="/images/2017/03/Snip20170306_6.png" alt="Snip20170306_6"></p><p>如果我们将getNum的返回结果改为15，则不会通过测试：</p><p><img src="/images/2017/03/Snip20170306_7.png" alt="Snip20170306_7"></p><p>如果测试方法比较多的时候也可以直接点击方法后运行的图标单独测试某个方法，Command + U是全部测试：</p><p><img src="/images/2017/03/Snip20170306_8.png" alt="Snip20170306_8"></p><p>2、性能测试</p><p>刚开始的时候系统为我们创建的一个测试用例方法里有这么个方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    [self <span class="string">measureBlock:</span>^&#123;</span><br><span class="line">        <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释可以看到我们可以将需要测试执行时间的代码放在该方法的Block中，测试时Block中的代码会运行10次并打印出每次运行的时间。例如，我们将getNum的代码改成如下代码：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(NSInteger)getNum&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">time</span> = arc4random_uniform(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">sleep</span>(<span class="keyword">time</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">testPerformanceExample</span> &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"testPerformanceExample-----------------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="selector-attr">[self measureBlock:^&#123;</span></span><br><span class="line"><span class="selector-attr"></span></span><br><span class="line"><span class="selector-attr">        MyClass *myClass = [[MyClass alloc]</span><span class="selector-tag">init</span>];</span><br><span class="line">        <span class="selector-attr">[myClass getNum]</span>;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按快捷键Command + U进行单元测试，结果如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-03-06</span> <span class="number">16</span>:<span class="number">42:01.403</span> MyDemo[<span class="number">51107</span>:<span class="number">5178923</span>] setUp-----------------</span><br><span class="line"><span class="number">2017-03-06</span> <span class="number">16</span>:<span class="number">42:01.404</span> MyDemo[<span class="number">51107</span>:<span class="number">5178923</span>] testPerformanceExample-----------------</span><br><span class="line">/Users/lifengfeng/Desktop/Project/iOSProject/MyDemo/MyDemoTests/MyDemoTests.m:<span class="number">31</span>: Test Case '-[MyDemoTests testPerformanceExample]' measured [Time, seconds] average: <span class="number">0</span>.<span class="number">422</span>, relative standard deviation: <span class="number">164.533</span>%, values: [<span class="number">0.000053</span>, <span class="number">2.073384</span>, <span class="number">0.000010</span>, <span class="number">1.073334</span>, <span class="number">0.000013</span>, <span class="number">1.074108</span>, <span class="number">0.000016</span>, <span class="number">0.000005</span>, <span class="number">0.000004</span>, <span class="number">0.000003</span>], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: "", baselineAverage: , maxPercentRegression: <span class="number">10</span>.<span class="number">000</span>%, maxPercentRelativeStandardDeviation: <span class="number">10</span>.<span class="number">000</span>%, maxRegression: <span class="number">0</span>.<span class="number">100</span>, maxStandardDeviation: <span class="number">0</span>.<span class="number">100</span></span><br><span class="line"><span class="number">2017-03-06</span> <span class="number">16</span>:<span class="number">42:06.080</span> MyDemo[<span class="number">51107</span>:<span class="number">5178923</span>] tearDown-----------------</span><br></pre></td></tr></table></figure><p>从上面可以看到10次中每次执行所花费的时间，从上面我们可以了解到我们代码的性能。</p><p>三、<strong>常用的测试断言</strong></p><ul><li>XCTFail(format…) 生成一个失败的测试;</li></ul><ul><li>XCTFail(@”Fail”);</li></ul><ul><li>XCTAssertNil(a1, format…) 为空判断， a1 为空时通过，反之不通过;</li></ul><ul><li>XCTAssertNil(@”not nil string”, @”string must be nil”);</li></ul><ul><li>XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；</li></ul><ul><li>XCTAssertNotNil(@”not nil string”, @”string can not be nil”);</li></ul><ul><li>XCTAssert(expression, format…) 当expression求值为TRUE时通过；</li></ul><ul><li>XCTAssert((2 &gt; 2), @”expression must be true”);</li></ul><ul><li>XCTAssertTrue(expression, format…) 当expression求值为TRUE时通过；</li></ul><ul><li>XCTAssertTrue(1, @”Can not be zero”);</li></ul><ul><li>XCTAssertFalse(expression, format…) 当expression求值为False时通过；</li></ul><ul><li>XCTAssertFalse((2 &lt; 2), @”expression must be false”);</li></ul><ul><li>XCTAssertEqualObjects(a1, a2, format…) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；</li></ul><ul><li>XCTAssertEqualObjects(@”1”, @”1”, @”[a1 isEqual:a2] should return YES”);</li></ul><ul><li>XCTAssertEqualObjects(@”1”, @”2”, @”[a1 isEqual:a2] should return YES”);</li></ul><ul><li>XCTAssertNotEqualObjects(a1, a2, format…) 判断不等， [a1 isEqual:a2] 值为False时通过，</li></ul><ul><li>XCTAssertNotEqualObjects(@”1”, @”1”, @”[a1 isEqual:a2] should return NO”);</li></ul><ul><li>XCTAssertNotEqualObjects(@”1”, @”2”, @”[a1 isEqual:a2] should return NO”);</li></ul><ul><li>XCTAssertEqual(a1, a2, format…) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</li></ul><ul><li>XCTAssertNotEqual(a1, a2, format…) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）;</li></ul><ul><li>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试;</li></ul><ul><li>XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @”a1 = a2 in accuracy should return YES”);</li></ul><ul><li>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试;</li></ul><ul><li>XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @”a1 = a2 in accuracy should return NO”);</li></ul><ul><li>XCTAssertThrows(expression, format…) 异常测试，当expression发生异常时通过；反之不通过；</li></ul><ul><li>XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过;</li></ul><ul><li>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过;</li></ul><ul><li>XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；</li></ul><ul><li>XCTAssertNoThrowSpecific(expression, specificException, format…)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过;</li></ul><ul><li>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过;</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> XCTest </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程安全详解</title>
      <link href="/article/582/"/>
      <url>/article/582/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在多线程操作过程中，往往一个数据同时被多个线程读写，在这种情况下，如果没有相应的机制对数据进行保护，就很可能会发生数据污染的的问题，给程序造成各种难以重现的潜在bug。</p><p>多线程安全中相关术语及概念（假设操作的是数据库）：</p><p>（1）脏读</p><p>指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中。这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p><p>（2）不可重复读</p><p>指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p><p>（3）幻觉读</p><p>指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如：<br>目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这时，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p><p>二、<strong>多线程的安全问题</strong></p><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。</p><p><img src="/images/2017/03/Snip20170304_1.png" alt="Snip20170304_1"></p><p>线程安全：简单来说就是多个线程同时对共享资源进行访问时，采用了加锁机制，当一个线程访问共享资源，对该资源进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。</p><p><img src="/images/2017/03/Snip20170304_2.png" alt="Snip20170304_2"></p><p>三、<strong>iOS多线程中的“锁”</strong></p><p>1、互斥锁：@synchronized(id anObject)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">myMethod</span><span class="selector-pseudo">:(id)anObj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@synchronized</span>(anObj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、atomic</p><p>OC在定义属性时有nonatomic和atomic两种选择。</p><p>atomic：原子属性，为setter方法加锁（默认就是atomic）。</p><p>nonatomic：非原子属性，不会为setter方法加锁。</p><p>atomic加锁原理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, atomic) <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line"> &#123; </span><br><span class="line">     <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </span><br><span class="line">        _age = age;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3、NSLock</p><p>NSLock对象实现了NSLocking protocol，包含几个方法：<br>lock——加锁<br>unlock——解锁<br>tryLock——尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO<br>lockBeforeDate:——在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO。<br>比如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLock *theLock = [[NSLock alloc] init]; </span><br><span class="line"><span class="keyword">if</span> ([theLock <span class="keyword">lock</span>]) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//do something here</span></span><br><span class="line">   [<span class="meta">theLock unlock</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、递归锁：NSRecursiveLock</p><p>多次调用不会阻塞已获取该锁的线程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRecursiveLock *rcsLock = [[NSRecursiveLock alloc] init]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveLockTest</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  [<span class="meta">rcsLock lock</span>]; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="number">0</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    --<span class="keyword">value</span>; </span><br><span class="line">    recursiveLockTest(<span class="keyword">value</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">rcsLock unlock</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">recursiveLockTest(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上面如果直接使用NSLock就会造成死锁。NSRecursiveLock类定义的锁可以在同一线程多次lock，而不会造成死锁。递归锁会跟踪它被多少次lock。每次成功的lock都必须平衡调用unlock操作。只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线程获得。</p><p>5、条件锁：NSConditionLock</p><p>有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程中</span></span><br><span class="line"><span class="built_in">NSConditionLock</span> *theLock = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        [theLock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"thread1:%d"</span>,i);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        [theLock unlockWithCondition:i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [theLock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"thread2"</span>);</span><br><span class="line">    [theLock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在线程1中的加锁使用了lock，是不需要条件的，所以顺利的就锁住了。但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock、lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p><p>上述代码运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:29.031</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031878]</span> <span class="selector-tag">thread1</span><span class="selector-pseudo">:0</span></span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:31.105</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031878]</span> <span class="selector-tag">thread1</span><span class="selector-pseudo">:1</span></span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:33.175</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031878]</span> <span class="selector-tag">thread1</span><span class="selector-pseudo">:2</span></span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:35.249</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031879]</span> <span class="selector-tag">thread2</span></span><br></pre></td></tr></table></figure><p>如果上面线程2的代码中将[theLock lockWhenCondition:2];改为[theLock lockWhenCondition:3];，则运行时就不会再打印出thread2了。</p><p>6、分布锁：NSDistributedLock</p><p>以上所有的锁都是在解决多线程之间的冲突，但如果遇上多个进程或多个程序之间需要构建互斥的情景该怎么办呢？这个时候我们就需要使用到NSDistributedLock了，从它的类名就知道这是一个分布式的Lock，NSDistributedLock的实现是通过文件系统的，所以使用它才可以有效的实现不同进程之间的互斥，但NSDistributedLock并非继承于NSLock，它没有lock方法，它只实现了tryLock，unlock，breakLock，所以如果需要lock的话，你就必须自己实现一个tryLock的轮询。</p><p>例如：</p><p>程序A：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, </span><span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    lock = [[NSDistributedLock alloc] initWithPath:@<span class="string">"/Users/lifengfeng/Desktop/locktest.txt"</span>]<span class="comment">;</span></span><br><span class="line">    [lock <span class="keyword">breakLock];</span></span><br><span class="line"><span class="keyword"> </span>   [lock tryLock]<span class="comment">;</span></span><br><span class="line">    sleep(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">    [lock unlock]<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"appA: OK"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>程序B:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    lock = [[NSDistributedLock alloc] initWithPath:@<span class="string">"/Users/lifengfeng/Desktop/locktest.txt"</span>]<span class="comment">;</span></span><br><span class="line">        while (![lock tryLock]) &#123;</span><br><span class="line">            NSLog(@<span class="string">"appB: waiting"</span>)<span class="comment">;</span></span><br><span class="line">            sleep(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock]<span class="comment">;</span></span><br><span class="line">        NSLog(@<span class="string">"appB: OK"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>先运行程序A，然后立即运行程序B。根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中。当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两上不同程序之间的互斥。/Users/lifengfeng/Desktop/locktest.txt是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。</p><p>7、GCD中信号量：dispatch_semaphore</p><p>假设现在系统有两个空闲资源可以被利用，但同一时间却有三个线程要进行访问，这种情况下，该如何处理呢？这里，我们就可以方便的利用信号量来解决这个问题。同样我们也可以用它来构建一把”锁”（从本质上讲，信号量与锁是有区别的，具体的请自行查阅资料）。</p><p>信号量：就是一种可用来控制访问资源的数量的标识。设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。</p><p>在GCD中有三个函数是semaphore的操作：<br><strong>_dispatch_semaphore_create_</strong>        创建一个semaphore<br>_<strong>dispatch_semaphore_signal</strong>_        发送一个信号<br><strong>_dispatch_semaphore_wait_</strong>        等待信号</p><p>dispatch_semaphore_create函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量+1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p><p>具体使用如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//crate的value表示，最多几个资源可访问</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run task 1"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete task 1"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run task 2"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete task 2"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run task 3"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete task 3"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:52.915</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095043]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:52.915</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095041]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:53.983</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095043]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:53.984</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095040]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 3</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:53.992</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095041]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:55.029</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095040]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 3</span><br></pre></td></tr></table></figure><p>由于设定的信号值为2，先执行两个线程，等执行完一个，才会继续执行下一个，保证同一时间执行的线程数不超过2。</p><p>如果我们把信号值设为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>则运行结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:56.468</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100137]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:57.530</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100137]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:57.531</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100135]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:58.531</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100135]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:58.532</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100134]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 3</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:59.588</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100134]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 3</span><br></pre></td></tr></table></figure><p>8、GCD中“栅栏函数”：dispatch_barrier_async</p><p>dispatch_barrier_async函数的作用与barrier的意思相同，在进程管理中起到一个栅栏的作用，它等待所有位于barrier函数之前的操作执行完毕后执行，并且在barrier函数执行之后，barrier函数之后的操作才会得到执行，该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用。</p><p>dispatch_barrier_async函数的作用：</p><p>（1）实现高效率的数据库访问和文件访问</p><p>（2）避免数据竞争</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----4"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上述代码打印结果总是1 2 –&gt; barrier –&gt;3 4，即1、2总在barrier之前打印，3、4总在barrier之后打印，其中1、2 由于并行处理先后顺序不定，当然3、4也一样。</p><p>四、<strong>综合demo</strong></p><p>先看下面代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> configData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)configData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.dataSource = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataSource addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Obj - %i"</span>, i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户在点击start按钮后，会在一个全局的queue里面对构造的数据进行遍历，为了模拟实际场景中网络请求的时延，每次循环让当前线程休息0.05s。这样在遍历的过程中，如果用户点击了移除按钮，此时<code>self.dataSource[i]</code>执行时，因为数组已经被清空了，会报数组越界的错误。</p><p>解决办法：</p><p>（1）使用@synchronized修复</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>.dataSource) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>.dataSource) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用NSLock修复</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个全局变量</span></span><br><span class="line"> <span class="built_in">NSRecursiveLock</span>* rLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line"> - (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [rLock lock];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        [rLock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    [rLock lock];</span><br><span class="line">    [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    [rLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用dispatch_semaphore_signal修复</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）使用dispatch_barrier_async修复</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.threadsafe.sing"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Core Animation详解</title>
      <link href="/article/548/"/>
      <url>/article/548/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>Core Animation，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。它可以用在Mac OS X和iOS平台。Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。要注意的是，<strong>Core Animation是直接作用在CALayer上的，并非UIView</strong>。</p><p>二、<strong>Core Animation的继承结构</strong></p><p>CAAnimation是所有动画对象的父类，负责控制动画的持续时间和速度、是个抽象类，不能直接使用，应该使用具体子类。需要注意的是CAAnimation 和 CAPropertyAnimation 都是抽象类。</p><p>view是负责响应事件的，layer是负责显示的。</p><p><img src="/images/2017/02/2248583-2dfdb6de25cde9d1.png" alt="2248583-2dfdb6de25cde9d1"></p><p>黄色的区块是常用的属性、方法或者需要遵守的协议，灰色的是名称。</p><p>图注：</p><ul><li>核心动画中所有类都遵守CAMediaTiming。</li></ul><ul><li>CAAnaimation是个抽象类，不具备动画效果，必须用它的子类（CAAnimationGroup和CATransition）才有动画效果。</li></ul><ul><li>CAAnimationGroup（动画组），可以同时进行缩放，旋转。</li></ul><ul><li>CATransition（转场动画），界面之间跳转都可以用转场动画。</li></ul><ul><li>CAPropertyAnimation也是个抽象类，本身不具备动画效果，只有子类（CABasicAnimation和CAKeyframeAnimation）才有动画效果。</li></ul><ul><li>CABasicAnimation（基础动画），做一些简单效果。</li></ul><ul><li>CAKeyframeAnimation（帧动画），做一些连续的流畅的动画。</li></ul><p>三、<strong>Core Animation使用步骤及相关属性</strong></p><p>1、使用步骤</p><p>第一步：初始化一个CAAnimation对象，并设置一些动画相关属性。</p><p>第二步：通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了。</p><p>第三步：通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画。</p><p>2、常用属性</p><p>就是上面图片中的小黄色区内容。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">duration：持续时间，默认值是<span class="number">0.25</span>秒</span><br><span class="line"></span><br><span class="line">repeatCount:重复次数，无线循环可以设置HUGE_VALF或者<span class="built_in">CGFLOAT_MAX</span></span><br><span class="line"></span><br><span class="line">repeatDuration:重复时间</span><br><span class="line"></span><br><span class="line">removeOnCompletion: 默认为<span class="literal">YES</span>，代表动画执行完毕后就从图层上移除，图形会恢复到执行动画之前的状态。如果想要图层保持显示动画执行后的状态，那就设置为<span class="literal">NO</span>，同时设置fillMode为kCAFillModeForwards</span><br><span class="line"></span><br><span class="line">fillMode：决定当前对象在非active时间段的行为</span><br><span class="line"></span><br><span class="line">beginTime：可以用来设置动画延时执行，若想延迟<span class="number">2</span>s，就设置为<span class="built_in">CACurrentMediaTIme</span>() + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CACurrentMediaTIme</span>()：图层的当前时间</span><br><span class="line"></span><br><span class="line">timingFunction:速度控制函数，控制动画运行节奏</span><br><span class="line"></span><br><span class="line">delegate：动画代理</span><br></pre></td></tr></table></figure><p>动画代理能够检测动画的执行和结束：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">CAAnimationDelegate</span>)</span></span><br><span class="line"> - (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"> - (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>3、animationWithKeyPath中，常用的keyPath</p><p><img src="/images/2017/02/Snip20170211_6_2.png" alt="Snip20170211_6_2"></p><p>4、动画填充模式</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kCAFillModeForwards:</span>当动画结束后，layer会一直保持着动画最后的状态</span><br><span class="line"></span><br><span class="line">kCAFillModeBackwards：在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始</span><br><span class="line"></span><br><span class="line">kCAFillModeBoth：这个其实就是上面两个合成，动画加入后，开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</span><br><span class="line"></span><br><span class="line">kCAFillModeRemoved：这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态</span><br></pre></td></tr></table></figure><p>5、动画速度控制函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉</span><br><span class="line"></span><br><span class="line">kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开</span><br><span class="line"></span><br><span class="line">kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地</span><br><span class="line"></span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。</span><br></pre></td></tr></table></figure><p>6、CALayer上动画的暂停和恢复</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark 暂停CALayer的动画</span></span><br><span class="line">-(<span class="keyword">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让CALayer的时间停止走动</span></span><br><span class="line">      layer.speed = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 让CALayer的时间停留在pausedTime这个时刻</span></span><br><span class="line">    layer.timeOffset = pausedTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark 恢复CALayer的动画</span></span><br><span class="line">-(<span class="keyword">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> pausedTime = layer.timeOffset;</span><br><span class="line">    <span class="comment">// 1. 让CALayer的时间继续行走</span></span><br><span class="line">      layer.speed = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 2. 取消上次记录的停留时刻</span></span><br><span class="line">      layer.timeOffset = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 3. 取消上次设置的时间</span></span><br><span class="line">      layer.beginTime = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;</span><br><span class="line">    <span class="comment">// 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)</span></span><br><span class="line">      layer.beginTime = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、<strong>动画的调用方式</strong></p><p>（1）UIView 代码块调用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_demoView.frame = CGRectMake(<span class="number">0</span>, <span class="keyword">SCREEN_HEIGHT/2-50, </span><span class="number">50</span>, <span class="number">50</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">[UIView animateWithDuration:<span class="number">1</span>.<span class="number">0</span>f animations:^&#123;</span><br><span class="line">    _demoView.frame = CGRectMake(<span class="keyword">SCREEN_WIDTH, </span><span class="keyword">SCREEN_HEIGHT/2-50, </span><span class="number">50</span>, <span class="number">50</span>)<span class="comment">;</span></span><br><span class="line">&#125; completion:^(<span class="keyword">BOOL </span>finished) &#123;</span><br><span class="line">    _demoView.frame = CGRectMake(<span class="keyword">SCREEN_WIDTH/2-25, </span><span class="keyword">SCREEN_HEIGHT/2-50, </span><span class="number">50</span>, <span class="number">50</span>)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（2）UIView [begin commit]模式</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_demoView.frame = CGRectMake(<span class="number">0</span>, <span class="keyword">SCREEN_HEIGHT/2-50, </span><span class="number">50</span>, <span class="number">50</span>)<span class="comment">;</span></span><br><span class="line">[UIView <span class="keyword">beginAnimations:nil </span><span class="built_in">context</span>:nil]<span class="comment">;</span></span><br><span class="line">[UIView setAnimationDuration:<span class="number">1</span>.<span class="number">0</span>f]<span class="comment">;</span></span><br><span class="line">_demoView.frame = CGRectMake(<span class="keyword">SCREEN_WIDTH, </span><span class="keyword">SCREEN_HEIGHT/2-50, </span><span class="number">50</span>, <span class="number">50</span>)<span class="comment">;</span></span><br><span class="line">[UIView commitAnimations]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（3）使用Core Animation中的类</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@<span class="string">"position"</span>]<span class="comment">;</span></span><br><span class="line">anima.fromValue = [NSValue valueWithCGPoint:CGPointMake(<span class="number">0</span>, <span class="keyword">SCREEN_HEIGHT/2-75)];</span></span><br><span class="line"><span class="keyword">anima.toValue </span>= [NSValue valueWithCGPoint:CGPointMake(<span class="keyword">SCREEN_WIDTH, </span><span class="keyword">SCREEN_HEIGHT/2-75)];</span></span><br><span class="line"><span class="keyword">anima.duration </span>= <span class="number">1</span>.<span class="number">0</span>f<span class="comment">;</span></span><br><span class="line">[_demoView.layer <span class="keyword">addAnimation:anima </span>forKey:@<span class="string">"positionAnimation"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>addanimation:forkey: 这个key到底是什么？官方的注释是：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** Animation methods. **/</span><br><span class="line"></span><br><span class="line">/* Attach an animation object <span class="keyword">to</span> <span class="keyword">the</span> layer. Typically this <span class="keyword">is</span> implicitly</span><br><span class="line"> * invoked <span class="keyword">through</span> an action <span class="keyword">that</span> <span class="keyword">is</span> an CAAnimation object.</span><br><span class="line"> *</span><br><span class="line"> * 'key' may be any <span class="built_in">string</span> such <span class="keyword">that</span> only one animation per unique key</span><br><span class="line"> * <span class="keyword">is</span> added per layer. The special key 'transition' <span class="keyword">is</span> automatically</span><br><span class="line"> * used <span class="keyword">for</span> transition animations. The nil pointer <span class="keyword">is</span> also a valid key.</span><br><span class="line"> *</span><br><span class="line"> * If <span class="keyword">the</span> `duration' <span class="keyword">property</span> <span class="keyword">of</span> <span class="keyword">the</span> animation <span class="keyword">is</span> zero <span class="keyword">or</span> negative <span class="keyword">it</span></span><br><span class="line"> * <span class="keyword">is</span> <span class="keyword">given</span> <span class="keyword">the</span> default duration, either <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span></span><br><span class="line"> * `animationDuration' <span class="keyword">transaction</span> <span class="keyword">property</span> <span class="keyword">or</span> <span class="number">.25</span> seconds otherwise.</span><br><span class="line"> *</span><br><span class="line"> * The animation <span class="keyword">is</span> copied <span class="keyword">before</span> being added <span class="keyword">to</span> <span class="keyword">the</span> layer, so any</span><br><span class="line"> * subsequent modifications <span class="keyword">to</span> `anim' will have no affect unless <span class="keyword">it</span> <span class="keyword">is</span></span><br><span class="line"> * added <span class="keyword">to</span> another layer. */</span><br></pre></td></tr></table></figure><p>翻译下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="bullet">* *</span>动画方法。<span class="bullet">* *</span> // </span><br><span class="line"><span class="bullet">* </span>将动画对象附加到层。通常这是隐式地</span><br><span class="line"><span class="bullet">* </span>通过一个动作是一个CAAnimation对象调用。</span><br><span class="line"><span class="bullet">* </span>“key”可以是任何字符串,这样每个唯一键只有一个动画</span><br><span class="line"><span class="bullet">* </span>添加每层。特殊键自动“过渡”</span><br><span class="line"><span class="bullet">* </span>用于过渡动画。空指针也是一个有效的关键。</span><br><span class="line"><span class="bullet">* </span>如果动画的“持续时间”属性是零或消极</span><br><span class="line"><span class="bullet">* </span>默认时间,给出的值</span><br><span class="line"><span class="bullet">*  </span>animationDuration事务属性或。25秒。</span><br><span class="line"><span class="bullet">*  </span>动画复制之前添加到层,所以任何后续修改“动画”没有影响,除非它是添加到另一层</span><br></pre></td></tr></table></figure><p>也就是说，key可以设置为任意值。</p><p>五、<strong>基本使用示例</strong></p><p>1、基础动画（CABaseAnimation）</p><p>重要属性：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>Value ： keyPath对应的初始值</span><br><span class="line"></span><br><span class="line"><span class="keyword">to</span>Value ： keyPath对应的结束值</span><br></pre></td></tr></table></figure><p>基础动画主要提供了对于CALayer对象中的可变属性进行简单动画的操作。比如：位移、透明度、缩放、旋转、背景色等等。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  AnimationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/2/11.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span></span><br><span class="line"><span class="meta">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIView</span> *myView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> myViewW = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> myViewH = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> myViewX = (SCREEN_WIDTH - myViewW)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> myViewY = (SCREEN_HEIGHT - myViewH)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">self</span>.myView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(myViewX, myViewY, myViewW, myViewH)];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.myView];</span><br><span class="line">    <span class="keyword">self</span>.myView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用CABasicAnimation创建基础动画</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *anima = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    anima.fromValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-75</span>)];</span><br><span class="line">    anima.toValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-75</span>)];</span><br><span class="line">    anima.duration = <span class="number">1.0</span>f;</span><br><span class="line">    <span class="comment">//anima.fillMode = kCAFillModeForwards;</span></span><br><span class="line">    <span class="comment">//anima.removedOnCompletion = NO;</span></span><br><span class="line">    [<span class="keyword">self</span>.myView.layer addAnimation:anima forKey:<span class="string">@"positionAnimation"</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/2017/02/2017-02-11-22.08.34.gif" alt="2017-02-11 22.08.34"></p><p>其他一些动画效果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  透明度动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(void)opacityAniamtion&#123;</span><br><span class="line">    CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@<span class="string">"opacity"</span>]<span class="comment">;</span></span><br><span class="line">    anima.fromValue = [NSNumber numberWithFloat:<span class="number">1</span>.<span class="number">0</span>f]<span class="comment">;</span></span><br><span class="line">    anima.toValue = [NSNumber numberWithFloat:<span class="number">0</span>.<span class="number">2</span>f]<span class="comment">;</span></span><br><span class="line">    anima.duration = <span class="number">1</span>.<span class="number">0</span>f<span class="comment">;</span></span><br><span class="line">    [_demoView.layer <span class="keyword">addAnimation:anima </span>forKey:@<span class="string">"opacityAniamtion"</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  缩放动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(void)<span class="keyword">scaleAnimation&#123; </span></span><br><span class="line">    CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@<span class="string">"transform.scale"</span>]<span class="comment">;//同上</span></span><br><span class="line">    anima.toValue = [NSNumber numberWithFloat:<span class="number">2</span>.<span class="number">0</span>f]<span class="comment">;</span></span><br><span class="line">    anima.duration = <span class="number">1</span>.<span class="number">0</span>f<span class="comment">;</span></span><br><span class="line">    [_demoView.layer <span class="keyword">addAnimation:anima </span>forKey:@<span class="string">"scaleAnimation"</span>]<span class="comment">; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  旋转动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(void)rotateAnimation&#123;</span><br><span class="line">    CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@<span class="string">"transform.rotation.z"</span>]<span class="comment">;//绕着z轴为矢量，进行旋转(@"transform.rotation.z"==@@"transform.rotation")</span></span><br><span class="line">    anima.toValue = [NSNumber numberWithFloat:<span class="number">3</span>*M_PI]<span class="comment">;</span></span><br><span class="line">    anima.duration = <span class="number">1</span>.<span class="number">0</span>f<span class="comment">;</span></span><br><span class="line">    [_demoView.layer <span class="keyword">addAnimation:anima </span>forKey:@<span class="string">"rotateAnimation"</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  背景色变化动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(void)<span class="keyword">backgroundAnimation&#123;</span></span><br><span class="line"><span class="keyword"> </span>   CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@<span class="string">"backgroundColor"</span>]<span class="comment">;</span></span><br><span class="line">    anima.toValue =(id) [UIColor greenColor].CGColor<span class="comment">;</span></span><br><span class="line">    anima.duration = <span class="number">1</span>.<span class="number">0</span>f<span class="comment">;</span></span><br><span class="line">    [_demoView.layer <span class="keyword">addAnimation:anima </span>forKey:@<span class="string">"backgroundAnimation"</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、CAKeyframeAnimation 关键帧动画</p><p>Keyframe顾名思义就是关键点的frame，你可以通过设定CALayer的始点、中间关键点、终点的frame，时间，动画会沿你设定的轨迹进行移动 。</p><p>CAKeyframeAnimation 的一些比较重要的属性：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span>：这是一个 CGPathRef 对象，默认是空的，当我们创建好CAKeyframeAnimation的实例的时候，可以通过制定一个自己定义的<span class="built_in">path</span>来让某一个物体按照这个路径进行动画。这个值默认是<span class="literal">nil</span>，当其被设定的时候，values 这个属性就被覆盖。</span><br><span class="line"></span><br><span class="line">values：一个数组，提供了一组关键帧的值，当使用<span class="built_in">path</span>的 时候 values的值自动被忽略。</span><br></pre></td></tr></table></figure><p>例如，连续移动一个view到不同的位置：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  关键帧动画 values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)keyFrameAnimation&#123;</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *anima = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    <span class="built_in">NSValue</span> *value0 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *value1 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *value2 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span>+<span class="number">50</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *value3 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH*<span class="number">2</span>/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span>+<span class="number">50</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *value4 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH*<span class="number">2</span>/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *value5 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">    anima.values = [<span class="built_in">NSArray</span> arrayWithObjects:value0,value1,value2,value3,value4,value5, <span class="literal">nil</span>];</span><br><span class="line">    anima.duration = <span class="number">2.0</span>f;</span><br><span class="line">    anima.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];<span class="comment">//设置动画的节奏</span></span><br><span class="line">    anima.delegate = <span class="keyword">self</span>;<span class="comment">//设置代理，可以检测动画的开始和结束</span></span><br><span class="line">    [_demoView.layer addAnimation:anima forKey:<span class="string">@"keyFrameAnimation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  path动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)pathAnimation&#123;</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *anima = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(SCREEN_WIDTH/<span class="number">2</span><span class="number">-100</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-100</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">    anima.path = path.CGPath;</span><br><span class="line">    anima.duration = <span class="number">2.0</span>f;</span><br><span class="line">    [_demoView.layer addAnimation:anima forKey:<span class="string">@"pathAnimation"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果就不贴出来了，大家可以自己尝试下。</p><p>对比基础动画跟关键帧动画，关键帧动画引入了动画占比时长的概念，这让我们能控制每个关键帧动画的占用比例而不是传入一个无意义的动画时长 —— 这让我们的代码更加难以理解。当然，除了动画占比之外，关键帧动画的options参数也让动画变得更加平滑，下面是关键帧特有的配置参数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewKeyframeAnimationOptionCalculationModeLinear</span> <span class="comment">// 连续运算模式，线性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewKeyframeAnimationOptionCalculationModeDiscrete</span> <span class="comment">// 离散运算模式，只显示关键帧</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewKeyframeAnimationOptionCalculationModePaced</span> <span class="comment">// 均匀执行运算模式，线性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewKeyframeAnimationOptionCalculationModeCubic</span> <span class="comment">// 平滑运算模式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewKeyframeAnimationOptionCalculationModeCubicPaced</span> <span class="comment">// 平滑均匀运算模式</span></span><br></pre></td></tr></table></figure><p>3、CAAnimationGroup 组合动画</p><p>Group也就是组合的意思，可以保存一组动画对象，将CAAnimationGroup对象加入图层后，组中所有动画对象可以同时并发运行。</p><p>其重要属性为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animations：用来保存一组动画对象的<span class="built_in">NSArray</span></span><br></pre></td></tr></table></figure><p>注意：默认情况下，一组动画对象是同时运行的，我们也可以通过设置动画对象的beginTime属性来更改动画的开始时间。</p><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)groupAnimation1&#123;</span><br><span class="line"> <span class="comment">// 位移动画</span></span><br><span class="line">  <span class="built_in">CAKeyframeAnimation</span> *anima1 = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">  <span class="built_in">NSValue</span> *value0 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">  <span class="built_in">NSValue</span> *value1 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">  <span class="built_in">NSValue</span> *value2 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span>+<span class="number">50</span>)];</span><br><span class="line">  <span class="built_in">NSValue</span> *value3 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH*<span class="number">2</span>/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span>+<span class="number">50</span>)];</span><br><span class="line">  <span class="built_in">NSValue</span> *value4 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH*<span class="number">2</span>/<span class="number">3</span>, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">  <span class="built_in">NSValue</span> *value5 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(SCREEN_WIDTH, SCREEN_HEIGHT/<span class="number">2</span><span class="number">-50</span>)];</span><br><span class="line">  anima1.values = [<span class="built_in">NSArray</span> arrayWithObjects:value0,value1,value2,value3,value4,value5, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//缩放动画</span></span><br><span class="line">  <span class="built_in">CABasicAnimation</span> *anima2 = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line">  anima2.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.8</span>f];</span><br><span class="line">  anima2.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">2.0</span>f];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//旋转动画</span></span><br><span class="line">  <span class="built_in">CABasicAnimation</span> *anima3 = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation"</span>];</span><br><span class="line">  anima3.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:M_PI*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//组动画</span></span><br><span class="line">  <span class="built_in">CAAnimationGroup</span> *groupAnimation = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">  groupAnimation.animations = [<span class="built_in">NSArray</span> arrayWithObjects:anima1,anima2,anima3, <span class="literal">nil</span>];</span><br><span class="line">  groupAnimation.duration = <span class="number">4.0</span>f;</span><br><span class="line"></span><br><span class="line">  [_demoView.layer addAnimation:groupAnimation forKey:<span class="string">@"groupAnimation"</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/2017-02-11-22.32.29.gif" alt="2017-02-11 22.32.29"></p><p>4、CATransition 过渡动画</p><p>CAAnimation的子类，用于做过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。</p><p>重要属性：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>：动画过渡类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">subtype</span>：动画过渡方向</span><br><span class="line"></span><br><span class="line">startProgress：动画起点(在整体动画的百分比)</span><br><span class="line"></span><br><span class="line">endProgress：动画终点(在整体动画的百分比)</span><br></pre></td></tr></table></figure><p>有以下几种type：<br><img src="/images/2017/02/Snip20170211_8.png" alt="Snip20170211_8"></p><p>有以下几种subtype：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kCATransitionFromRight</span> 从右侧进入</span><br><span class="line">kCATransitionFromLeft 从左侧进入</span><br><span class="line">kCATransitionFromTop 从顶部进入</span><br><span class="line">kCATransitionFromBottom 从底部进入</span><br></pre></td></tr></table></figure><p>例如，为了便于使用，我们可以自定义一个相关方法：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">pragma</span> CATransition动画实现</span><br><span class="line">- (void) transitionWithType:(NSString *) <span class="keyword">type</span> <span class="type">WithSubtype:(NSString </span>*) <span class="keyword">subtype</span> <span class="type">ForView </span>: (UIView *) view</span><br><span class="line">&#123;</span><br><span class="line">    //创建CATransition对象</span><br><span class="line">    CATransition *animation = [CATransition animation];</span><br><span class="line">    //设置运动时间</span><br><span class="line">    animation.duration = DURATION;</span><br><span class="line">    //设置运动<span class="keyword">type</span></span><br><span class="line">    animation.<span class="keyword">type</span> <span class="type">= </span><span class="keyword">type</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">subtype</span> <span class="type">!= </span>nil) &#123;</span><br><span class="line">        //设置子类</span><br><span class="line">        animation.<span class="keyword">subtype</span> <span class="type">= </span><span class="keyword">subtype</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置运动速度</span><br><span class="line">    animation.timingFunction = UIViewAnimationOptionCurveEaseInOut;</span><br><span class="line">    [view.layer addAnimation:animation forKey:@<span class="string">"animation"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面layer的动画之外，还有UIView的动画：</p><p><img src="/images/2017/02/Snip20170211_9.png" alt="Snip20170211_9"></p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> beginAnimations:<span class="string">@"animationID"</span> context:<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">UIView</span> setAnimationDuration:<span class="number">0.5</span>f]; <span class="comment">//动画时长</span></span><br><span class="line">[<span class="built_in">UIView</span> setAnimationCurve:<span class="built_in">UIViewAnimationCurveEaseInOut</span>];</span><br><span class="line">[<span class="built_in">UIView</span> setAnimationTransition:<span class="built_in">UIViewAnimationTransitionFlipFromLeft</span> forView:<span class="keyword">self</span>.myView cache:<span class="literal">YES</span>]; <span class="comment">//给视图添加过渡效果</span></span><br><span class="line"><span class="comment">//在这里写你的代码.</span></span><br><span class="line">[<span class="built_in">UIView</span> commitAnimations]; <span class="comment">//提交动画</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/2017-02-11-22.57.43.gif" alt="2017-02-11 22.57.43"></p><p>以上就是Core Animation的主要用法。</p><p><em>PS：终于整理完了，累成狗了~</em></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Core Animation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS CALayer详解</title>
      <link href="/article/543/"/>
      <url>/article/543/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在iOS中，你能看得见摸得着的东西基本上都是UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是UIView，其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层，在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) CALayer *layer;</span><br></pre></td></tr></table></figure><p>当UIView需要显示到屏幕上时，会调用<strong>drawRect:</strong>方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。换句话说，UIView本身不具备显示的功能，是它内部的图层有显示功能。</p><p>通过操作CALayer对象，可以很方便地调整UIView的一些外观属性，比如：阴影（如果设置了超过主图层的部分减掉，则设置阴影不会有显示效果；设置阴影，不光需要设置阴影颜色，还应该设置阴影的偏移位和透明度。因为如果不设置偏移位的话，那么阴影和layer完全重叠，且默认透明度为0，即完全透明）、圆角大小、边框宽度和颜色、还可以给图层添加动画，来实现一些比较炫酷的效果等等。</p><p>二、<strong>UIView和CALayer之间的区别</strong></p><p>1、UIView是用来显示内容的，可以处理用户事件。直接继承UIResponser。<br>2、CALayer是用来绘制内容的，不能处理用户事件。直接继承NSObject。<br>3、 UIView和CALayer是相互依赖的关系。UIView依赖于CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。</p><p>三、<strong>CALayer的常用属性</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宽度和高度</span></span><br><span class="line"><span class="variable">@property</span> CGRect bounds;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位置(默认指中点，具体由anchorPoint决定)</span></span><br><span class="line"><span class="variable">@property</span> CGPoint position;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锚点(x,y的范围都是0-1)，决定了position的含义</span></span><br><span class="line"><span class="variable">@property</span> CGPoint anchorPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">//背景颜色(CGColorRef类型)</span></span><br><span class="line"><span class="variable">@propertyCGColorRefbackgroundColor</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形变属性</span></span><br><span class="line"><span class="variable">@property</span> CATransform3D transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边框颜色(CGColorRef类型)</span></span><br><span class="line"><span class="variable">@property</span>  CGColorRef  borderColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边框宽度</span></span><br><span class="line"><span class="variable">@property</span> CGFloat borderWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆角半径</span></span><br><span class="line"><span class="variable">@property</span> CGFloat cornerRadius;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内容(比如设置为图片CGImageRef)</span></span><br><span class="line"><span class="variable">@property</span>(retain) id contents;</span><br></pre></td></tr></table></figure><p>可以通过设置contents属性给UIView设置背景图片:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.layer.contents = (__bridge <span class="keyword">id</span> _Nullable)([<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>].CGImage); <span class="comment">// 跨框架赋值需要进行桥接</span></span><br></pre></td></tr></table></figure><p>例如，我们利用CALayer对图片的显示进行处理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  CALayerTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/2/11.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)  <span class="built_in">CALayer</span> *myLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到控制器的视图之中</span></span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.myLayer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置图层的内容</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.contents = (__bridge <span class="keyword">id</span> _Nullable)([<span class="built_in">UIImage</span> imageNamed:<span class="string">@"headImg"</span>].CGImage);</span><br><span class="line">    <span class="comment">// 设置阴影的颜色</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.shadowColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    <span class="comment">// 设置阴影的偏移</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 设置阴影的不透明度</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.shadowOpacity = <span class="number">0.6</span>;</span><br><span class="line">    <span class="comment">// 设置边角半径</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.cornerRadius = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">// 设置裁剪</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 设置边框线的颜色</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.borderColor = [<span class="built_in">UIColor</span> greenColor].CGColor;</span><br><span class="line">    <span class="comment">// 设置边框线条的宽度</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.borderWidth = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">CALayer</span> *)myLayer&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_myLayer ==<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建layer对象</span></span><br><span class="line">        _myLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">        <span class="comment">// 设置图层的frame</span></span><br><span class="line">        _myLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">100</span>, <span class="number">190</span>, <span class="number">145</span>);</span><br><span class="line">        <span class="comment">// 设置背景颜色</span></span><br><span class="line">        _myLayer.backgroundColor = [<span class="built_in">UIColor</span> greenColor].CGColor;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.myLayer = _myLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _myLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170211_3.png" alt="Snip20170211_3"></p><p>看上面代码，我们添加了阴影效果，为什么阴影效果没有展现出来呢？那是因为阴影效果和裁剪边角的效果是冲突的，如果设置裁剪边角那么阴影效果无法实现；当注释掉裁剪边框的效果，阴影效果才显示：</p><p><img src="/images/2017/02/Snip20170211_4.png" alt="Snip20170211_4"></p><p>四、<strong>position和anchorPoint属性</strong></p><p>CALayer有2个非常重要的属性：position和anchorPoint。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>CGPoint position;</span><br></pre></td></tr></table></figure><p>（1）用来设置CALayer在父层中的位置</p><p>（2）以父层的左上角为原点(0, 0)</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property CGPoint <span class="built_in">anchor</span>Point;</span><br></pre></td></tr></table></figure><p>（1）称为“定位点”、“锚点”，控件旋转动画围绕着锚点旋转。</p><p>（2）决定着CALayer身上的哪个点会在position属性所指的位置，可用来将控件放到指定位置（设置锚点并把锚点放到position位置）。</p><p>（3）以自己的左上角为原点(0, 0)。</p><p>（4）它的x、y取值范围都是0~1，默认值为（0.5, 0.5），即默认是中点。</p><p>如下，我们改变View的anchorPoint：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  CALayerTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/2/11.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)  <span class="built_in">CALayer</span> *myLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到控制器的视图之中</span></span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.myLayer];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">CALayer</span> *)myLayer&#123;</span><br><span class="line">    <span class="keyword">if</span> (_myLayer ==<span class="literal">nil</span>) &#123;</span><br><span class="line">        _myLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">        _myLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        _myLayer.backgroundColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">        <span class="keyword">self</span>.myLayer = _myLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _myLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.myLayer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/2017-02-11-19.37.06.gif" alt="2017-02-11 19.37.06"></p><p>五、<strong>隐式动画</strong></p><p>每一个UIView内部都默认关联着一个CALayer，我们可称这个Layer为RootLayer（根层），所有的非RootLayer，也就是手动创建的CALayer对象，都存在着隐式动画。</p><p>什么是隐式动画？<br>当对非RootLayer的部分属性进行修改时，默认会自动产生一些动画效果而这些属性称为AnimatableProperties(可动画属性)。</p><p>列举几个常见的AnimatableProperties：</p><ul><li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画。</li></ul><ul><li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画。</li></ul><ul><li>position：用于设置CALayer的位置。修改这个属性会产生平移动画。</li></ul><p>可以通过动画事务(CATransaction)关闭默认的隐式动画效果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransactionbegin</span>];</span><br><span class="line">[<span class="built_in">CATransactionsetDisableActions</span>:<span class="literal">YES</span>];</span><br><span class="line"><span class="keyword">self</span>.myview.layer.position= <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">[<span class="built_in">CATransactioncommit</span>];</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  CALayerTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/2/11.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)  <span class="built_in">CALayer</span> *myLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到控制器的视图之中</span></span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.myLayer];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">CALayer</span> *)myLayer&#123;</span><br><span class="line">    <span class="keyword">if</span> (_myLayer ==<span class="literal">nil</span>) &#123;</span><br><span class="line">        _myLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">        _myLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        _myLayer.backgroundColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">        <span class="keyword">self</span>.myLayer = _myLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _myLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 关闭隐式动画</span></span><br><span class="line">    <span class="keyword">self</span>.myLayer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 执行动画事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/2017-02-11-19.43.30.gif" alt="2017-02-11 19.43.30"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> CALayer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS NSURLSession详解</title>
      <link href="/article/538/"/>
      <url>/article/538/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>NSURLSession在2013年随着iOS7的发布一起面世，苹果对它的定位是作为NSURLConnection的替代者，然后逐步将NSURLConnection退出历史舞台。现在使用最广泛的第三方网络框架：AFNetworking、SDWebImage等等都使用了NSURLSession。</p><p>Session翻译为中文意思是会话，我们知道，在七层网络协议中有物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层，那我们可以将NSURLSession类理解为会话层，用于管理网络接口的创建、维护、删除等等工作，我们要做的工作也只是会话层之后的层即可，底层的工作NSURLSession已经帮我们封装好了。</p><p>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。NSURLSession将NSURLConnection替换为<em>NSURLSession</em>和<em>NSURLSessionConfiguration</em>，以及3个NSURLSessionTask的子类：<em>NSURLSessionDataTask</em>, <em>NSURLSessionUploadTask</em>, 和<em>NSURLSessionDownloadTask</em>。</p><p>它们之间的关系如下图：</p><p><img src="/images/2017/02/Snip20170211_1.png" alt="Snip20170211_1"></p><p>NSURLSessionTask及三个子类继承关系：</p><p><img src="/images/2017/02/7f6418d2-de8b-3006-a57f-95b3bd6c96cf.png" alt="7f6418d2-de8b-3006-a57f-95b3bd6c96cf"></p><p><em>NSURLSessionDataTask</em>: 主要用于读取服务端的简单数据，比如 JSON 数据。</p><p><em>NSURLSessionDownloadTask</em>: 这个 task 的主要用途是进行文件下载，它针对大文件的网络请求做了更多的处理，比如下载进度，断点续传等等。</p><p><em>NSURLSessionUploadTask</em>: 和下载任务对应，这个 task 主要是用于对服务端发送文件类型的数据使用的。</p><p>二、<strong>NSURLSession的使用</strong></p><p>NSURLSession 本身是不会进行请求的，而是通过创建 task 的形式进行网络请求（resume() 方法的调用），同一个 NSURLSession 可以创建多个 task，并且这些 task 之间的 cache 和 cookie 是共享的。NSURLSession的使用有如下几步：</p><ul><li>第一步：创建NSURLSession对象</li></ul><ul><li>第二步：使用NSURLSession对象创建Task</li></ul><ul><li>第三步：启动任务</li></ul><p>1、创建NSURLSession对象</p><p>NSURLSession对象的创建有如下三种方法：</p><p>（1）直接创建</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br></pre></td></tr></table></figure><p>（2）配置后创建</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[NSURLSession sessionWithConfiguration:defaultSessionConfiguration]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（3）设置加代理获得</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用代理方法需要设置代理,但是session的delegate属性是只读的,要想设置代理只能通过这种方式创建session</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]</span><br><span class="line">    delegate:<span class="keyword">self</span></span><br><span class="line">    delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br></pre></td></tr></table></figure><p>关于NSURLSession的配置有三种类型：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的配置会将缓存存储在磁盘上</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//瞬时会话模式不会创建持久性存储的缓存</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后台会话模式允许程序在后台进行上传下载工作</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)backgroundSessionConfigurationWithIdentifier:(<span class="built_in">NSString</span> *)identifier</span><br></pre></td></tr></table></figure><p>2、使用NSURLSession对象创建Task</p><p>NSURLSessionTask的创建要根据具体需要创建相应类型的Task。</p><p>（1）NSURLSessionDataTask</p><p>通过request对象或url创建：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="name">NSURLSessionDataTask</span> *)dataTaskWithRequest:(NSURLRequest *)request<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">- (<span class="name">NSURLSessionDataTask</span> *)dataTaskWithURL:(NSURL *)url<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>通过request对象或url创建，同时指定任务完成后通过completionHandler指定回调的代码块：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure><p>（2）NSURLSessionUploadTask</p><p>通过request创建，在上传时指定文件源或数据源：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(NSURLSessionUploadTask *)</span>uploadTaskWithRequest:<span class="params">(NSURLRequest *)</span>request fromFile:<span class="params">(NSURL *)</span>fileURL;  </span><br><span class="line">   </span><br><span class="line">- <span class="params">(NSURLSessionUploadTask *)</span>uploadTaskWithRequest:<span class="params">(NSURLRequest *)</span>request fromData:<span class="params">(NSData *)</span>bodyData;  </span><br><span class="line">  </span><br><span class="line">- <span class="params">(NSURLSessionUploadTask *)</span>uploadTaskWithStreamedRequest:<span class="params">(NSURLRequest *)</span>request;</span><br></pre></td></tr></table></figure><p>通过completionHandler指定任务完成后的回调代码块：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure><p>（3）NSURLSessionDownloadTask</p><p>下载任务支持断点续传，第三种方式是通过之前已经下载的数据来创建下载任务：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="name">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(NSURLRequest *)request<span class="comment">;    </span></span><br><span class="line">    </span><br><span class="line">- (<span class="name">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(NSURL *)url<span class="comment">;    </span></span><br><span class="line">  </span><br><span class="line">- (<span class="name">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(NSData *)resumeData<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>同样地可以通过completionHandler指定任务完成后的回调代码块：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure><p>我们在使用三种 task 的任意一种的时候都可以指定相应的代理。NSURLSession 的代理对象结构如下：</p><p><img src="/images/2017/02/a01337ad-ac97-3b9a-8ee7-f5b261747202.png" alt="a01337ad-ac97-3b9a-8ee7-f5b261747202"></p><p><em>NSURLSessionDelegate</em> - 作为所有代理的基类，定义了网络请求最基础的代理方法。</p><p><em>NSURLSessionTaskDelegate</em> - 定义了网络请求任务相关的代理方法。</p><p><em>NSURLSessionDownloadDelegate</em> - 用于下载任务相关的代理方法，比如下载进度等等。</p><p><em>NSURLSessionDataDelegate</em> - 用于普通数据任务和上传任务。</p><p>相信大家都会使用代理，具体的使用方法这里不再讲解。</p><p>3、启动任务</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动任务</span></span><br><span class="line">[<span class="meta">task resume</span>];</span><br></pre></td></tr></table></figure><p>三、<strong>GET请求与POST请求</strong></p><p>我们可以使用NSURLSessionDataTask进行GET请求与POST请求。</p><p>1、GET 请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建NSURLSession对象</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、利用NSURLSession创建任务(task)</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.xxx.com/login?username=myName&amp;pwd=myPsd"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">//打印解析后的json数据</span></span><br><span class="line">    <span class="comment">//NSLog(@"%@", [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、执行任务</span></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><p>2、POST请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建NSURLSession对象</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、利用NSURLSession创建任务(task)</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.xxx.com/login"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建请求对象里面包含请求体</span></span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line">request.HTTPBody = [<span class="string">@"username=myName&amp;pwd=myPsd"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">//打印解析后的json数据</span></span><br><span class="line">    <span class="comment">//NSLog(@"%@", [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、执行任务</span></span><br><span class="line"> [task resume];</span><br></pre></td></tr></table></figure><p>四、<strong>文件的上传</strong></p><p>我们可以使用NSURLSessionUploadTask进行文件的上传，使用NSURLSessionUploadTask文件上传共有两种方法：</p><p>方法1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionUploadTask</span> *task =</span><br><span class="line">[[<span class="built_in">NSURLSession</span> sharedSession] uploadTaskWithRequest:request</span><br><span class="line">                                           fromFile:fileName</span><br><span class="line">                                  completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">self.session</span> uploadTaskWithRequest:request</span><br><span class="line">                            fromData:body</span><br><span class="line">                   completionHandler:^(<span class="name">NSData</span> *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line"> NSLog(<span class="name">@</span><span class="string">"-------%@"</span>, [<span class="name">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:nil])<span class="comment">;</span></span><br><span class="line"> &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>1、以数据流的方式进行上传</p><p>这种方式好处就是大小不受限制，示例代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) <span class="built_in">NSURLSessionBinaryUploadTaskTest</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建url</span></span><br><span class="line">    <span class="built_in">NSString</span> *urlString = <span class="string">@"http://www.xxxx.com/upload.php"</span>;</span><br><span class="line">    <span class="comment">// urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]];</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    <span class="comment">// 文件上传使用post</span></span><br><span class="line">    request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.开始上传   request的body data将被忽略，而由fromData提供</span></span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] uploadTaskWithRequest:request fromData:[<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"/Users/lifengfeng/Desktop/test.jpg"</span>]     completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"upload success：%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"upload error:%@"</span>,error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;] resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、以拼接表单的方式进行上传</p><ul><li>上传的关键是请求体部分的表单拼接，获取本地上传文件的类型（MIME Types），至于具体的网络上传则很简单。 另外拼接表单的方式会有大小限制，即HTML的<code>MAX_FILE_SIZE</code>限制(可以自己设定，一般2MB)。</li></ul><ul><li>根据上面的继承关系图，我们知道uploadTask是dataTask的子类，也可以使用uploadTask来代替dataTask。</li></ul><p>表单拼接格式如下，boundary作为分界线：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--boundary</span><br><span class="line">Content-Disposition:<span class="keyword">form</span>-<span class="keyword">data</span>;<span class="keyword">name</span>=”表单控件名称”;filename=”上传文件名称”</span><br><span class="line">Content-<span class="keyword">Type</span>:要上传文件MIME Types</span><br><span class="line"></span><br><span class="line">要上传文件二进制数据;</span><br><span class="line"></span><br><span class="line">--boundary--</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="built_in">NSURLSessionUploadTaskTest</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建url  采用Apache本地服务器</span></span><br><span class="line">    <span class="built_in">NSString</span> *urlString = <span class="string">@"http://localhost/upload/upload.php"</span>;</span><br><span class="line">    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> URLFragmentAllowedCharacterSet]];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    <span class="comment">// 文件上传使用post</span></span><br><span class="line">    request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *contentType = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>,<span class="string">@"boundary"</span>];</span><br><span class="line"></span><br><span class="line">    [request setValue:contentType forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    <span class="comment">// test.jpg</span></span><br><span class="line">    <span class="comment">// 3.拼接表单，大小受MAX_FILE_SIZE限制(2MB)  FilePath:要上传的本地文件路径  formName:表单控件名称，应于服务器一致</span></span><br><span class="line">    <span class="built_in">NSData</span>* data = [<span class="keyword">self</span> getHttpBodyWithFilePath:<span class="string">@"/Users/lifengfeng/Desktop/test.jpg"</span> formName:<span class="string">@"file"</span> reName:<span class="string">@"newName.png"</span>];</span><br><span class="line">    request.HTTPBody = data;</span><br><span class="line">    <span class="comment">// 根据需要是否提供，非必须,如果不提供，session会自动计算</span></span><br><span class="line">    [request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%lu"</span>,data.length] forHTTPHeaderField:<span class="string">@"Content-Length"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.1 使用dataTask</span></span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"upload success：%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"upload error:%@"</span>,error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;] resume];</span><br><span class="line"><span class="meta">#if 0</span></span><br><span class="line">    <span class="comment">// 4.2 开始上传 使用uploadTask   fromData:可有可无，会被忽略</span></span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] uploadTaskWithRequest:request fromData:<span class="literal">nil</span>     completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"upload success：%@"</span>,[[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"upload error:%@"</span>,error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;] resume];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的两个自定义的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// filePath:要上传的文件路径   formName：表单控件名称  reName：上传后文件名</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)getHttpBodyWithFilePath:(<span class="built_in">NSString</span> *)filePath formName:(<span class="built_in">NSString</span> *)formName reName:(<span class="built_in">NSString</span> *)reName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableData</span> *data = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="built_in">NSURLResponse</span> *response = [<span class="keyword">self</span> getLocalFileResponse:filePath];</span><br><span class="line">    <span class="comment">// 文件类型：MIMEType  文件的大小：expectedContentLength  文件名字：suggestedFilename</span></span><br><span class="line">    <span class="built_in">NSString</span> *fileType = response.MIMEType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有传入上传后文件名称,采用本地文件名!</span></span><br><span class="line">    <span class="keyword">if</span> (reName == <span class="literal">nil</span>) &#123;</span><br><span class="line">        reName = response.suggestedFilename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表单拼接</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *headerStrM =[<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [headerStrM appendFormat:<span class="string">@"--%@\r\n"</span>,<span class="string">@"boundary"</span>];</span><br><span class="line">    <span class="comment">// name：表单控件名称  filename：上传文件名</span></span><br><span class="line">    [headerStrM appendFormat:<span class="string">@"Content-Disposition: form-data; name=%@; filename=%@\r\n"</span>,formName,reName];</span><br><span class="line">    [headerStrM appendFormat:<span class="string">@"Content-Type: %@\r\n\r\n"</span>,fileType];</span><br><span class="line">    [data appendData:[headerStrM dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件内容</span></span><br><span class="line">    <span class="built_in">NSData</span> *fileData = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line">    [data appendData:fileData];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableString</span> *footerStrM = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"\r\n--%@--\r\n"</span>,<span class="string">@"boundary"</span>];</span><br><span class="line">    [data appendData:[footerStrM  dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line"><span class="comment">//    NSLog(@"dataStr=%@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取响应，主要是文件类型和文件名</span></span><br><span class="line">- (<span class="built_in">NSURLResponse</span> *)getLocalFileResponse:(<span class="built_in">NSString</span> *)urlString</span><br><span class="line">&#123;</span><br><span class="line">    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> URLFragmentAllowedCharacterSet]];</span><br><span class="line">    <span class="comment">// 本地文件请求</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:urlString];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLResponse</span> *localResponse = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 使用信号量实现NSURLSession同步请求</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        localResponse = response;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="keyword">return</span>  localResponse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五、<strong>文件的下载</strong></p><p>我们可以使用NSURLSessionDownloadTask实现文件的下载。NSURLSession使用代理方法也可以实现大文件下载，但是它实现不了断点下载，所以一般不用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="built_in">NSURLSessionDownloadTaskTest</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建url</span></span><br><span class="line">    <span class="built_in">NSString</span> *urlString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"http://www.xxx.com/test.mp3"</span>];</span><br><span class="line">    <span class="comment">// 一些特殊字符编码</span></span><br><span class="line">    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建请求</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建会话，采用苹果提供全局的共享session</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *sharedSession = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [sharedSession downloadTaskWithRequest:request completionHandler:^(<span class="built_in">NSURL</span> * _Nullable location, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// location:下载任务完成之后,文件存储的位置，这个路径默认是在tmp文件夹下!</span></span><br><span class="line">            <span class="comment">// 只会临时保存，因此需要将其另存</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"location:%@"</span>,location.path);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 采用模拟器测试，为了方便将其下载到Mac桌面</span></span><br><span class="line"><span class="comment">//            NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span></span><br><span class="line">            <span class="built_in">NSString</span> *filePath = <span class="string">@"/Users/lifengfeng/Desktop/test.mp3"</span>;</span><br><span class="line">            <span class="built_in">NSError</span> *fileError;</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] copyItemAtPath:location.path toPath:filePath error:&amp;fileError];</span><br><span class="line">            <span class="keyword">if</span> (fileError == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"file save success"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"file save error: %@"</span>,fileError);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"download error:%@"</span>,error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.开启任务</span></span><br><span class="line">    [downloadTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于NSURLSession的用法，其中相关的代理方法并没有讲解，通过代理方法我们可以实现下载进度的获取等，具体的根据需要自己去实现。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> NSURLSession </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程详解</title>
      <link href="/article/533/"/>
      <url>/article/533/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在iOS中每个进程启动后都会建立一个主线程（UI线程），这个线程是其他线程的父线程。由于在iOS中除了主线程，其他子线程是独立于Cocoa Touch的，所以只有主线程可以更新UI界面。iOS中多线程使用并不复杂，关键是如何控制好各个线程的执行顺序、处理好资源竞争问题。</p><p>多线程的实现有以下几种方式：</p><p><img src="/images/2017/02/1593252-1ae56de0c12d5936.png" alt="1593252-1ae56de0c12d5936"></p><p>NSThread：</p><p>（1）使用NSThread对象建立一个线程非常方便</p><p>（2）但是！要使用NSThread管理多个线程非常困难，不推荐使用</p><p>（3）技巧！使用[NSThread currentThread]获得任务所在线程，适用于这三种技术</p><p>（4）使线程休眠3秒：[NSThread sleepForTimeInterval:0.3f];</p><p>GCD —— Grand Central Dispatch：</p><p>（1）是基于C语言的底层API</p><p>（2）用Block定义任务，使用起来非常灵活便捷</p><p>（3）提供了更多的控制能力以及操作队列中所不能使用的底层函数</p><p>NSOperation/NSOperationQueue：</p><p>（1）是使用GCD实现的一套Objective-C的API</p><p>（2）是面向对象的线程技术</p><p>（3）提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系</p><p>二、<strong>线程与进程</strong></p><p>1、进程</p><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，每一个进程都有自己独立的虚拟内存空间。</p><p>简单来说，进程是指在系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p><p>2、线程</p><p>线程，是程序执行流的最小单元线程是程序中一个单一的顺序控制流程。是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。</p><p>简单来说，1个进程要想执行任务，必须得有线程。</p><p>线程中任务的执行是串行的，要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务，也就是说，在同一时间内，1个线程只能执行1个任务，由此可以理解线程是进程中的1条执行路径。</p><p>一个进程中至少包含一条线程，即主线程，创建线程的目的就是为了开启一条新的执行路径，运行指定的代码，与主线程中的代码实现同时运行。</p><p>3、多线程</p><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p><p>原理：</p><ul><li>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）</li></ul><ul><li>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）</li></ul><ul><li>如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象<br>注意：多线程并发，并不是cpu在同一时刻同时执行多个任务，只是CPU调度足够快，造成的假象。</li></ul><p>优点：</p><ul><li>能适当提高程序的执行效率</li></ul><ul><li>能适当提高资源利用率（CPU、内存利用率）</li></ul><p>缺点：</p><ul><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li></ul><ul><li>线程越多，CPU在调度线程上的开销就越大</li></ul><p><img src="/images/2017/02/图片-1-1.png" alt="图片 1"></p><p>主线程栈区的1M，非常非常宝贵。一个进程，至少有一个线程(主线程)，不能杀掉一个线程！但是可以暂停、休眠。</p><p>三、<strong>NSThread的使用</strong></p><p>1、线程的创建</p><p>NSThread创建线程有如下三种方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：要执行的方法，参数2：提供selector的对象，通常是self，参数3传递给selector的参数</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:(<span class="keyword">nonnull</span> SEL)&gt; toTarget:(<span class="keyword">nonnull</span> <span class="keyword">id</span>) withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数一：提供selector的对象，通常是self,参数2：要执行的方法，参数3：传递给selector的参数（如果selector方法不带参数，就使用nil）</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式创建并启动线程，第一个参数为调用的方法，第二个参数为传给selector方法的参数</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelectorInBackground:</span>(SEL)aSelector <span class="string">withObject:</span>(id)arg</span><br></pre></td></tr></table></figure><p>NSThread对象的常见属性：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只读属性，线程是否在执行</span></span><br><span class="line"><span class="keyword">thread</span>.isExecuting;</span><br><span class="line"><span class="comment">//只读属性，线程是否被取消</span></span><br><span class="line"><span class="keyword">thread</span>.isCancelled;</span><br><span class="line"><span class="comment">//只读属性，线程是否完成</span></span><br><span class="line"><span class="keyword">thread</span>.isFinished;</span><br><span class="line"><span class="comment">//是否是主线程</span></span><br><span class="line"><span class="keyword">thread</span>.isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的优先级，取值范围0.0到1.0，默认优先级0.5，1.0表示最高优     //先级，优先级高，CPU调度的频率高</span></span><br><span class="line"><span class="keyword">thread</span>.threadPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的堆栈大小，线程执行前堆栈大小为512K，线程完成后堆栈大小       为0K</span></span><br><span class="line"><span class="comment">//注意:线程执行完毕后，由于内存空间被释放，不能再次启动</span></span><br><span class="line"><span class="keyword">thread</span>.stackSize;</span><br></pre></td></tr></table></figure><p>NSThread对象的方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程开始，线程加入线程池等待CPU调度（并非真正开始执行，只是通常等待时间都非常短，看不出效果）</span></span><br><span class="line">[<span class="meta">thread start</span>];</span><br><span class="line"><span class="keyword">if</span>(!thread.isCancelled)&#123;<span class="comment">//在执行之前需要先确认线程状态，如果已经取消就直接返回</span></span><br><span class="line">    [<span class="meta">thread cancel</span>]; <span class="comment">//通知线程取消，可以在外不终止线程执行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><p>NSThread的类方法：</p><p>类方法都用在线程内部，也就是说类方法作用于相关类方法的线程。</p><p>（1）当前线程，在开发中常用于调试，适用于所有多线程计数，返回一个线程号码</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="built_in">number</span> == <span class="number">1</span> 表示主线程，<span class="built_in">number</span> ！= <span class="number">1</span>表示后台线程</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">number</span> = [NSThread currentThread]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（2）阻塞方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠到指定时间</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line"><span class="comment">//休眠指定时长</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4.5</span>];</span><br></pre></td></tr></table></figure><p>（3）其他类方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>退出线程</span><br><span class="line">[NSThread <span class="keyword">exit</span>];</span><br><span class="line"><span class="regexp">//</span>当前线程是否为主线程</span><br><span class="line">[NSThread isMainThread];</span><br><span class="line"><span class="regexp">//</span>是否多线程</span><br><span class="line">[NSThread isMultiThreaded];</span><br><span class="line"><span class="regexp">//</span>返回主线程的对象</span><br><span class="line">NSThread *mainThread = [NSThread mainThread];</span><br></pre></td></tr></table></figure><p>2、线程的状态</p><p>线程的状态如下图：</p><p><img src="/images/2017/02/Snip20170209_1.png" alt="Snip20170209_1"></p><p>（1）新建：实例化对象</p><p>（2）就绪：向线程对象发送 start 消息，线程对象被加入“可调度线程池”等待 CPU 调度；detach 方法和 performSelectorInBackground 方法会直接实例化一个线程对象并加入“可调度线程池”</p><p>（3）运行:CPU 负责调度“可调度线程池”中线程的执行,线程执行完成之前，状态可能会在“就绪”和“运行”之间来回切换,“就绪”和“运行”之间的状态变化由 CPU 负责，程序员不能干预</p><p>（4）阻塞:当满足某个预定条件时，可以使用休眠或锁阻塞线程执行,影响的方法有：sleepForTimeInterval，sleepUntilDate，@synchronized(self)x线程锁；<br>线程对象进入阻塞状态后，会被从“可调度线程池”中移出，CPU 不再调度</p><p>（5）死亡<br>死亡方式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正常死亡：线程执行完毕</span><br><span class="line">非正常死亡：线程内死亡---&gt;[NSThread <span class="keyword">exit</span>]:强行中止后，后续代码都不会在执行</span><br><span class="line">线程外死亡：[threadObj cancel]---&gt;通知线程对象取消,在线程执行方法中需要增加 isCancelled 判断,如果 isCancelled == YES，直接返回</span><br></pre></td></tr></table></figure><p>死亡后线程对象的 isFinished 属性为 YES；如果是发送 calcel 消息，线程对象的 isCancelled 属性为YES；死亡后 stackSize == 0，内存空间被释放。</p><p>3、多线程的安全问题</p><p>多个线程访问同一块资源进行读写，如果不加控制随意访问容易产生数据错乱从而引发数据安全问题。为了解决这一问题，就有了加锁的概念。加锁的原理就是当有一个线程正在访问资源进行写的时候，不允许其他线程再访问该资源，只有当该线程访问结束后，其他线程才能按顺序进行访问。对于读取数据，有些程序设计是允许多线程同时读的，有些不允许。UIKit中几乎所有控件都不是线程安全的，因此需要在主线程上更新UI。</p><p>解决多线程安全问题：</p><p>（1）互斥锁</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：锁定1份代码只用1把锁，用多把锁是无效的</span></span><br><span class="line"><span class="meta">@synchronized(锁对象)</span> &#123; <span class="comment">// 需要锁定的代码  &#125;</span></span><br></pre></td></tr></table></figure><p>使用互斥锁，在同一个时间，只允许一条线程执行锁中的代码。因为互斥锁的代价非常昂贵，所以锁定的代码范围应该尽可能小，只要锁住资源读写部分的代码即可。使用互斥锁也会影响并发的目的。</p><p>（2）使用NSLock对象</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_lock</span> = [[NSLock alloc] init];</span><br><span class="line"> - (void)synchronizedMethod &#123;</span><br><span class="line">    [<span class="variable">_lock</span> <span class="built_in">lock</span>];</span><br><span class="line">    <span class="comment">//safe</span></span><br><span class="line">    [<span class="variable">_lock</span> unlock];</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（3）atomic加锁</p><p>OC在定义属性时有nonatomic和atomic两种选择。</p><p>atomic：原子属性，为setter方法加锁（默认就是atomic）。</p><p>nonatomic：非原子属性，不会为setter方法加锁。</p><p>atomic加锁原理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, atomic) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </span><br><span class="line">       _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>atomic：线程安全，需要消耗大量的资源</p><p>nonatomic：非线程安全，适合内存小的移动设备</p><p>iOS开发的建议:</p><p>（1）所有属性都声明为nonatomic</p><p>（2）尽量避免多线程抢夺同一块资源</p><p>（3）尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</p><p>4、线程间通信</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主线程上执行操作，例如给UIImageVIew设置图片</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelectorOnMainThread:</span>(SEL)aSelector <span class="string">withObject:</span>(id)arg <span class="string">waitUntilDone:</span>(BOOL)wait</span><br><span class="line"><span class="comment">//在指定线程上执行操作</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelector:</span>(SEL)aSelector <span class="string">onThread:</span>(NSThread *)thread <span class="string">withObject:</span>(id)arg <span class="string">waitUntilDone:</span>(BOOL)wai</span><br></pre></td></tr></table></figure><p>四、GCD的使用</p><p>GCD（Grand Central Dispatch） 伟大的中央调度系统，是苹果为多核并行运算提出的C语言并发技术框架。</p><p>GCD会自动利用更多的CPU内核；<br>会自动管理线程的生命周期（创建线程，调度任务，销毁线程等）；<br>程序员只需要告诉 GCD 想要如何执行什么任务，不需要编写任何线程管理代码。</p><p>一些专业术语：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch </span>:派遣/调度</span><br><span class="line"></span><br><span class="line"><span class="attribute">queue</span>:队列</span><br><span class="line">    用来存放任务的先进先出（FIFO）的容器</span><br><span class="line"><span class="attribute">sync</span>:同步</span><br><span class="line">    只是在当前线程中执行任务，不具备开启新线程的能力</span><br><span class="line"><span class="attribute">async</span>:异步</span><br><span class="line">    可以在新的线程中执行任务，具备开启新线程的能力</span><br><span class="line"><span class="attribute">concurrent</span>:并发</span><br><span class="line">    多个任务并发（同时）执行</span><br><span class="line">串行：</span><br><span class="line">    一个任务执行完毕后，再执行下一个任务</span><br></pre></td></tr></table></figure><p>1、GCD中的核心概念</p><p>（1）任务</p><p>任务就是要在线程中执行的操作。我们需要将要执行的代码用block封装好，然后将任务添加到队列并指定任务的执行方式，等待CPU从队列中取出任务放到对应的线程中执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - <span class="built_in">queue</span>：队列</span><br><span class="line"> - block：任务</span><br><span class="line"><span class="comment">// 1.用同步的方式执行任务</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.用异步的方式执行任务</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.GCD中还有个用来执行任务的函数</span></span><br><span class="line"><span class="comment">// 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>（2）队列</p><p>串行队列：串行队列一次只调度一个任务，一个任务完成后再调度下一个任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建串行队列</span></span><br><span class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用dispatch_get_main_queue()获得主队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br><span class="line">注意：主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行。</span><br></pre></td></tr></table></figure><p>并发队列：并发队列可以同时调度多个任务，调度任务的方式，取决于执行任务的函数；并发功能只有在异步的（dispatch_async）函数下才有效；异步状态下，开启的线程上线由GCD底层决定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="number">1.</span>使用dispatch_queue_create函数创建队列</span><br><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="comment">// 队列名称,该名称可以协助开发调试以及崩溃分析报告 </span></span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr); <span class="comment">// 队列的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>以上自定义队列在MRC开发时需要使用dispatch_release释放队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__has_feature(objc_arc)</span></span><br><span class="line">    dispatch_release(<span class="built_in">queue</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主队列：主队列负责在主线程上调度任务，如果在主线程上有任务执行，会等待主线程空闲后再调度任务执行。主队列用于UI以及触摸事件等的操作，我们在进行线程间通信，通常是返回主线程更新UI的时候使用到。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 耗时操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">//放回主线程的函数</span></span><br><span class="line">    <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 在主线程更新 UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>全局并发队列：全局并发队列是由苹果API提供的，方便程序员使用多线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dispatch_get_global_queue函数获得全局的并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">dispatch_queue_priority_t</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="comment">// dispatch_queue_priority_t priority(队列的优先级 )</span></span><br><span class="line"><span class="comment">// unsigned long flags( 此参数暂时无用，用0即可 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>全局并发队列有优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局并发队列的优先级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH 2 <span class="comment">// 高优先级</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT 0 <span class="comment">// 默认（中）优先级</span></span></span><br><span class="line"><span class="comment">//注意，自定义队列的优先级都是默认优先级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-2) <span class="comment">// 低优先级</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN <span class="comment">// 后台优先级</span></span></span><br></pre></td></tr></table></figure><p>然而，iOS8 开始使用 QOS(服务质量) 替代了原有的优先级。获取全局并发队列时，直接传递 0，可以实现 iOS 7 &amp; iOS 8 later 的适配。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像这样</span></span><br><span class="line">dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>全局并发队列与并发队列的区别：</p><p>（1）全局并发队列与并发队列的调度方法相同<br>（2）全局并发队列没有队列名称<br>（3）在MRC开发中，全局并发队列不需要手动释放</p><p>2、执行任务的函数</p><p>（1）同步（dispatch_sync）</p><p>任务被添加到队列后，会当前线程被调度；队列中的任务同步执行完成后，才会调度后续任务。</p><p>在主线程中，向主队列添加同步任务，会造成死锁。<br>在其他线程中，向主队列向主队列添加同步任务，则会在主线程中同步执行。</p><p>我们可以利用同步的机制，建立任务之间的依赖关系。如用户登录后，才能够并发下载多部小说等情况。<br>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.imlifengfeng.ios"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// [NSThread currentThread]获得当前线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务顺序执行，但是如果用在串行队列中，仍然会依次顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@%d "</span>, [<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（2）异步（dispatch_async）</p><p>异步是多线程的代名词,当任务被添加到主队列后，会等待主线程空闲时才会调度该任务；添加到其他线程时，会开启新的线程调度任务。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.imlifengfeng.ios"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（3）以函数指针的方式调度任务</p><p>函数指针的调用方式有两种,同样是同步和异步；函数指针的传递类似于 pthread。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_sync_f</span></span><br><span class="line"><span class="keyword">dispatch_async_f</span></span><br></pre></td></tr></table></figure><p>函数指针调用在实际开发中几乎不用，只是有些面试中会问到，dispatch + block 才是 gcd 的主流！</p><p>3、开发中如何选择队列</p><p>选择队列当然是要先了解队列的特点：<br>串行队列：对执行效率要求不高，对执行顺序要求高，性能消耗小<br>并发队列：对执行效率要求高，对执行顺序要求不高，性能消耗大<br>如果不想兼顾 MRC 中队列的释放，建议选择使用全局队列 + 异步任务。</p><p>4、GCD的其他用法</p><p>（1）延时执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：从现在开始经过多少纳秒，参数2：调度任务的队列，参数3：异步执行的任务</span></span><br><span class="line"><span class="function"><span class="title">dispatch_after</span><span class="params">(when, queue, block)</span></span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(<span class="name">dispatch_time</span>(<span class="name">DISPATCH_TIME_NOW</span>, (<span class="name">int64_t</span>)(<span class="number">2.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 2秒后异步执行这里的代码...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（2）一次性执行</p><p>应用场景：保证某段代码在程序运行过程中只被执行一次，在单例设计模式中被广泛使用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（3）调度组（队列组）</p><p>应用场景：需要在多个耗时操作执行完毕之后，再统一做后续处理。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建调度组</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line"><span class="comment">//将调度组添加到队列，执行 block 任务</span></span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, queue, <span class="keyword">block</span>);</span><br><span class="line"><span class="comment">//当调度组中的所有任务执行结束后，获得通知，统一做后续操作</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), <span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5、应用案例：单例模式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在.m中保留一个全局的static的实例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供1个类方法让外界访问唯一的实例</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.实现copyWithZone:方法</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五、<strong>NSOperation</strong></p><p>NSOperation是苹果推荐使用的并发技术，它提供了一些用GCD不是很好实现的功能。NSOperation是基于GCD的面向对象的使用OC语言的封装。相比GCD，NSOperation的使用更加简单。NSOperation是一个抽象类，也就是说它并不能直接使用，而是应该使用它的子类。使用它的子类的方法有三种，使用苹果为我们提供的两个子类 <strong>NSInvocationOperation</strong>，<strong>NSBlockOperation</strong>和自定义继承自NSOperation的子类。</p><p>NSOperation的使用常常是配合NSOperationQueue来进行的。只要是使用NSOperation的子类创建的实例就能添加到NSOperationQueue操作队列之中，一旦添加到队列，操作就会自动异步执行（注意是异步）。<strong>如果没有添加到队列，而是使用start方法，则会在当前线程执行</strong>。</p><p>我们知道，线程间的通信主要是主线程与分线程之间进行的。主线程到分线程，NSOperation子类也有相应带参数的方法；而分线程到主线程，比如更新UI，它也有很方便的获取主队列（被添加到主队列的操作默认会在主线程执行）的方法：[NSOperationQueue mainQueue]。</p><p>1、NSInvocationOperation</p><p>（1）单个NSInvocationOperation</p><p>直接创建一个NSInvocationOperation的对象，然后调用start方法会直接在主线程执行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">  <span class="built_in">NSOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> </span><br><span class="line">selector:<span class="keyword">@selector</span>(downloadImage:) object:<span class="string">@"Invocation"</span>];</span><br><span class="line"> <span class="comment">//2.start方法，直接在当前线程执行</span></span><br><span class="line">    [op start];</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 调用的耗时操作,后面调用的耗时操作都是这个</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImage:(<span class="keyword">id</span>)obj&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[<span class="built_in">NSThread</span> currentThread],obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1151</span>:<span class="number">50868</span>] &lt;NSThread: <span class="number">0x7fae624047b0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">-----Invocation</span></span><br></pre></td></tr></table></figure><p>添加到NSOperationQueue：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">  NSOperation *op = [[NSInvocationOperation alloc]<span class="string">initWithTarget:</span>self </span><br><span class="line"><span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">downloadImage:</span>) <span class="string">object:</span>@<span class="string">"Invocation"</span>];</span><br><span class="line"> <span class="comment">//2.放到队列里面去</span></span><br><span class="line">    NSOperationQueue *q = [[NSOperationQueue alloc]init];</span><br><span class="line"><span class="comment">//只要把操作放到队列，会自动异步执行调度方法</span></span><br><span class="line">    [q <span class="string">addOperation:</span>op];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1192</span>:<span class="number">55469</span>] &lt;NSThread: <span class="number">0x7fbe59e45c30</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">3</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation</span></span><br></pre></td></tr></table></figure><p>在number为3，name为空的子线程执行。</p><p>（2）多个NSInvocationOperation</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列，GCD里面的并发队列使用最多，所以NSOperation技术直接把GCD里面的并发队列封装起来</span></span><br><span class="line"><span class="comment">//NSOperationQueue本质就是GCD里面的并发队列</span></span><br><span class="line"><span class="comment">//操作就是GCD里面异步执行的任务</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *q = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//把多个操作放到队列里面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">NSOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> </span><br><span class="line">       selector:<span class="keyword">@selector</span>(downloadImage:) object:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invocation%d"</span>,i]];</span><br><span class="line">  [q addOperation:op];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**[<span class="number">1222</span>:<span class="number">58476</span>] &lt;NSThread: <span class="number">0x7fdc14b0cd20</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">7</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation5</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58478</span>] &lt;NSThread: <span class="number">0x7fdc1357e5f0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">9</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation7</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58307</span>] &lt;NSThread: <span class="number">0x7fdc14a06ad0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">3</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation1</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58477</span>] &lt;NSThread: <span class="number">0x7fdc134916e0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">8</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation6</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58481</span>] &lt;NSThread: <span class="number">0x7fdc1357e120</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">12</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation10</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58475</span>] &lt;NSThread: <span class="number">0x7fdc14801710</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">6</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation4</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58480</span>] &lt;NSThread: <span class="number">0x7fdc13415630</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">11</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation9</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58306</span>] &lt;NSThread: <span class="number">0x7fdc13512e20</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">4</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation3</span></span><br><span class="line">··· ···</span><br></pre></td></tr></table></figure><p>线程名与输出均没有规律，很明显就是并发队列。</p><p>2、NSBlockOperation</p><p>NSBlockOperation的用法与NSInvocationOperation相同，只是创建的方式不同，它不需要去调用方法，而是直接使用代码块,显得更方便。这也使得NSBlockOperation比NSInvocationOperation更加流行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟GCD中的并发队列一样</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *q = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"><span class="comment">//跟GCD中的主队列一样</span></span><br><span class="line"><span class="comment">// NSOperationQueue *q = [NSOperationQueue mainQueue];</span></span><br><span class="line"><span class="comment">//把多个操作放到队列里面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@------%d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line"></span><br><span class="line"> &#125;];</span><br><span class="line">  <span class="comment">//把Block操作放到队列</span></span><br><span class="line">  [q addOperation:op];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"完成"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列输出结果：</span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72440</span>] &lt;NSThread: <span class="number">0x7f9cb2603460</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">6</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------5**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72442</span>] &lt;NSThread: <span class="number">0x7f9cb48106a0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">5</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------7**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72441</span>] &lt;NSThread: <span class="number">0x7f9cb242b3e0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">7</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------6**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72325</span>] &lt;NSThread: <span class="number">0x7f9cb4851550</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">9</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------2**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72320</span>] &lt;NSThread: <span class="number">0x7f9cb492be70</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">4</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------3**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72313</span>] &lt;NSThread: <span class="number">0x7f9cb24077b0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">2</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------1**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72276</span>] 完成</span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72444</span>] &lt;NSThread: <span class="number">0x7f9cb481cc40</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">11</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------9**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72326</span>] &lt;NSThread: <span class="number">0x7f9cb4923fe0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">3</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------0**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72440</span>] &lt;NSThread: <span class="number">0x7f9cb2603460</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">6</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------12**</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主队列输出结果：</span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] 完成</span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------0**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------1**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------2**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------3**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------4**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------5**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------6**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------7**</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>事实上NSBlockOperation有更简单的使用方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *q = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    [q addOperationWithBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@------%d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、线程间通信</p><p>主线程到子线程传对象，前面的例子里面已经有了，不再缀述。下面的例子就是回到主线程更新UI。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.p1 &#123;margin: <span class="number">0</span>.<span class="number">0</span>px <span class="number">0</span>.<span class="number">0</span>px <span class="number">0</span>.<span class="number">0</span>px <span class="number">0</span>.<span class="number">0</span>px<span class="comment">; font: 14.0px Menlo; c</span></span><br><span class="line"></span><br><span class="line">NSOperationQueue *q = [[NSOperationQueue alloc]init]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  [q <span class="keyword">addOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="keyword"> </span>   NSLog(@<span class="string">"耗时操作--%@"</span>,[NSThread currentThread])<span class="comment">;</span></span><br><span class="line">    [[NSOperationQueue mainQueue] <span class="keyword">addOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="keyword"> </span>     NSLog(@<span class="string">"更新UI-----%@"</span>,[NSThread currentThread])<span class="comment">;</span></span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">  &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>4、NSOperationQueue的一些高级操作</p><p>NSOperationQueue支持的高级操作有：队列的挂起，队列的取消，添加操作的依赖关系和设置最大并发数。</p><p>（1）最大并发数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSOperationQueue</span> *opQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写getter方法实现懒加载</span></span><br><span class="line">- (<span class="built_in">NSOperationQueue</span>*)opQueue&#123;</span><br><span class="line">  <span class="keyword">if</span> (_opQueue == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _opQueue = [[<span class="built_in">NSOperationQueue</span> alloc]init]; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _opQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 高级操作:最大并发数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置最大的并发数量（并非线程的数量）</span></span><br><span class="line">  <span class="keyword">self</span>.opQueue.maxConcurrentOperationCount = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//把多个操作放到队列里面</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@------%d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//把Block操作放到队列</span></span><br><span class="line">    [<span class="keyword">self</span>.opQueue addOperation:op];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（2）线程的挂起</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 高级操作：线程的挂起</span></span><br><span class="line"><span class="comment">//暂停继续(对队列的暂停和继续)，挂起的是队列，不会影响已经在执行的操作</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">  <span class="comment">//判断操作的数量，当前队列里面是不是有操作？</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.opQueue.operationCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前队列没有操作"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.opQueue.suspended = !<span class="keyword">self</span>.opQueue.isSuspended;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.opQueue.suspended) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"暂停"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"继续"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）取消队列里的所有操作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 高级操作：取消队列里的所有操作</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)cancelAll:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">  <span class="comment">//只能取消所有队列的里面的操作，正在执行的无法取消</span></span><br><span class="line">  <span class="comment">//取消操作并不会影响队列的挂起状态</span></span><br><span class="line">  [<span class="keyword">self</span>.opQueue cancelAllOperations];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"取消队列里所有的操作"</span>);</span><br><span class="line">  <span class="comment">//取消队列的挂起状态</span></span><br><span class="line">  <span class="comment">//（只要是取消了队列的操作，我们就把队列处于不挂起状态,以便于后续的开始）</span></span><br><span class="line">  <span class="keyword">self</span>.opQueue.suspended = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）依赖关系</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 例子</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 1.下载一个小说压缩包</span></span><br><span class="line"><span class="comment">  *  2.解压缩，删除压缩包</span></span><br><span class="line"><span class="comment">  * 3.更新UI</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1.下载一个小说压缩包,%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2.解压缩，删除压缩包,%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3.更新UI,%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定任务之间的依赖关系 --依赖关系可以跨队列(可以再子线程下载，在主线程更新UI)</span></span><br><span class="line"></span><br><span class="line">  [op2 addDependency:op1];</span><br><span class="line">  [op3 addDependency:op2];</span><br><span class="line"><span class="comment">//  [op1 addDependency:op3];  一定不能出现循环依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//waitUntilFinished  类似GCD中的调度组的通知</span></span><br><span class="line">  <span class="comment">//NO不等待，直接执行输出come here</span></span><br><span class="line">  <span class="comment">//YES等待任务执行完再执行输出come here</span></span><br><span class="line">  [<span class="keyword">self</span>.opQueue addOperations:@[op1,op2] waitUntilFinished:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在主线程更新UI</span></span><br><span class="line">  [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op3];</span><br><span class="line">  [op3 addDependency:op2];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"come here"</span>);</span><br></pre></td></tr></table></figure><p>还有一个NSOperationQueuePriority，队列优先级的概念，因为用的极少，所以这里不做介绍。</p><p>六、<strong>三种多线程技术比较</strong></p><p>1、NSThread</p><ul><li>优点：NSThread 比其他两个轻量级，使用简单</li></ul><ul><li>缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。线程同步对数据的加锁会有一定的系统开销</li></ul><ul><li><p>2、GCD<br>GCD 是iOS 4.0以后才出现的并发技术</p></li></ul><ul><li>使用方式：将任务添加到队列（串行/并行（全局）），指定执行任务的方法，（同步（阻塞）/异步 ）</li></ul><ul><li>拿到主队列：dispatch_get_main_queu()</li></ul><ul><li>NSOperation无法做到的：1.一次性执行，2.延迟执行，3.调度组（op实现要复杂的多 ）</li></ul><p>3、NSOperation<br>NSOperation iOS2.0的时候就出现了（当时不好用，后来苹果对其进行改造）</p><ul><li>使用方式：将操作（异步执行）添加到队列（并发/全局）</li></ul><ul><li>拿到主队列：[NSOperationQueue mainQueue] 主队列，任务添加到主队列就会在主线程执行</li></ul><ul><li>提供了GCD不好实现的：1.最大并发数，2.暂停和继续，3.取消所有任务，4.依赖关系</li></ul><p>GCD是比较底层的封装，我们知道较低层的代码一般性能都是比较高的，相对于NSOperationQueue。所以追求性能，而功能够用的话就可以考虑使用GCD。如果异步操作的过程需要更多的用户交互和被UI显示出来，NSOperationQueue会是一个好选择。如果任务之间没有什么依赖关系，而是需要更高的并发能力，GCD则更有优势。<br>高德纳的教诲：“在大概97%的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。”只有Instruments显示有真正的性能提升时才有必要用低级的GCD。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS UIWebView与WKWebView</title>
      <link href="/article/528/"/>
      <url>/article/528/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>UIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。WKWebView只能用代码创建，而且自身就支持了右滑返回手势allowsBackForwardNavigationGestures和加载进度estimatedProgress等一些UIWebView不具备却非常好用的属性。通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度也有提升，但是并不像内存那样提升那么多。下面列举一些其它的优势：</p><ul><li>更多的支持HTML5的特性</li></ul><ul><li>官方宣称的高达60fps的滚动刷新率以及内置手势</li></ul><ul><li>Safari相同的JavaScript引擎</li></ul><ul><li>将UIWebViewDelegate与UIWebView拆分成了14类与3个协议(<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html" target="_blank" rel="noopener">官方文档说明</a>)</li></ul><ul><li>另外用的比较多的，增加加载进度属性：estimatedProgress</li></ul><p>二、<strong>UIWebView的用法</strong></p><p>1、加载网页或本地文件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页url</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br><span class="line"><span class="comment">// 网络请求</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request =[<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"><span class="comment">// 加载网页</span></span><br><span class="line">[<span class="keyword">self</span>.webview loadRequest:request];</span><br></pre></td></tr></table></figure><p>注意，如果上述的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页url</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页url</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>];</span><br></pre></td></tr></table></figure><p>会无法加载网页并有如下提示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">2017-02-07</span> <span class="selector-tag">15</span><span class="selector-pseudo">:29</span><span class="selector-pseudo">:46.768</span> <span class="selector-tag">WebViewTest</span><span class="selector-attr">[12469:1020441]</span> <span class="selector-tag">App</span> <span class="selector-tag">Transport</span> <span class="selector-tag">Security</span> <span class="selector-tag">has</span> <span class="selector-tag">blocked</span> <span class="selector-tag">a</span> <span class="selector-tag">cleartext</span> <span class="selector-tag">HTTP</span> (<span class="attribute">http</span>:<span class="comment">//) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.</span></span><br></pre></td></tr></table></figure><p>原因为ATS禁止了HTTP的明文传输，因为它不安全。可以修改Info.plist文件，让它临时允许明文传输。</p><p>解决办法：<br>在Info.plist文件中添加”App Transport SecuritySettings”，Type为”Dictionary”，再添加一个item为”Allow Arbitray Loads”，Type 为”Boolean”，“Value”为“YES”即可。</p><p>2、网页导航刷新有关函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刷新</span></span><br><span class="line">- (<span class="keyword">void</span>)reload;</span><br><span class="line"><span class="comment">// 停止加载</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br><span class="line"><span class="comment">// 后退函数</span></span><br><span class="line">- (<span class="keyword">void</span>)goBack;</span><br><span class="line"><span class="comment">// 前进函数</span></span><br><span class="line">- (<span class="keyword">void</span>)goForward;</span><br><span class="line"><span class="comment">// 是否可以后退</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=canGoBack) <span class="built_in">BOOL</span> canGoBack;</span><br><span class="line"><span class="comment">// 是否可以向前</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=canGoForward) <span class="built_in">BOOL</span> canGoForward;</span><br><span class="line"><span class="comment">// 是否正在加载</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isLoading) <span class="built_in">BOOL</span> loading;</span><br></pre></td></tr></table></figure><p>3、相关代理协议</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UIWebViewDelegate</span></span><br><span class="line"><span class="comment">// 是否允许加载网页</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"允许加载网页"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始加载网页时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidStartLoad:(<span class="built_in">UIWebView</span> *)webView &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开始加载网页"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网页加载完成时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"网页加载完成"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网页加载错误时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">UIWebView</span> *)webView didFailLoadWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"网页加载错误时调用"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、与JS交互</p><p>（1）OC调用JS</p><p>OC调用JS主要通过下面方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> )stringByEvaluatingJavaScriptFromString:(<span class="built_in">NSString</span> )script;</span><br></pre></td></tr></table></figure><p>我们只需要传入要执行的JS代码块即可，如果有返回值，可以接收NSString类型返回值。</p><p>例如，我们获取网页Title并赋值给导航控制器Title：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> "调用JS"按钮点击事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="literal">void</span>)rightAction&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">self</span>.navigationItem.title = <span class="meta">[</span><span class="built_in">self</span>.webView stringByEvaluatingJavaScriptFromString:@<span class="string">"document.title"</span><span class="meta">]</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/2017/02/Snip20170208_15.png" alt="Snip20170208_15"></p><p>点击“调用JS”按钮后：</p><p><img src="/images/2017/02/Snip20170208_16.png" alt="Snip20170208_16"></p><p>（2）JS调用OC</p><p>JS是不能执行OC代码的，但是可以变相的执行，JS可以将要执行的操作封装到网络请求里面，然后OC拦截这个请求，获取URL里面的字符串解析即可，这里用到代理协议的如下方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>webView:<span class="params">(UIWebView *)</span>webView shouldStartLoadWithRequest:<span class="params">(NSURLRequest *)</span>request navigationType:<span class="params">(UIWebViewNavigationType)</span>navigationType</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取请求路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *url = request.URL.absoluteString;</span><br><span class="line">    <span class="comment">// 定义的协议</span></span><br><span class="line">    <span class="built_in">NSString</span> *scheme = <span class="string">@"ios://"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([url hasPrefix:scheme]) &#123;</span><br><span class="line">        <span class="comment">// 获得协议后面的路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *path = [url substringFromIndex:scheme.length];</span><br><span class="line">        <span class="comment">// 利用?切割路径 分割方法与参数</span></span><br><span class="line">        <span class="built_in">NSArray</span> *subpaths = [path componentsSeparatedByString:<span class="string">@"?"</span>];</span><br><span class="line">        <span class="comment">// 方法名 methodName == sendMessage:number2:</span></span><br><span class="line">        <span class="built_in">NSString</span> *methodName = [subpaths firstObject];</span><br><span class="line">        <span class="comment">// 参数  如：200&amp;300</span></span><br><span class="line">        <span class="built_in">NSArray</span> *params = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (subpaths.count == <span class="number">2</span>) &#123;</span><br><span class="line">            params = [[subpaths lastObject] componentsSeparatedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用本地函数</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(methodName) withObjects:params];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"想加载其他请求，不是想调用OC的方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、WKWebView的用法</p><p>WKWebView 和 UIWebView 的基本使用方法相类似，但是需要导入头文件 #import &lt;WebKit/WebKit.h&gt;。</p><p>1、加载网页</p><p>加载网页方法与UIWebView相同：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页url</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>];</span><br><span class="line"><span class="comment">// 网络请求</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request =[<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"><span class="comment">// 加载网页</span></span><br><span class="line">[<span class="keyword">self</span>.webview loadRequest:request];</span><br></pre></td></tr></table></figure><p>2、加载文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建url(可以随便从桌面拉张图片)</span></span><br><span class="line">NSURL *url = [NSURL <span class="string">fileURLWithPath:</span>@<span class="string">"/Users/ios/Desktop/图片/xxx.jpg"</span>];</span><br><span class="line"><span class="comment">// 加载文件</span></span><br><span class="line">[webView <span class="string">loadFileURL:</span>url <span class="string">allowingReadAccessToURL:</span>url];</span><br></pre></td></tr></table></figure><p>其他几个加载方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其它三个加载函数</span></span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)loadHTMLString:(<span class="built_in">NSString</span> *)string baseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)baseURL;</span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)loadData:(<span class="built_in">NSData</span> *)data MIMEType:(<span class="built_in">NSString</span> *)MIMEType characterEncodingName:(<span class="built_in">NSString</span> *)characterEncodingName baseURL:(<span class="built_in">NSURL</span> *)baseURL;</span><br></pre></td></tr></table></figure><p>3、网页导航刷新有关函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canGoBack;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canGoForward;</span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)goBack;</span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)goForward;</span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)reload;</span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)reloadFromOrigin; <span class="comment">// 增加的函数</span></span><br><span class="line">- (<span class="built_in">WKNavigation</span> *)goToBackForwardListItem:(<span class="built_in">WKBackForwardListItem</span> *)item; <span class="comment">// 增加的函数</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br></pre></td></tr></table></figure><ul><li>reloadFromOrigin会比较网络数据是否有变化，没有变化则使用缓存，否则从新请求。</li></ul><ul><li>goToBackForwardListItem：比向前向后更强大，可以跳转到某个指定历史页面</li></ul><p>4、常用属性</p><ul><li>allowsBackForwardNavigationGestures：BOOL类型，是否允许左右划手势导航，默认不允许</li></ul><ul><li>estimatedProgress：加载进度，取值范围0~1</li></ul><ul><li>title：页面title</li></ul><ul><li>scrollView.scrollEnabled：是否允许上下滚动，默认允许</li></ul><ul><li>backForwardList：WKBackForwardList类型，访问历史列表，可以通过前进后退按钮访问，或者通过goToBackForwardListItem函数跳到指定页面</li></ul><p>5、相关代理协议</p><p>几个常用代理协议：</p><p>（1）WKNavigationDelegate</p><p>最常用，和UIWebViewDelegate功能类似，追踪加载过程，有是否允许加载、开始加载、加载完成、加载失败。下面会对方法做简单的说明，并用数字标出调用的先后次序：1-2-3-4-5</p><p>三个是否允许加载方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收到服务器跳转请求之后调用 (服务器端redirect)，不一定调用</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">didReceiveServerRedirectForProvisionalNavigation</span><span class="selector-pseudo">:(WKNavigation</span> *)<span class="selector-tag">navigation</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 在收到服务器的响应头，根据response相关信息，决定是否跳转。decisionHandler必须调用，来决定是否跳转，参数WKNavigationActionPolicyCancel取消跳转，WKNavigationActionPolicyAllow允许跳转</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">decidePolicyForNavigationResponse</span><span class="selector-pseudo">:(WKNavigationResponse</span> *)<span class="selector-tag">navigationResponse</span> <span class="selector-tag">decisionHandler</span><span class="selector-pseudo">:(void</span> (^)(WKNavigationResponsePolicy))<span class="selector-tag">decisionHandler</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 在发送请求之前，决定是否跳转 </span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">decidePolicyForNavigationAction</span><span class="selector-pseudo">:(WKNavigationAction</span> *)<span class="selector-tag">navigationAction</span> <span class="selector-tag">decisionHandler</span><span class="selector-pseudo">:(void</span> (^)(WKNavigationActionPolicy))<span class="selector-tag">decisionHandler</span>;</span><br></pre></td></tr></table></figure><p>追踪加载过程方法:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 页面开始加载</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">didStartProvisionalNavigation:</span>(WKNavigation *)navigation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 开始获取到网页内容时返回</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">didCommitNavigation:</span>(WKNavigation *)navigation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 页面加载完成之后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">didFinishNavigation:</span>(WKNavigation *)navigation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面加载失败时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">didFailProvisionalNavigation:</span>(WKNavigation *)navigation;</span><br></pre></td></tr></table></figure><p>（2）WKUIDelegate</p><p>UI界面相关，原生控件支持，三种提示框：输入、确认、警告。首先将web提示框拦截然后再做处理。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的WebView</span></span><br><span class="line"><span class="selector-tag">-</span> (WKWebView *)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">createWebViewWithConfiguration</span><span class="selector-pseudo">:(WKWebViewConfiguration</span> *)<span class="selector-tag">configuration</span> <span class="selector-tag">forNavigationAction</span><span class="selector-pseudo">:(WKNavigationAction</span> *)<span class="selector-tag">navigationAction</span> <span class="selector-tag">windowFeatures</span><span class="selector-pseudo">:(WKWindowFeatures</span> *)<span class="selector-tag">windowFeatures</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入框</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">runJavaScriptTextInputPanelWithPrompt</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">prompt</span> <span class="selector-tag">defaultText</span><span class="selector-pseudo">:(nullable</span> <span class="selector-tag">NSString</span> *)<span class="selector-tag">defaultText</span> <span class="selector-tag">initiatedByFrame</span><span class="selector-pseudo">:(WKFrameInfo</span> *)<span class="selector-tag">frame</span> <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(NSString * __nullable result))<span class="selector-tag">completionHandler</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认框</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">runJavaScriptConfirmPanelWithMessage</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">message</span> <span class="selector-tag">initiatedByFrame</span><span class="selector-pseudo">:(WKFrameInfo</span> *)<span class="selector-tag">frame</span> <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(BOOL result))<span class="selector-tag">completionHandler</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告框</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">runJavaScriptAlertPanelWithMessage</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">message</span> <span class="selector-tag">initiatedByFrame</span><span class="selector-pseudo">:(WKFrameInfo</span> *)<span class="selector-tag">frame</span> <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(void))<span class="selector-tag">completionHandler</span>;</span><br></pre></td></tr></table></figure><p>6、与JS交互</p><p>（1）WKWebView加载JS</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JS文件路径</span></span><br><span class="line"><span class="built_in">NSString</span> *jsPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"demo"</span> ofType:<span class="string">@"js"</span>];</span><br><span class="line"><span class="comment">//读取JS文件内容</span></span><br><span class="line"><span class="built_in">NSString</span> *jsContent = [<span class="built_in">NSString</span> stringWithContentsOfFile:jsPath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//创建用户脚本对象，</span></span><br><span class="line"><span class="comment">//WKUserScriptInjectionTimeAtDocumentStart :HTML文档创建后，完成加载前注入，类似于&lt;head&gt;中</span></span><br><span class="line"><span class="comment">//WKUserScriptInjectionTimeAtDocumentEnd :HTML文件完成加载后注入,类似于&lt;body&gt;中</span></span><br><span class="line"><span class="built_in">WKUserScript</span> *script = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:jsContent injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//添加用户脚本</span></span><br><span class="line">[webView.configuration.userContentController addUserScript:script];</span><br></pre></td></tr></table></figure><p>（2）WKWebView执行JS方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行JS方法</span></span><br><span class="line">[webView evaluateJavaScript:<span class="string">@"test()"</span> completionHandler:^(<span class="keyword">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//result为执行js方法的返回值</span></span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Success"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Quartz2D详解</title>
      <link href="/article/514/"/>
      <url>/article/514/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>Quartz2D的API是纯C语言的，它是一个二维绘图引擎，同时支持iOS和Mac系统。Quartz2D的API来自于Core Graphics框架，数据类型和函数基本都以CG作为前缀。通常，我们可以使用系统提供的控件去完成大部分UI，但是有些UI界面极其复杂、而且比较个性化，用普通的UI控件无法实现，这时可以利用Quartz2D技术将控件内部的结构画出来，类似自定义控件。其实，iOS中大部分控件的内容都是通过Quartz2D画出来的，因此，Quartz2D在iOS开发中很重要的一个价值是：自定义view（自定义UI控件）。</p><p>Quartz 2D能完成的工作：</p><p>绘制图形 : 线条\三角形\矩形\圆\弧等；</p><p>绘制文字；</p><p>绘制\生成图片(图像)；</p><p>读取\生成PDF；</p><p>截图\裁剪图片；</p><p>自定义UI控件；</p><p>… …</p><p>二、<strong>图形上下文（Graphics Context）</strong></p><p>图形上下文（Graphics Context）：是一个CGContextRef类型的数据。</p><p>图形上下文的作用：</p><p>（1）保存绘图信息、绘图状态</p><p>（2）决定绘制的输出目标（绘制到什么地方去？）</p><p>（输出目标可以是PDF文件、Bitmap或者显示器的窗口上）</p><p><img src="/images/2017/02/图片-1.png" alt="图片 1"></p><p>相同的一套绘图序列，指定不同的Graphics Context，就可将相同的图像绘制到不同的目标上。</p><p>Quartz2D提供了以下几种类型的Graphics Context：</p><p>（1）Bitmap Graphics Context</p><p>（2）PDF Graphics Context</p><p>（3）Window Graphics Context</p><p>（4）Layer Graphics Context</p><p>（5）Printer Graphics Context</p><p><img src="/images/2017/02/1639.png" alt="1639"></p><p>将当前的上下文copy一份,保存到栈顶(那个栈叫做”图形上下文栈”)：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextSaveGState</span>(<span class="built_in">CGContextRef</span> c)</span><br></pre></td></tr></table></figure><p>将栈顶的上下文出栈,替换掉当前的上下文（清空之前对于上下文设置）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextRestoreGState</span>(<span class="built_in">CGContextRef</span> c)</span><br></pre></td></tr></table></figure><p>三、<strong>使用Quartz2D自定义View</strong></p><p>1、Quartz2D自定义view</p><p>如何利用Quartz2D自定义view？（自定义UI控件）如何利用Quartz2D绘制东西到view上？</p><p>首先，得有图形上下文，因为它能保存绘图信息，并且决定着绘制到什么地方去。</p><p>其次，那个图形上下文必须跟view相关联，才能将内容绘制到view上面。</p><p><strong>自定义**</strong>view<strong>**的步骤：</strong></p><p>（1）新建一个类，继承自UIView</p><p>（2）实现- (void)drawRect:(CGRect)rect方法，然后在这个方法中</p><p>（a）取得跟当前view相关联的图形上下文</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGContextRef ctx</span> = UIGraphicsGetCurrentContext();</span><br></pre></td></tr></table></figure><p>（b）绘制相应的图形内容</p><p>例如：画1/4圆（扇形）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGContextMoveToPoint(ctx, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">CGContextAddLineToPoint(ctx, <span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">CGContextAddArc(ctx, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, -M_PI_2, M_PI, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">CGContextClosePath(ctx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[UIColor redColor] set];</span><br></pre></td></tr></table></figure><p>（3）利用图形上下文将绘制的所有内容渲染显示到view上面</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextFillPath(<span class="name">ctx</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>注：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//M_PI的含义:π</span></span><br><span class="line"><span class="comment">//M_PI * 2的含义:2π</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//M_PI_2的含义:π/2</span></span><br><span class="line"><span class="comment">//M_PI / 2的含义:π/2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 画的图形路径</span></span><br><span class="line"><span class="comment">//bezierPathWithArcCenter:弧所在的圆心</span></span><br><span class="line"><span class="comment">//radius:圆的半径</span></span><br><span class="line"><span class="comment">//startAngle:开始角度,圆的最右侧为0度</span></span><br><span class="line"><span class="comment">//endAngle:截至角度,向下为正,向上为负.</span></span><br><span class="line"><span class="comment">//clockwise:时针的方向,yes:顺时针 no:逆时针</span></span><br><span class="line">UIBezierPath *path = [UIBezierPath <span class="string">bezierPathWithArcCenter:</span>self.center <span class="string">radius:</span>radius <span class="string">startAngle:</span>startA <span class="string">endAngle:</span>endA <span class="string">clockwise:</span>NO];</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyView.m</span></span><br><span class="line"><span class="comment">//  Quartz2DTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/2/6.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];<span class="comment">//设置背景为白色，为了便于观察绘制后的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">    <span class="built_in">CGContextAddArc</span>(ctx, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, -M_PI_2, M_PI, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">CGContextClosePath</span>(ctx);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(ctx);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_1.png" alt="Snip20170206_1"></p><p>2、核心方法drawRect:</p><ul><li>为什么要实现drawRect:方法才能绘图到view上？</li></ul><pre><code>* 因为在drawRect:方法中才能取得跟view相关联的图形上下文</code></pre><ul><li>drawRect:方法在什么时候被调用？</li></ul><pre><code>* 当view第一次显示到屏幕上时（被加到UIWindow上显示出来）* 调用view的setNeedsDisplay或者setNeedsDisplayInRect:时.</code></pre><ul><li>注意4点:</li></ul><pre><code>* 手动调用drawRect:方法，不会自动创建跟View相关联的上下文。应该</code></pre><p>调用setNeedsDisplay方法,系统底层会自动调用drawRect，告诉系统重新绘制View.这样，系统底层会自动创建跟View相关联的上下文</p><pre><code>* setNeedsDisplay底层会调用drawRect,并不是立马调用的.只是设了一个调用的标志.调用时刻是等下一次屏幕刷新时才去调用drawRect。屏幕每一秒刷新30-60秒次,所以1秒调用drawRect方法大概30-60次,速度非常快哦* view内部有个layer（图层）属性，drawRect:方法中取得的是一个Layer Graphics Context，因此，绘制的东西其实是绘制到view的layer上去了* View之所以能显示东西，完全是因为它内部的layer</code></pre><p>3、Quartz2D绘图的代码步骤</p><p><strong>第一步：获得图形上下文：</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGContextRef ctx</span> = UIGraphicsGetCurrentContext();</span><br></pre></td></tr></table></figure><p><strong>第二步：拼接路径（下面代码是绘制一条线段）：</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGContextMoveToPoint(<span class="name">ctx</span>, <span class="number">10</span>, <span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">CGContextAddLineToPoint(<span class="name">ctx</span>, <span class="number">100</span>, <span class="number">100</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>第三步：绘制路径：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CGContextStrokePath</span>(ctx); <span class="comment">// CGContextFillPath(ctx);</span></span><br></pre></td></tr></table></figure><p>四、<strong>Quartz2D重要函数</strong></p><p>1、常用拼接路径函数</p><p>新建一个起点</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextMoveToPoint</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y)</span><br></pre></td></tr></table></figure><p>添加新的线段到某个点</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextAddLineToPoint</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y)</span><br></pre></td></tr></table></figure><p>添加一个矩形</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextAddRect</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGRect</span> rect)</span><br></pre></td></tr></table></figure><p>添加一个椭圆</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextAddEllipseInRect</span>(<span class="built_in">CGContextRef</span> context, <span class="built_in">CGRect</span> rect)</span><br></pre></td></tr></table></figure><p>添加一个圆弧</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextAddArc</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y,</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> radius, <span class="built_in">CGFloat</span> startAngle, <span class="built_in">CGFloat</span> endAngle, <span class="keyword">int</span> clockwise)</span><br></pre></td></tr></table></figure><p>2、常用绘制路径函数</p><p>一般以CGContextDraw、CGContextStroke、CGContextFill开头的函数，都是用来绘制路径的。</p><p>Mode参数决定绘制的模式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextDrawPath</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGPathDrawingMode</span> mode)</span><br></pre></td></tr></table></figure><p>绘制空心路径</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextStrokePath</span>(<span class="built_in">CGContextRef</span> c)</span><br></pre></td></tr></table></figure><p>绘制实心路径</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextFillPath</span>(<span class="built_in">CGContextRef</span> c)</span><br></pre></td></tr></table></figure><p>3、矩阵操作函数</p><p>利用矩阵操作，能让绘制到上下文中的所有路径一起发生变化。</p><p>缩放：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextScaleCTM</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)</span><br></pre></td></tr></table></figure><p>旋转：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextRotateCTM</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> angle)</span><br></pre></td></tr></table></figure><p>平移：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextTranslateCTM</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)</span><br></pre></td></tr></table></figure><p>4、其他常用函数</p><p>设置线段宽度</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineWidth(<span class="name">ctx</span>, <span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>设置线段头尾部的样式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineCap(<span class="name">ctx</span>, kCGLineCapRound)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>设置线段转折点的样式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineJoin(<span class="name">ctx</span>, kCGLineJoinRound)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>设置颜色</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetRGBStrokeColor(ctx, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>五、<strong>Quartz2D的内存管理</strong></p><p>关于Quartz2D内存管理，有以下原则：</p><p>（1）使用含有“Create”或“Copy”的函数创建的对象，使用完后必须释放，否则将导致内存泄露。</p><p>（2）使用不含有“Create”或“Copy”的函数获取的对象，则不需要释放</p><p>（3）如果retain了一个对象，不再使用时，需要将其release掉。</p><p>（4）可以使用Quartz 2D的函数来指定retain和release一个对象。例如，如果创建了一个CGColorSpace对象，则使用函数CGColorSpaceRetain和CGColorSpaceRelease来retain和release对象。</p><p>（5）也可以使用Core Foundation的CFRetain和CFRelease。注意不能传递NULL值给这些函数。</p><p>六、<strong>Quartz2D使用案例</strong></p><p>1、画矩形、正方形</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//2.描述路径</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">    <span class="comment">//3.把路径添加到上下文</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];<span class="comment">// 路径的颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.把上下文的内容渲染到View的layer.</span></span><br><span class="line">    <span class="comment">//CGContextStrokePath(ctx);// 描边路径</span></span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(ctx);<span class="comment">// 填充路径</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_3.png" alt="Snip20170206_3"></p><p>2、画扇形</p><p>除上面“二、使用Quartz2D自定义View”中的方法外，也可以使用OC中自带画图方法实现，如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(CGRect)<span class="built_in">rect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    CGPoint center = CGPointMake(<span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="number">0.5</span>, <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="number">0.5</span>);</span><br><span class="line">    CGFloat radius = <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="number">0.5</span> - <span class="number">10</span>;</span><br><span class="line">    CGFloat startA = <span class="number">0</span>;</span><br><span class="line">    CGFloat endA = -M_PI_2;</span><br><span class="line">    <span class="comment">// 画弧的路径</span></span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:NO];</span><br><span class="line">    <span class="comment">// 添加一根线到圆心</span></span><br><span class="line">    [path addLineToPoint:center];</span><br><span class="line">    <span class="comment">// 闭合路径</span></span><br><span class="line">    [path closePath];</span><br><span class="line">    <span class="comment">// 路径颜色</span></span><br><span class="line">    [[UIColor redColor] <span class="built_in">set</span>];</span><br><span class="line">    <span class="comment">// 填充路径</span></span><br><span class="line">    [path <span class="built_in">fill</span>];</span><br><span class="line">    <span class="comment">// 描边路径</span></span><br><span class="line">    <span class="comment">//[path stroke];</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_4.png" alt="Snip20170206_4"></p><p>注：</p><p>判断一个点是否在一个矩形框内</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGRectContainsPoint（<span class="built_in">rect</span>,<span class="built_in">point</span>）;<span class="comment">//判断point这个点是否在rect这个矩形框内</span></span><br></pre></td></tr></table></figure><p>3、画圆形</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//2.描述路径</span></span><br><span class="line">    <span class="comment">// cornerRadius:圆角半径。矩形的宽高都为200，如果圆角为100，那么两个角之间弧线上任意一点到矩形中心的距离都为100,所以为圆形</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>) cornerRadius:<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//3.把路径添加到上下文</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];<span class="comment">// 路径的颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.把上下文的内容渲染到View的layer.</span></span><br><span class="line">    <span class="comment">// CGContextStrokePath(ctx);// 描边路径</span></span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(ctx);<span class="comment">// 填充路径</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_5.png" alt="Snip20170206_5"></p><p>4、画圆角矩形</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//2.描述路径</span></span><br><span class="line">    <span class="comment">// cornerRadius:圆角半径。</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>) cornerRadius:<span class="number">50</span>];</span><br><span class="line">    <span class="comment">//3.把路径添加到上下文</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];<span class="comment">// 路径的颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.把上下文的内容渲染到View的layer.</span></span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);<span class="comment">// 描边路径</span></span><br><span class="line">    <span class="comment">//CGContextFillPath(ctx);// 填充路径</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_6.png" alt="Snip20170206_6"></p><p>5、画直线</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.获取跟View相关联的上下文(uigraphics开头)</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.描述路径</span></span><br><span class="line">    <span class="comment">//一条路径可以绘制多条线 路径:path     路径绘制多条线:path使用了两次（2次的起点到终点），都是将线添加到某个点</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    <span class="comment">//设置起点</span></span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>)];</span><br><span class="line">    <span class="comment">//添加一根线Line到某个点</span></span><br><span class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">250</span>, <span class="number">50</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//画第二根线</span></span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">250</span>)];</span><br><span class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">250</span>, <span class="number">100</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线宽</span></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//设置线的连接样式</span></span><br><span class="line">    <span class="built_in">CGContextSetLineJoin</span>(ctx, kCGLineJoinBevel);</span><br><span class="line">    <span class="comment">//设置线的顶角样式</span></span><br><span class="line">    <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);<span class="comment">// 圆角线条</span></span><br><span class="line">    <span class="comment">//设置线条颜色</span></span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.把路径添加到上下文</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</span><br><span class="line">    <span class="comment">//4.把上下文当中绘制的内容渲染到跟View关联的layer</span></span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_7.png" alt="Snip20170206_7"></p><p>6、画曲线</p><p>本塞尔曲线原理：</p><p><img src="/images/2017/02/2364940-93c60e25992fecb7.gif" alt="2364940-93c60e25992fecb7"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.获取跟View相关联的上下文.】</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//2.描述路径</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span>  bezierPath];</span><br><span class="line">    <span class="comment">//画曲线,设置起点.还有一个控制点(用来控制曲线的方向跟弯曲程度)</span></span><br><span class="line">    <span class="comment">//设置起点</span></span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">150</span>)];</span><br><span class="line">    <span class="comment">//添加一要曲线到某个点</span></span><br><span class="line">    [path addQuadCurveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">150</span>) controlPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">10</span>)];</span><br><span class="line">    <span class="comment">//3.把路径添加到上下文当中</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</span><br><span class="line">    <span class="comment">//4.把上下文的内容渲染View上</span></span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_8.png" alt="Snip20170206_8"></p><p>7、画饼图</p><p>方法1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *dataArray =  @[@<span class="number">25</span>,@<span class="number">25</span>,@<span class="number">50</span>];</span><br><span class="line">    <span class="comment">// 画弧</span></span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(rect.size.width * <span class="number">0.5</span>, rect.size.height * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 半径</span></span><br><span class="line">    <span class="built_in">CGFloat</span> radius = rect.size.width * <span class="number">0.5</span> - <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> startA = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> angle = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> endA = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *num <span class="keyword">in</span> dataArray) &#123;</span><br><span class="line">        startA = endA;</span><br><span class="line">        <span class="comment">// 遍历出第一个对象25,angle =25/100 *2π，即angle = π/2，所以为1/4圆,</span></span><br><span class="line">        angle = num.intValue / <span class="number">100.0</span> * M_PI * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 截至角度= 开始的角度+ 遍历出的对象所占整个圆形的角度</span></span><br><span class="line">        endA = startA + angle;</span><br><span class="line">        <span class="comment">// 顺势针画贝塞尔曲线</span></span><br><span class="line">        <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="literal">YES</span>];</span><br><span class="line">        <span class="comment">// 设置随机颜色</span></span><br><span class="line">        [[<span class="keyword">self</span> randomColor] set];</span><br><span class="line">        <span class="comment">// 添加一根线到圆心</span></span><br><span class="line">        [path addLineToPoint:center];</span><br><span class="line">        <span class="comment">// 填充路径</span></span><br><span class="line">        [path fill];</span><br><span class="line">        <span class="comment">// 描边路径</span></span><br><span class="line"><span class="comment">//      [path stroke];</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 生成随机颜色</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return UIColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="built_in">UIColor</span> *)randomColor&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> redLevel    = rand() / (<span class="keyword">float</span>) RAND_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> greenLevel  = rand() / (<span class="keyword">float</span>) RAND_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blueLevel   = rand() / (<span class="keyword">float</span>) RAND_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed: redLevel green: greenLevel blue: blueLevel alpha: <span class="number">1.0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_9.png" alt="Snip20170206_9"></p><p>方法二：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.bounds.size.width * <span class="number">0.5</span>, <span class="keyword">self</span>.bounds.size.height * <span class="number">.5</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> radius = <span class="keyword">self</span>.bounds.size.width * <span class="number">0.5</span> - <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> startA = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> endA = <span class="number">25</span> / <span class="number">100.0</span> * M_PI * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line">    <span class="comment">//添加一根线到圆心</span></span><br><span class="line">    [path addLineToPoint:center];</span><br><span class="line">    [path fill];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二个扇形</span></span><br><span class="line">    startA = endA;</span><br><span class="line">    <span class="built_in">CGFloat</span> angle = <span class="number">25</span> / <span class="number">100.0</span> * M_PI * <span class="number">2</span>;</span><br><span class="line">    endA = startA + angle;</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path2 = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">UIColor</span> greenColor] set];</span><br><span class="line">    <span class="comment">//添加一根线到圆心</span></span><br><span class="line">    [path2 addLineToPoint:center];</span><br><span class="line">    [path2 fill];</span><br><span class="line">    </span><br><span class="line">    startA = endA;</span><br><span class="line">    angle = <span class="number">50</span> / <span class="number">100.0</span> * M_PI * <span class="number">2</span>;</span><br><span class="line">    endA = startA + angle;</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path3 = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">UIColor</span> blueColor] set];</span><br><span class="line">    <span class="comment">//添加一根线到圆心</span></span><br><span class="line">    [path3 addLineToPoint:center];</span><br><span class="line">    [path3 fill];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 生成随机颜色</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return UIColor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="built_in">UIColor</span> *)randomColor&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> redLevel    = rand() / (<span class="keyword">float</span>) RAND_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> greenLevel  = rand() / (<span class="keyword">float</span>) RAND_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blueLevel   = rand() / (<span class="keyword">float</span>) RAND_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed: redLevel green: greenLevel blue: blueLevel alpha: <span class="number">1.0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><p>如果想实现点击以下变换颜色可以加上如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重绘</span></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、绘制文字</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"李峰峰博客：http://www.imlifengfeng.com/"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//设置字体</span></span><br><span class="line">    dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">30</span>];</span><br><span class="line">    <span class="comment">//设置颜色</span></span><br><span class="line">    dict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    <span class="comment">//设置描边</span></span><br><span class="line">    dict[<span class="built_in">NSStrokeColorAttributeName</span>] = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    dict[<span class="built_in">NSStrokeWidthAttributeName</span>] = @<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//设置阴影</span></span><br><span class="line">    <span class="built_in">NSShadow</span> *shadow = [[<span class="built_in">NSShadow</span> alloc] init];</span><br><span class="line">    shadow.shadowColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">    shadow.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">-2</span>, <span class="number">-2</span>);</span><br><span class="line">    shadow.shadowBlurRadius = <span class="number">3</span>;</span><br><span class="line">    dict[<span class="built_in">NSShadowAttributeName</span>] = shadow;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置文字的属性</span></span><br><span class="line">    <span class="comment">//drawAtPoint不会自动换行</span></span><br><span class="line">    <span class="comment">//[str drawAtPoint:CGPointMake(0, 0) withAttributes:dict];</span></span><br><span class="line">    <span class="comment">//drawInRect会自动换行</span></span><br><span class="line">    [str drawInRect:<span class="keyword">self</span>.bounds withAttributes:dict];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_10.png" alt="Snip20170206_10"></p><p>9、加水印</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  Quartz2DTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/2/6.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImageView</span> *myImageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height)];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:myImageView];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成一张图片</span></span><br><span class="line">    <span class="comment">//0.加载图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *oriImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"test"</span>];</span><br><span class="line">    <span class="comment">//1.创建位图上下文(size:开启多大的上下文,就会生成多大的图片)</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(oriImage.size);</span><br><span class="line">    <span class="comment">//2.把图片绘制到上下文当中</span></span><br><span class="line">    [oriImage drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">    <span class="comment">//3.绘制水印(虽说UILabel可以快速实现这种效果，但是我们也可以绘制出来)</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"李峰峰博客"</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">20</span>];</span><br><span class="line">    dict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    </span><br><span class="line">    [str drawAtPoint:<span class="built_in">CGPointZero</span> withAttributes:dict];</span><br><span class="line">    <span class="comment">//4.从上下文当中生成一张图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">//5.关闭位图上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    myImageView.image = newImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/02/Snip20170206_11.png" alt="Snip20170206_11"></p><p>10、屏幕截图</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成图片</span></span><br><span class="line">    <span class="comment">//1.开启一个位图上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.view.bounds.size);</span><br><span class="line">    <span class="comment">//2.把View的内容绘制到上下文当中</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx =  <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//UIView内容想要绘制到上下文当中, 必须使用渲染的方式</span></span><br><span class="line">    [<span class="keyword">self</span>.view.layer renderInContext:ctx];</span><br><span class="line">    <span class="comment">//3.从上下文当中生成一张图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">//4.关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="comment">//把图片转成二进制流</span></span><br><span class="line">    <span class="comment">//NSData *data = UIImageJPEGRepresentation(newImage, 1);</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(newImage);</span><br><span class="line">    </span><br><span class="line">    [data writeToFile:<span class="string">@"/Users/lifengfeng/Downloads/imlifengfeng.jpg"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p>截图而已，就跟普通截图一样，自己试。</p><p>以上就是关于Quartz2D一些常用的案例，Quartz2D还可以实现更多效果，具体的根据需求去实现。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Quartz2D </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS FMDB详解</title>
      <link href="/article/512/"/>
      <url>/article/512/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>FMDB是iOS平台的SQLite数据库框架，它以OC的方式封装了SQLite的C语言API。FMDB的优点：</p><p>（1）使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码。</p><p>（2）对比苹果自带的Core Data框架，更加轻量级和灵活。</p><p>（3）提供了多线程安全的数据库操作方法，有效地防止数据混乱。</p><p>FMDB链接：<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">https://github.com/ccgus/fmdb</a></p><p>将FMDB下载下来并且导入sqlite框架后添加到项目中就可以使用了。</p><p>FMDB中重要的类：</p><p>FMDatabase：一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p><p>FMResultSet：使用FMDatabase执行查询后的结果集</p><p>FMDatabaseQueue：用于在多线程中执行多个查询或更新，它是线程安全的</p><p>二、<strong>FMDB的使用方法</strong></p><p>首先要在用到的地方导入相关头文件：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"FMDB.h"</span></span><br></pre></td></tr></table></figure><p>1、创建数据库</p><p>如果该位置没有此数据库文件将会建立一个新的数据库文件，如果已经有了，将会直接获得该数据库：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FMDatabase</span> <span class="meta">*db</span> <span class="string">=</span> <span class="string">[FMDatabase</span> <span class="attr">databaseWithPath:dataBasePath];</span></span><br></pre></td></tr></table></figure><p>dataBasePath可以这样设定：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">dataBasePath</span> <span class="selector-attr">[[(NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)) lastObject]</span><span class="selector-tag">stringByAppendingPathComponent</span><span class="selector-pseudo">:dataBaseName</span>]</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">dataBaseName</span> @"<span class="keyword">test</span>.<span class="keyword">sqlite</span>"</span><br></pre></td></tr></table></figure><p>2、打开数据库</p><p>返回BOOL类型，代表是否成功：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[db open]</span><br></pre></td></tr></table></figure><p>3、关闭数据库</p><p>返回BOOL类型，代表是否成功：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[db close]</span><br></pre></td></tr></table></figure><p>4、创建新表</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 创建表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)createTable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *sqlCreateTable = <span class="string">@"CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL)"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> res = [<span class="keyword">self</span>.db executeStatements:sqlCreateTable];</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"建表失败！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"建表成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、增加数据</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)addData:(<span class="built_in">NSString</span> *)name withAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *sql = <span class="string">@"INSERT INTO t_student (name, age) VALUES (?,?);"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> res = [<span class="keyword">self</span>.db executeUpdate:sql,name,@(age)];</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"添加数据失败！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"添加数据成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、删除数据</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 删除数据</span><br><span class="line"> */</span><br><span class="line">-(void)delData:(NSString *)name&#123;</span><br><span class="line">    </span><br><span class="line">    if (<span class="string">[self.db open]</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *sql = @<span class="string">"<span class="keyword">DELETE</span> FROM t_student WHERE name = ?"</span>;</span><br><span class="line">        </span><br><span class="line">        BOOL res = <span class="string">[self.db executeUpdate:sql, name]</span>;</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            NSLog(@<span class="string">"删除数据失败！"</span>);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@<span class="string">"删除数据成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="string">[self.db close]</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、修改数据</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 修改数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)updateData:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *sql = <span class="string">@"UPDATE t_student SET name = ?"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> res = [<span class="keyword">self</span>.db executeUpdate:sql,name];</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"修改数据失败！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"修改数据成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、查询数据</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 查询数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)queryData&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回数据库中第一条满足条件的结果</span></span><br><span class="line">        <span class="built_in">NSString</span> *sql = <span class="string">@"SELECT * FROM t_student"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回全部查询结果</span></span><br><span class="line">        FMResultSet *resultSet=[<span class="keyword">self</span>.db executeQuery:sql];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ([resultSet next]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idNum = [resultSet intForColumn:<span class="string">@"id"</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *name = [resultSet objectForColumnName:<span class="string">@"name"</span>];</span><br><span class="line">            <span class="keyword">int</span> age = [resultSet intForColumn:<span class="string">@"age"</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"id=%i ,name=%@, age=%i"</span>,idNum,name,age);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [resultSet close];</span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要特别注意上面用的占位符为“?”而不是“%@”</strong>。</p><p>三、<strong>FMDatabaseQueue</strong></p><p>FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类。</p><p>1、FMDatabaseQueue的创建与数据库操作</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue <span class="string">databaseQueueWithPath:</span>path];</span><br><span class="line"></span><br><span class="line">[queue <span class="string">inDatabase:</span>^(FMDatabase *db) &#123;<span class="comment">//从这个block中直接获得打开的数据库实例</span></span><br><span class="line">    </span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO t_student(name) VALUES (?)"</span>, @<span class="string">"Jack"</span>];</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO t_student(name) VALUES (?)"</span>, @<span class="string">"Rose"</span>];</span><br><span class="line">    [db <span class="string">executeUpdate:</span>@<span class="string">"INSERT INTO t_student(name) VALUES (?)"</span>, @<span class="string">"Jim"</span>];</span><br><span class="line">    </span><br><span class="line">    FMResultSet *rs = [db <span class="string">executeQuery:</span>@<span class="string">"select * from t_student"</span>];</span><br><span class="line">    <span class="keyword">while</span> ([rs next]) &#123;</span><br><span class="line">        <span class="comment">// …</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>2、FMDatabaseQueue使用事务</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">queue</span> inTransaction:^(<span class="name">FMDatabase</span> *db, BOOL *rollback) &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"INSERT INTO t_student(name) VALUES (?)"</span>, @<span class="string">"Jack"</span>]<span class="comment">;</span></span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"INSERT INTO t_student(name) VALUES (?)"</span>, @<span class="string">"Rose"</span>]<span class="comment">;</span></span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"INSERT INTO t_student(name) VALUES (?)"</span>, @<span class="string">"Jim"</span>]<span class="comment">;</span></span><br><span class="line">    if(<span class="name">发现情况不对</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *rollback = YES//回滚事务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FMResultSet *rs = [<span class="name">db</span> executeQuery:@<span class="string">"select * from t_student"</span>]<span class="comment">;</span></span><br><span class="line">    while ([<span class="name">rs</span> next]) &#123;</span><br><span class="line">        // …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>当然也可以使用如下方法：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">self.queue</span> inDatabase:^(<span class="name">FMDatabase</span> *db) &#123;</span><br><span class="line">    // 开启事务</span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"begin transaction;"</span>]<span class="comment">;//等价于[db beginTransaction];</span></span><br><span class="line"></span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"update t_student set age = ? where name = ?;"</span>, @20, @<span class="string">"jack"</span>]<span class="comment">;</span></span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"update t_student set age = ? where name = ?;"</span>, @20, @<span class="string">"jack"</span>]<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">    if (<span class="name">发现情况不对</span>)&#123;</span><br><span class="line">        // 回滚事务</span><br><span class="line">        [<span class="name">db</span> executeUpdate:@<span class="string">"rollback transaction;"</span>]<span class="comment">;//等价于[db rollback];</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    [<span class="name">db</span> executeUpdate:@<span class="string">"update t_student set age = ? where name = ?;"</span>, @20, @<span class="string">"jack"</span>]<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        // 提交事务</span><br><span class="line">       [<span class="name">db</span> executeUpdate:@<span class="string">"commit transaction;"</span>]<span class="comment">;//等价于[db commit];</span></span><br><span class="line"></span><br><span class="line">    &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> FMDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS NSNotification详解</title>
      <link href="/article/509/"/>
      <url>/article/509/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>NSNotification顾名思义就是通知的作用，一个对象通知另外一个对象，可以用来传递参数、通信等作用，与delegate的一对一不同，通知是多对多的。在一个对象中注册了通知，那么其他任意对象都可以来对这个对象发出通知。</p><p>二、<strong>NSNotificationCenter</strong></p><p>每一个应用程序都有一个通知中心(NSNotificationCenter)实例，专门负责协助不同对象之间的消息通信</p><p>任何一个对象都可以向通知中心发布通知(NSNotification)，描述自己在做什么。其他感兴趣的对象(Observer)可以申请在某个特定通知发布时(或在某个特定的对象发布通知时)收到这个通知</p><p>通知与代理的区别：通知是多对多的，代理是一对一的。如下图：</p><p><img src="/images/2017/01/图片-1.png" alt="图片 1"></p><p>比如，键盘弹出的时候也会发送一条通知。</p><p>三、<strong>NSNotification</strong></p><p>一个完整的通知一般包含3个属性：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> (NSString *)name; <span class="regexp">//</span> 通知的名称</span></span><br><span class="line"><span class="ruby">- (id)object; <span class="regexp">//</span> 通知发布者(是谁要发布通知)</span></span><br><span class="line"><span class="ruby">- (NSDictionary *)userInfo; <span class="regexp">//</span> 一些额外的信息(通知发布者传递给通知接收者的信息内容)</span></span><br></pre></td></tr></table></figure><p>创建一个通知（NSNotification）对象：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)notificationWithName:(<span class="type">NSString</span> *)aName object:(id)anObject;</span><br></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)notificationWithName:(<span class="type">NSString</span> *)aName object:(id)anObject userInfo:(<span class="type">NSDictionary</span> *)aUserInfo;</span><br></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithName:(<span class="type">NSString</span> *)name object:(id)object userInfo:(<span class="type">NSDictionary</span> *)userInfo;</span><br></pre></td></tr></table></figure><p><strong>实际上创建通知对象并不是必须的，更方便的是通过通知中心发送通知。</strong></p><p>四、<strong>发布通知</strong></p><p>通知中心(NSNotificationCenter)提供了相应的方法来帮助发布通知。</p><p>获得通知中心对象：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *center = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br></pre></td></tr></table></figure><p>通知中心提供的发布通知的方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>postNotification:<span class="params">(NSNotification *)</span>notification;</span><br></pre></td></tr></table></figure><p>上述为发布一个notification通知，可在notification对象中设置通知的名称、通知发布者、额外信息等。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>postNotificationName:<span class="params">(NSString *)</span>aName object:<span class="params">(id)</span>anObject;</span><br></pre></td></tr></table></figure><p>发布一个名称为aName的通知，anObject为这个通知的发布者。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>postNotificationName:<span class="params">(NSString *)</span>aName object:<span class="params">(id)</span>anObject userInfo:<span class="params">(NSDictionary *)</span>aUserInfo;</span><br></pre></td></tr></table></figure><p>发布一个名称为aName的通知，anObject为这个通知的发布者，aUserInfo为额外信息。</p><p>当我们添加通知以后，我们就可以发出通知，也是通过NSNotificationCenter类的defaultCenter来获取到通知中心，然后通过postNotificationName来发出通知。这里需要注意的一点就是<strong>这样发出的通知是同步操作</strong>，也就是只有当发出的通知执行完毕以后才会继续执行接下去的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)getNotification:(<span class="built_in">NSNotification</span> *)info&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = info.userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是发出通知以后会调用的方法，在多线程操作时，发出通知的对象和接收通知的对象需要处于同一个线程。</p><p>五、<strong>注册通知监听器</strong></p><p>通知中心(NSNotificationCenter)提供了方法来注册一个监听通知的监听器(Observer)。</p><p>方法1：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addObserver:<span class="params">(id)</span>observer selector:<span class="params">(SEL)</span>aSelector name:<span class="params">(NSString *)</span>aName object:<span class="params">(id)</span>anObject;</span><br></pre></td></tr></table></figure><p>observer：监听器，即谁要接收这个通知。</p><p>aSelector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入，意思是收到通知后调用接收者中的哪个方法。</p><p>aName：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知，意思是监听哪个aName的通知。</p><p>anObject：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知，意思是监听哪个对象发出的通知。</p><p>例如，监听输入框内容是否发生改变：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">selector</span>:</span><br><span class="line">@<span class="keyword">selector</span>(<span class="keyword">textChange</span>) name:UITextFieldTextDidChangeNotification object:self.accountField];</span><br></pre></td></tr></table></figure><p>当输入框内容发生改变会自动发送通知，之后会调用我们自定义的textChange方法。</p><p>方法2：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">addObserverForName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span> <span class="selector-tag">object</span><span class="selector-pseudo">:(id)obj</span> <span class="selector-tag">queue</span>:</span><br><span class="line">(NSOperationQueue *)<span class="selector-tag">queue</span> <span class="selector-tag">usingBlock</span><span class="selector-pseudo">:(void</span> (^)(NSNotification *note))<span class="selector-tag">block</span>;</span><br></pre></td></tr></table></figure><p>name：通知的名称。</p><p>obj：通知发布者。</p><p>queue：决定了block在哪个操作队列中执行，如果传nil，默认在当前操作队列中同步执行。</p><p>block：收到对应的通知时，会回调这个block。</p><p>接下来我们通过一个小demo来看下具体用法（代码比较简单，不再解释，不过这个代码有小问题哦，还没有取消注册监听呢，取消方法后面再讲~）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Person.h</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/27.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)newsCome:(<span class="built_in">NSNotification</span> *)note;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Person.m</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/27.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NewsCompany.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)newsCome:(<span class="built_in">NSNotification</span> *)note</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通知的发布者</span></span><br><span class="line">    NewsCompany *obj = note.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@接收到了%@发出的通知,通知内容是:%@"</span>, <span class="keyword">self</span>.name, obj.name, note.userInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NewsCompany.h</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/27.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NewsCompany</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NewsCompany.m</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/27.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NewsCompany.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NewsCompany</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/27.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#<span class="keyword">import</span> <span class="string">"AppDelegate.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"Person.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NewsCompany.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 1.初始化机构</span></span><br><span class="line">        NewsCompany *tx = [[NewsCompany alloc] <span class="keyword">init</span>];</span><br><span class="line">        tx.name = @<span class="string">"腾讯新闻"</span>;</span><br><span class="line">        </span><br><span class="line">        NewsCompany *sina = [[NewsCompany alloc] <span class="keyword">init</span>];</span><br><span class="line">        sina.name = @<span class="string">"新浪新闻"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.初始化3个人</span></span><br><span class="line">        Person *zhangsan = [[Person alloc] <span class="keyword">init</span>];</span><br><span class="line">        zhangsan.name = @<span class="string">"张三"</span>;</span><br><span class="line">        </span><br><span class="line">        Person *lisi = [[Person alloc] <span class="keyword">init</span>];</span><br><span class="line">        lisi.name = @<span class="string">"李四"</span>;</span><br><span class="line">        </span><br><span class="line">        Person *wangwu = [[Person alloc] <span class="keyword">init</span>];</span><br><span class="line">        wangwu.name = @<span class="string">"王五"</span>;</span><br><span class="line">        </span><br><span class="line">        NSNotificationCenter *center = [NSNotificationCenter defaultCenter];</span><br><span class="line">        <span class="comment">// 3.添加监听器</span></span><br><span class="line">        <span class="comment">// zhangsan只监听tx发出的junshi_news_come通知</span></span><br><span class="line">        <span class="comment">// zhangsan</span></span><br><span class="line">        [center addObserver:zhangsan selector:<span class="meta">@selector(newsCome:)</span> name:@<span class="string">"junshi_news_come"</span> <span class="keyword">object</span>:nil];</span><br><span class="line">        [center addObserver:zhangsan selector:<span class="meta">@selector(newsCome:)</span> name:@<span class="string">"yule_news_come"</span> <span class="keyword">object</span>:nil];</span><br><span class="line">        <span class="comment">// lisi</span></span><br><span class="line">        [center addObserver:lisi selector:<span class="meta">@selector(newsCome:)</span> name:nil <span class="keyword">object</span>:tx];</span><br><span class="line">        <span class="comment">// wangwu</span></span><br><span class="line">        [center addObserver:wangwu selector:<span class="meta">@selector(newsCome:)</span> name:nil <span class="keyword">object</span>:nil];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.发布新闻</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// tx发布了一则叫做junshi_news_come的通知</span></span><br><span class="line">        [center postNotificationName:@<span class="string">"junshi_news_come"</span></span><br><span class="line">                              <span class="keyword">object</span>:tx</span><br><span class="line">                            userInfo:@&#123;@<span class="string">"title"</span> : @<span class="string">"伊拉克战争停止了"</span>,</span><br><span class="line">                                       @<span class="string">"intro"</span> : @<span class="string">"伊拉克战争停止了.........."</span>&#125;];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sina发布了一则叫做yule_news_come的通知</span></span><br><span class="line">        [center postNotificationName:@<span class="string">"yule_news_come"</span></span><br><span class="line">                              <span class="keyword">object</span>:sina</span><br><span class="line">                            userInfo:@&#123;@<span class="string">"title"</span> : @<span class="string">"川普出柜迎娶安倍"</span>,</span><br><span class="line">                                       @<span class="string">"intro"</span> : @<span class="string">"川普出柜迎娶安倍.........."</span>&#125;];</span><br><span class="line">   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-01-27 <span class="number">15</span>:<span class="number">43</span>:<span class="number">29</span>.<span class="number">273</span> NotificationTest[<span class="number">2395</span>:<span class="number">155782</span>] 张三接收到了腾讯新闻发出的通知,通知内容是:&#123;</span><br><span class="line">    intro = <span class="string">"伊拉克战争停止了.........."</span><span class="comment">;</span></span><br><span class="line">    title = <span class="string">"伊拉克战争停止了"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2017</span>-01-27 <span class="number">15</span>:<span class="number">43</span>:<span class="number">29</span>.<span class="number">275</span> NotificationTest[<span class="number">2395</span>:<span class="number">155782</span>] 李四接收到了腾讯新闻发出的通知,通知内容是:&#123;</span><br><span class="line">    intro = <span class="string">"伊拉克战争停止了.........."</span><span class="comment">;</span></span><br><span class="line">    title = <span class="string">"伊拉克战争停止了"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2017</span>-01-27 <span class="number">15</span>:<span class="number">43</span>:<span class="number">29</span>.<span class="number">275</span> NotificationTest[<span class="number">2395</span>:<span class="number">155782</span>] 王五接收到了腾讯新闻发出的通知,通知内容是:&#123;</span><br><span class="line">    intro = <span class="string">"伊拉克战争停止了.........."</span><span class="comment">;</span></span><br><span class="line">    title = <span class="string">"伊拉克战争停止了"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2017</span>-01-27 <span class="number">15</span>:<span class="number">43</span>:<span class="number">29</span>.<span class="number">276</span> NotificationTest[<span class="number">2395</span>:<span class="number">155782</span>] 张三接收到了新浪新闻发出的通知,通知内容是:&#123;</span><br><span class="line">    intro = <span class="string">"川普出柜迎娶安倍.........."</span><span class="comment">;</span></span><br><span class="line">    title = <span class="string">"川普出柜迎娶安倍"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2017</span>-01-27 <span class="number">15</span>:<span class="number">43</span>:<span class="number">29</span>.<span class="number">277</span> NotificationTest[<span class="number">2395</span>:<span class="number">155782</span>] 王五接收到了新浪新闻发出的通知,通知内容是:&#123;</span><br><span class="line">    intro = <span class="string">"川普出柜迎娶安倍.........."</span><span class="comment">;</span></span><br><span class="line">    title = <span class="string">"川普出柜迎娶安倍"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六、<strong>取消注册通知监听器</strong></p><p>通知中心不会保留(retain)监听器对象，在通知中心注册过的对象，必须在该对象释放前取消注册。否则，当相应的通知再次出现时，通知中心仍然会向该监听器发送消息。因为相应的监听器对象已经被释放了，所以可能会导致应用崩溃。<strong>在上面我们的小demo中就没有取消注册监听器</strong>。</p><p>通知中心提供了相应的方法来取消注册监听器：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>removeObserver:<span class="params">(id)</span>observer;</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>removeObserver:<span class="params">(id)</span>observer name:<span class="params">(NSString *)</span>aName object:<span class="params">(id)</span>anObject;</span><br></pre></td></tr></table></figure><p>一般在监听器销毁之前取消注册（如在监听器中加入下列代码）：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">dealloc</span> &#123;</span><br><span class="line"><span class="comment">//[super dealloc];  非ARC中需要调用此句</span></span><br><span class="line">    <span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>七、<strong>NSNotificationQueue</strong></p><p>上面说到 <strong>NSNotificationCenter是一个同步操作，也就是只有当响应的通知的代码执行完毕以后，发出通知的对象的代码才会继续往下执行。而NSNotificationQueue则与之相反，其通知是异步发送的</strong>。</p><p>NSNotificationQueue：通知队列，用来管理多个通知的调用。通知队列通常以先进先出（FIFO）顺序维护通。NSNotificationQueue就像一个缓冲池把一个个通知放进池子中，使用特定方式通过NSNotificationCenter发送到相应的监听者。</p><p>创建通知队列方法:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithNotificationCenter:(<span class="type">NSNotificationCenter</span> *)notificationCenter <span class="type">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p>往队列加入通知（发送通知）方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br></pre></td></tr></table></figure><p>移除队列中的通知方法:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>dequeueNotificationsMatching:<span class="params">(NSNotification *)</span>notification coalesceMask:<span class="params">(NSUInteger)</span>coalesceMask;</span><br></pre></td></tr></table></figure><p>发送方式：</p><p><em>NSPostingStyle</em>包括三种类型：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">NSPostingStyle</span>) &#123;</span><br><span class="line">    <span class="type">NSPostWhenIdle</span> = 1,</span><br><span class="line">    <span class="type">NSPostASAP</span> = 2,</span><br><span class="line">    <span class="type">NSPostNow</span> = 3  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>NSPostWhenIdle</em>：空闲发送通知，当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。<br><em>NSPostASAP</em>：尽快发送通知，当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。<br><em>NSPostNow</em> ：同步发送通知，如果不使用合并通知 和postNotification:一样是同步通知。</p><p>合并通知：</p><p><em>NSNotificationCoalescing</em>也包括三种类型：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">NSNotificationCoalescing</span>) &#123;</span><br><span class="line">    <span class="type">NSNotificationNoCoalescing</span> = 0,</span><br><span class="line">    <span class="type">NSNotificationCoalescingOnName</span> = 1,</span><br><span class="line">    <span class="type">NSNotificationCoalescingOnSender</span> = 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>NSNotificationNoCoalescing</em>：不合并通知。<br><em>NSNotificationCoalescingOnName</em>：合并相同名称的通知。<br><em>NSNotificationCoalescingOnSender</em>：合并相同通知和同一对象的通知。</p><ul><li>通过合并我们可以用来保证相同的通知只被发送一次。</li></ul><ul><li><code>forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes</code>可以使用不同的<code>NSRunLoopMode</code>配合来发送通知，可以看出实际上<code>NSNotificationQueue</code>与<code>RunLoop</code>的机制以及运行循环有关系，通过<code>NSNotificationQueue</code>队列来发送的通知和关联的<code>RunLoop</code>运行机制来进行的。</li></ul><p>八、<strong>NSNotificatinonCenter实现原理</strong></p><ul><li><code>NSNotificatinonCenter</code>是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。</li></ul><ul><li><code>NSNotificatinonCenter</code>用来管理通知，将观察者注册到<code>NSNotificatinonCenter</code>的通知调度表中，然后发送通知时利用标识符<code>name</code>和<code>object</code>识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有name或者selector，可以接受参数，而且可能有返回值），如果是基于<code>block</code>创建的通知就调用<code>NSNotification</code>的<code>block</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 通知 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中图片自适应拉伸</title>
      <link href="/article/504/"/>
      <url>/article/504/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>图片拉伸在移动开发中特别常见，比如常用的即时通讯应用中的聊天气泡就需要根据文字长度对背景图片进行拉伸自适应。在Android中实现图片的拉伸特别特别简单，甚至不用写一行代码，直接使用.9图片进行划线即可。但是iOS就没这么简单了，比如对于下面的一张图片（原始尺寸：200*103）：</p><p><img src="/images/2017/01/chat_bg.png" alt="chat_bg"></p><p>我们不做任何处理，直接将它用作按钮的背景图片：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  ChatBgTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/23.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> addBtn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)addBtn&#123;</span><br><span class="line">    <span class="comment">// 创建一个按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    <span class="comment">// 设置按钮的frame</span></span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">103</span>);</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"chat_bg"</span>];</span><br><span class="line">    <span class="comment">// 设置按钮的背景图片</span></span><br><span class="line">    [btn setBackgroundImage:image forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 将按钮添加到控制器的view</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/images/2017/01/Snip20170123_1.png" alt="Snip20170123_1"></p><p>可以看到图片被明显拉伸，显示效果较差。今天我们研究内容就是图片自适应拉伸。</p><p>二、<strong>图片自适应拉伸</strong></p><p>1、iOS5之前</p><p>iOS中有个叫端盖(end cap)的概念，用来指定图片中的哪一部分不用拉伸，如下图：设置topCapHeight、leftCapWidth、bottomCapHeight、lerightCapWidth,图中的黑色区域就是图片拉伸的范围，也就是说边上的不会被拉伸。</p><p><img src="/images/2017/01/26210816-542ef6dfac654ae699c339fe0e4bb155.png" alt="26210816-542ef6dfac654ae699c339fe0e4bb155"></p><p>使用UIImage的下面这个方法，可以通过设置端盖宽度返回一个经过拉伸处理的UIImage对象：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(UIImage *)</span>stretchableImageWithLeftCapWidth:<span class="params">(NSInteger)</span>leftCapWidth topCapHeight:<span class="params">(NSInteger)</span>topCapHeight;</span><br></pre></td></tr></table></figure><p>这个方法只有2个参数，leftCapWidth代表左端盖宽度，topCapHeight代表上端盖高度。系统会自动计算出右端盖宽度rightCapWidth和底端盖高度bottomCapHeight，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第一种拉伸方式（iOS5之前）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)stretchTest1&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    <span class="comment">// 设置按钮的frame</span></span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">103</span>);</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"chat_bg"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置左边端盖宽度</span></span><br><span class="line">    <span class="built_in">NSInteger</span> leftCapWidth = image.size.width * <span class="number">0.5</span>f;</span><br><span class="line">    <span class="comment">// 设置上边端盖高度</span></span><br><span class="line">    <span class="built_in">NSInteger</span> topCapHeight = image.size.height * <span class="number">0.5</span>f;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = [image stretchableImageWithLeftCapWidth:leftCapWidth topCapHeight:topCapHeight];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置按钮的背景图片</span></span><br><span class="line">    [btn setBackgroundImage:newImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 将按钮添加到控制器的view</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，其实我们图片的可拉伸范围只有<code>1 * 1</code>，所以再怎么拉伸都不会影响图片的外观，运行效果如下：</p><p><img src="/images/2017/01/Snip20170123_2.png" alt="Snip20170123_2"></p><p>现在再看一下效果是不是好多了。</p><p>2、iOS5</p><p>在iOS 5.0中，UIImage又有一个新方法可以处理图片的拉伸问题：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(UIImage *)</span>resizableImageWithCapInsets:<span class="params">(UIEdgeInsets)</span>capInsets</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">UIEdgeInsets</span> &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> top, left, bottom, right;  </span><br><span class="line">    <span class="comment">// specify amount to inset (positive) for each of the edges. values can be negative to 'outset'</span></span><br><span class="line">&#125; <span class="built_in">UIEdgeInsets</span>;</span><br></pre></td></tr></table></figure><p>这个方法只接收一个UIEdgeInsets类型的参数，可以通过设置UIEdgeInsets中的CGFloat top, left, bottom, right就是用来设置上端盖、左端盖、下端盖、右端盖的尺寸(逆时针方向)。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第二种拉伸方式（iOS5）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)stretchTest2&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    <span class="comment">// 设置按钮的frame</span></span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">103</span>);</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"chat_bg"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端盖的值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> top = image.size.height * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> left = image.size.width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> bottom = image.size.height * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> right = image.size.width * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> edgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(top, left, bottom, right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉伸图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = [image resizableImageWithCapInsets:edgeInsets];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置按钮的背景图片</span></span><br><span class="line">    [btn setBackgroundImage:newImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 将按钮添加到控制器的view</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果与第一种一样，就不再截图了。</p><p>3、iOS6</p><p>在iOS6.0中，UIImage又提供了一个方法处理图片拉伸：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(UIImage *)</span>resizableImageWithCapInsets:<span class="params">(UIEdgeInsets)</span>capInsets resizingMode:<span class="params">(UIImageResizingMode)</span>resizingMode</span><br></pre></td></tr></table></figure><p>相比iOS5中的方法多了一个resizingMode参数：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIImageResizingMode</span>) &#123;</span><br><span class="line">    <span class="type">UIImageResizingModeTile</span>, // 平铺模式，通过重复显示<span class="type">UIEdgeInsets</span>指定的矩形区域来填充图片</span><br><span class="line">    <span class="type">UIImageResizingModeStretch</span>, // 拉伸模式，通过拉伸<span class="type">UIEdgeInsets</span>指定的矩形区域来填充图片</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体实现代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第三种拉伸方式（iOS6）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)stretchTest3&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    <span class="comment">// 设置按钮的frame</span></span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">103</span>);</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"chat_bg"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端盖的值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> top = image.size.height * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> left = image.size.width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> bottom = image.size.height * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> right = image.size.width * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端盖的值</span></span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> edgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(top, left, bottom, right);</span><br><span class="line">    <span class="comment">// 设置拉伸的模式</span></span><br><span class="line">    <span class="built_in">UIImageResizingMode</span> mode = <span class="built_in">UIImageResizingModeStretch</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉伸图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = [image resizableImageWithCapInsets:edgeInsets resizingMode:mode];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置按钮的背景图片</span></span><br><span class="line">    [btn setBackgroundImage:newImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 将按钮添加到控制器的view</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果与第一种一样，就不再截图了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS UITableView性能优化</title>
      <link href="/article/501/"/>
      <url>/article/501/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>iOS开发中，UITableView可能是平时我们打交道最多的UI控件之一，其重要性不言而喻。Android也是如此，Android中的ListView和UITableView是相同功能的一个控件，但是iOS的UITableView更为强大一点，原因就不说了，如果你学过Android就知道iOS中的UITableView使用起来是非常简单的，这也是峰哥喜欢iOS胜过Android的原因之一。今天研究的内容就是UITableView的优化。</p><p>开始之前，你能说出几种UITableView的可优化项？cell复用（Android中经常称为ListView的重用，其实重用复用都是一个意思，由于峰哥之前做过Android的原因，有时候我经常说“重用”，后面万一说“重用”大家知道是“复用”的意思就行了）！除了cell重用呢？</p><p>二、<strong>UITableView的性能优化</strong></p><p>1、cell复用</p><p>复用很简单，这或许是所有iOS开发者最为熟知的一个优化内容，如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *Identifier = <span class="string">@"cell"</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:ID];</span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:ID];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样重用就完美了吗？</p><p>我们经常在注意cellForRowAtIndexPath：中为每一个cell绑定数据，实际上在调用cellForRowAtIndexPath：的时候cell还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在cell显示出来后再执行，可以在tableView：willDisplayCell：forRowAtIndexPath：（以后简称willDisplayCell）方法中绑定数据。</p><p>注意willDisplayCell在cell 在tableview展示之前就会调用，此时cell实例已经生成，所以不能更改cell的结构，只能是改动cell上的UI的一些属性（例如label的内容等）。</p><p>2、cell高度的计算</p><p>这边我们分为两种cell，一种是定高的cell，另外一种是动态高度的cell。</p><p>（1）定高的cell，应该采用如下方式：</p><p>self.tableView.rowHeight = 88;</p><p>这个方法指定了所有cell高度都是88的tableview，rowHeight默认的值是44，所以一个空的TableView会显示成这个样子。对于定高cell，直接采用上面方式给定高度，不需要实现tableView:heightForRowAtIndexPath:以节省不必要的计算和开销。</p><p>（2）动态高度的cell</p><p>我们需要实现它的代理，来给出高度：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (CGFloat)<span class="selector-tag">tableView</span><span class="selector-pseudo">:(UITableView</span> *)<span class="selector-tag">tableView</span> <span class="selector-tag">heightForRowAtIndexPath</span><span class="selector-pseudo">:(NSIndexPath</span> *)<span class="selector-tag">indexPath</span> &#123;</span><br><span class="line">    <span class="comment">// return xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理方法实现后，上面的rowHeight的设置将会变成无效。在这个方法中，我们需要提高cell高度的计算效率，来节省时间。</p><p>自从iOS8之后有了self-sizing cell的概念，cell可以自己算出高度，使用self-sizing cell需要满足以下三个条件：</p><p>（1）使用Autolayout进行UI布局约束（要求cell.contentView的四条边都与内部元素有约束关系）。</p><p>（2）指定TableView的estimatedRowHeight属性的默认值。</p><p>（3）指定TableView的rowHeight属性为UITableViewAutomaticDimension。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidload &#123;</span><br><span class="line">    <span class="keyword">self</span>.myTableView.estimatedRowHeight = <span class="number">44.0</span>;</span><br><span class="line">    <span class="keyword">self</span>.myTableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了提高cell高度的计算效率之外，对于已经计算出的高度，我们需要进行缓存，对于已经计算过的高度，没有必要进行计算第二次。</p><p>3、渲染</p><p>为了保证TableView的流畅，当快速滑动的时候，cell必须被快速的渲染出来。所以cell渲染的速度必须快。如何提高cell的渲染速度呢？</p><p>（1）当有图像时，预渲染图像，在bitmap context先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示iOS图像”相关资料。</p><p>（2）渲染最好时的操作之一就是混合(blending)了,所以我们不要使用透明背景，将cell的opaque值设为Yes，背景色不要使用clearColor，尽量不要使用阴影渐变等</p><p>（3）由于混合操作是使用GPU来执行，我们可以用CPU来渲染，这样混合操作就不再执行。可以在UIView的drawRect方法中自定义绘制。</p><p>4、减少视图的数目</p><p>我们在cell上添加系统控件的时候，实际上系统都会调用底层的接口进行绘制，大量添加控件时，会消耗很大的资源并且也会影响渲染的性能。当使用默认的UITableViewCell并且在它的ContentView上面添加控件时会相当消耗性能。所以目前最佳的方法还是继承UITableViewCell，并重写drawRect方法。</p><p>5、减少多余的绘制操作</p><p>在实现drawRect方法的时候，它的参数rect就是我们需要绘制的区域，在rect范围之外的区域我们不需要进行绘制，否则会消耗相当大的资源。</p><p>6、不要给cell动态添加subView</p><p>在初始化cell的时候就将所有需要展示的添加完毕，然后根据需要来设置hide属性显示和隐藏。</p><p>7、异步化UI，不要阻塞主线程</p><p>我们时常会看到这样一个现象，就是加载时整个页面卡住不动，怎么点都没用，仿佛死机了一般。原因是主线程被阻塞了。所以对于网路数据的请求或者图片的加载，我们可以开启多线程，将耗时操作放到子线程中进行，异步化操作。这个或许每个iOS开发者都知道的知识，不必多讲。</p><p>8、滑动时按需加载对应的内容</p><p>如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">33</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在tableView:cellForRowAtIndexPath:方法中加入判断：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needLoadArr.<span class="keyword">count</span>&gt;0&amp;&amp;[needLoadArr indexOfObject:indexPath]==NSNotFound) &#123;</span><br><span class="line">    [cell <span class="keyword">clear</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动很快时，只加载目标范围内的cell，这样按需加载（配合SDWebImage），极大提高流畅度。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS KVO详解</title>
      <link href="/article/498/"/>
      <url>/article/498/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>KVO是基于观察者设计模式来实现的。<br>观察者模式：一个目标对象管理所有依赖于它的观察者对象，并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。</p><p>KVO：Key-Value Observing，是Foundation框架提供的一种机制，使用KVO，可以方便地对指定对象的某个属性进行观察，当属性发生变化时，进行通知。</p><p>使用KVO只需要两个步骤：</p><p>（1）注册Observer；</p><p>（2）接收通知。</p><p>二、<strong>KVO注册与接收通知</strong></p><p>1、注册Observer</p><p>使用下面方法注册Observer：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">addObserver:</span><span class="string">forKeyPath:</span><span class="string">options:</span><span class="string">context:</span></span><br></pre></td></tr></table></figure><p>其中三个参数的含义如下：</p><ul><li><em>observer</em>：观察者，需要响应属性变化的对象。该对象必须实现 _observeValueForKeyPath:ofObject:change:context: _方法。</li></ul><ul><li><em>keyPath</em>：要观察的属性名称。要和属性声明的名称一致。</li></ul><ul><li><em>options</em>：对KVO机制进行配置，修改KVO通知的时机以及通知的内容，在后面详解。</li></ul><ul><li><em>context</em>：接收一个C指针，指向希望监听的属性。如：&amp;self-&gt;_testData<br>需要注意的是，注册Observer之后一定要在合适的机会解除注册，否则会引发资源泄露，取消注册的方法：</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">removeObserver:forKeyPath:context:</span></span><br></pre></td></tr></table></figure><p>参数含义同注册时方法的参数含义。</p><p>options参数：</p><p>enum类型，在注册时传入，共有四种取值方式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">NSKeyValueObservingOptionNew = <span class="number">0x01</span>,</span><br><span class="line">NSKeyValueObservingOptionOld = <span class="number">0x02</span>,</span><br><span class="line">NSKeyValueObservingOptionInitial = <span class="number">0x04</span>,</span><br><span class="line">NSKeyValueObservingOptionPrior = <span class="number">0x08</span></span><br><span class="line">&#125;;</span><br><span class="line">typedef NSUInteger NSKeyValueObservingOptions;</span><br></pre></td></tr></table></figure><p>四个值的含义如下：</p><ul><li><em>NSKeyValueObservingOptionNew</em>：接收方法中使用change参数传入变化后的新值，键为：NSKeyValueChangeNewKey；</li></ul><ul><li><em>NSKeyValueObservingOptionOld</em>：接收方法中使用change参数传入变化前的旧值，键为：NSKeyValueChangeOldKey；</li></ul><ul><li><em>NSKeyValueObservingOptionInitial</em>：注册之后立刻调用接收方法，如果配置了NSKeyValueObservingOptionNew，change参数内容会包含新值，键为：NSKeyValueChangeNewKey；</li></ul><ul><li><em>NSKeyValueObservingOptionPrior</em>：如果加入这个参数，接收方法会在变化前后分别调用一次，共两次，变化前的通知change参数包含notificationIsPrior = 1。其他内容根据NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld的配置确定。</li></ul><p>2、接收通知</p><p>当属性的值发生变化时，框架默认会自动通知注册的观察者。</p><p>上文提到，观察者需要实现方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary *)change <span class="string">context:</span>(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure><p>这个方法就是接收通知的方法。参数含义如下：</p><ul><li><em>object</em>：这个是所监听的对象，也就是所监听的属性所属的对象。</li></ul><ul><li><em>change</em>：是传入的变化量，通过在注册时用options参数进行的配置，会包含不同的内容。</li></ul><ul><li>其他参数含义同注册时方法的参数含义。<br>在实现这个方法中需要注意的是， 一定要对注册监听的所有属性都进行处理——使用context参数进行判断——否则Xcode会警告。</li></ul><p>change参数</p><p>除了根据options参数控制的change参数内容，默认change参数会包含一个NSKeyValueChangeKindKey键值对，传递被监听属性的变化类型：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">NSKeyValueChangeSetting = <span class="number">1</span>,</span><br><span class="line">NSKeyValueChangeInsertion = <span class="number">2</span>,</span><br><span class="line">NSKeyValueChangeRemoval = <span class="number">3</span>,</span><br><span class="line">NSKeyValueChangeReplacement = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line">typedef NSUInteger NSKeyValueChange;</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li><em>NSKeyValueChangeSetting</em>：属性的值被重新设置；</li></ul><ul><li><em>NSKeyValueChangeInsertion</em>、NSKeyValueChangeRemoval、NSKeyValueChangeReplacement：表示更改的是集合属性，分别代表插入、删除、替换操作。<br>如果NSKeyValueChangeKindKey参数是针对集合属性的三个之一，change参数还会包含一个NSKeyValueChangeIndexesKey键值对，表示变化的index。</li></ul><p>例如，我们使用KVO实现监听Book的price改变：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Book.h</span></span><br><span class="line"><span class="comment">//  KVOTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSString</span> *price;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  KVOTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)Book *abook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addObserver];</span><br><span class="line">    [<span class="keyword">self</span> addBtn];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)addObserver&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加监听</span></span><br><span class="line">    <span class="keyword">self</span>.abook = [[Book alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.abook.price = <span class="string">@"0"</span>;<span class="comment">//先设一个初始值</span></span><br><span class="line">    [_abook addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"price"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span>|<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 添加一个按钮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)addBtn&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIButton</span> *abtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    abtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">80</span>, <span class="number">90.0</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">    [abtn setTitleColor:[<span class="built_in">UIColor</span> blueColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [abtn setTitle:<span class="string">@"Change"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [abtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:abtn];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 按钮点击事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)btnClick&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击了Btn!"</span>);</span><br><span class="line">    <span class="built_in">NSInteger</span> randomPrice = arc4random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *newPrice = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>,(<span class="keyword">long</span>)randomPrice];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两种方法触发监听</span></span><br><span class="line">    <span class="comment">//第一种方法</span></span><br><span class="line"><span class="comment">//    NSDictionary *newBookPropertiesDictionary=[NSDictionary dictionaryWithObjectsAndKeys:</span></span><br><span class="line"><span class="comment">//                                               @"book name",@"name",</span></span><br><span class="line"><span class="comment">//                                               newPrice,@"price",nil];</span></span><br><span class="line"><span class="comment">//    [self.abook setValuesForKeysWithDictionary:newBookPropertiesDictionary];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二种方法</span></span><br><span class="line">    [<span class="keyword">self</span>.abook setValue:newPrice forKey:<span class="string">@"price"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现监听</span></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqual:<span class="string">@"price"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"old price: %@"</span>,[change objectForKey:<span class="string">@"old"</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"new price: %@"</span>,[change objectForKey:<span class="string">@"new"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//移除监听</span></span><br><span class="line">    [_abook removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"price"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-01-17</span> 16<span class="selector-pseudo">:16</span><span class="selector-pseudo">:03.633</span> <span class="selector-tag">KVOTest</span><span class="selector-attr">[40935:3327447]</span> 点击了<span class="selector-tag">Btn</span>!</span><br><span class="line">2017<span class="selector-tag">-01-17</span> 16<span class="selector-pseudo">:16</span><span class="selector-pseudo">:03.634</span> <span class="selector-tag">KVOTest</span><span class="selector-attr">[40935:3327447]</span> <span class="selector-tag">old</span> <span class="selector-tag">price</span>: 0</span><br><span class="line">2017<span class="selector-tag">-01-17</span> 16<span class="selector-pseudo">:16</span><span class="selector-pseudo">:03.634</span> <span class="selector-tag">KVOTest</span><span class="selector-attr">[40935:3327447]</span> <span class="selector-tag">new</span> <span class="selector-tag">price</span>: 87</span><br><span class="line">2017<span class="selector-tag">-01-17</span> 16<span class="selector-pseudo">:16</span><span class="selector-pseudo">:04.944</span> <span class="selector-tag">KVOTest</span><span class="selector-attr">[40935:3327447]</span> 点击了<span class="selector-tag">Btn</span>!</span><br><span class="line">2017<span class="selector-tag">-01-17</span> 16<span class="selector-pseudo">:16</span><span class="selector-pseudo">:04.945</span> <span class="selector-tag">KVOTest</span><span class="selector-attr">[40935:3327447]</span> <span class="selector-tag">old</span> <span class="selector-tag">price</span>: 87</span><br><span class="line">2017<span class="selector-tag">-01-17</span> 16<span class="selector-pseudo">:16</span><span class="selector-pseudo">:04.945</span> <span class="selector-tag">KVOTest</span><span class="selector-attr">[40935:3327447]</span> <span class="selector-tag">new</span> <span class="selector-tag">price</span>: 49</span><br></pre></td></tr></table></figure><p>代码很简单，不再做过多解释。</p><p>3、自动通知和手动通知</p><p>上面提到，KVO默认会自动通知观察者。取消自动通知的方法是实现：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">BOOL</span>) automaticallyNotifiesObserversForKey:(NSString *)<span class="built_in">key</span></span><br></pre></td></tr></table></figure><p>方法，通过返回NO来控制取消自动通知。</p><p>针对非自动通知的属性，可以分别在变化之前和之后手动调用如下方法（will在前，did在后）来手动通知观察者：</p><ul><li>(will/did)ChangeValueForKey:</li></ul><ul><li>(will/did)ChangeValueForKey:withSetMutation:usingObjects:</li></ul><ul><li>(will/did)Change:valuesAtIndexes:forKey:</li></ul><p>手动通知的好处就是，可以灵活加上自己想要的判断条件，事实上自动通知也是框架通过调用这些方法实现的。</p><p>例如：</p><p>被观察的对象Target（重写setter/getter方法）：</p><p>Target.h：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="string">Target :</span> NSObject</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for manual KVO </span></span><br><span class="line">- age- (<span class="keyword">int</span>) age;</span><br><span class="line">- (<span class="keyword">void</span>) <span class="string">setAge:</span>(<span class="keyword">int</span>)theAge;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p>Target.m：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Target</span></span></span><br><span class="line">- (<span class="keyword">id</span>) init&#123; </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != <span class="keyword">self</span>) &#123; </span><br><span class="line">          age = <span class="number">10</span>; </span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for manual KVO - age</span></span><br><span class="line">- (<span class="keyword">int</span>) age&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) setAge:(<span class="keyword">int</span>)theAge&#123; </span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">    age = theAge; </span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">BOOL</span>) automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123; </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"age"</span>]) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key]**;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>三、<strong>KVO实现原理</strong></p><p>KVO的实现是基于runtime运行时的，下面就来详细介绍一下原理，如下图：</p><p><img src="/images/2017/01/Snip20170117_1.png" alt="Snip20170117_1"></p><ol><li>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</li></ol><ol start="2"><li>派生类在被重写的 setter 方法中实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</li></ol><ol start="3"><li>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</li></ol><p>四、<strong>KVO 和线程</strong></p><p>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 Run-loop 的处理。手动或者自动调用 <code>-didChange...</code> 会触发 KVO 通知。</p><p>所以，当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知。通常来说，我们不推荐把 KVO 和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p><p>KVO 是同步运行的这个特性非常强大，只要我们在单一线程上面运行（比如主队列 main queue），KVO 会保证下列两种情况的发生：</p><p>首先，如果我们调用一个支持 KVO 的 setter 方法，如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.exchangeRate = <span class="number">2.345</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>KVO 能保证所有 <code>exchangeRate</code> 的观察者在 setter 方法返回前被通知到。</p><p>其次，如果某个键被观察的时候附上了 <code>NSKeyValueObservingOptionPrior</code> 选项，直到 <code>-observe...</code> 被调用之前， <code>exchangeRate</code> 的 accessor 方法都会返回同样的值。</p><p>五、<strong>常见的 KVO 错误</strong></p><p>首先，KVO 兼容是 API 的一部分。如果类的所有者不保证某个属性兼容 KVO，我们就不能保证 KVO 正常工作。苹果文档里有 KVO 兼容属性的文档。例如，<code>NSProgress</code> 类的大多数属性都是兼容 KVO 的。</p><p>当做出改变_以后_，有些人试着放空的 <code>-willChange</code> 和 <code>-didChange</code> 方法来强制 KVO 的触发。KVO 通知虽然会生效，但是这样做破坏了有依赖于 <code>NSKeyValueObservingOld</code> 选项的观察者。详细来说，这影响了 KVO 对观察键路径 (key path) 的原生支持。KVO 在观察键路径 (key path) 时依赖于 <code>NSKeyValueObservingOld</code> 属性。</p><p>我们也要指出有些集合是不能被观察的。KVO 旨在观察<em>关系 (relationship)</em> 而不是集合。我们不能观察 <code>NSArray</code>，我们只能观察一个对象的属性——而这个属性有可能是 <code>NSArray</code>。举例说，如果我们有一个 <code>ContactList</code> 对象，我们可以观察它的 <code>contacts</code> 属性。但是我们不能向要观察对象的 <code>-addObserver:forKeyPath:...</code> 传入一个 <code>NSArray</code>。</p><p>相似地，观察 <code>self</code> 不是永远都生效的。而且这不是一个好的设计。</p><p>六、<strong>调试 KVO</strong></p><p>你可以在 <code>lldb</code> 里查看一个被观察对象的所有观察信息。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po <span class="string">[observedObject observationInfo]</span></span><br></pre></td></tr></table></figure><p>这会打印出有关谁观察谁之类的很多信息。</p><p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> KVO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS KVC详解</title>
      <link href="/article/493/"/>
      <url>/article/493/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>KVC（Key-value coding）键值编码，iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态在访问和修改对象的属性，而不是在编译时确定。</p><p>在实现了访问器方法的类中，使用点语法和KVC访问对象其实差别不大，二者可以任意混用。但是没有访问起方法的类中，点语法无法使用，这时KVC就有优势了。</p><p>二、<strong>KVC的定义与使用</strong></p><p>1、KVC相关的方法</p><p>KVC的定义都是对NSObject的扩展来实现的，Objective-c中有个显式的NSKeyValueCoding类别名，所以对于所有继承了NSObject在类型，都能使用KVC，下面是KVC最为重要的四个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;                          <span class="comment">//直接通过Key来取值</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;          <span class="comment">//通过Key来设值</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;                  <span class="comment">//通过KeyPath来取值</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;  <span class="comment">//通过KeyPath来设值</span></span><br></pre></td></tr></table></figure><p>当然NSKeyValueCoding类别中还有其他的一些方法，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly;</span><br><span class="line"><span class="comment">//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> __<span class="keyword">nullable</span> * __<span class="keyword">nonnull</span>)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="comment">//KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//和上一个方法一样，只不过是设值。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"><span class="comment">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span></span><br></pre></td></tr></table></figure><p>同时苹果对一些容器类比如NSArray或者NSSet等，KVC有着特殊的实现。</p><p>有序集合对应方法如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-countOf<span class="symbol">&lt;Key&gt;</span>//必须实现，对应于NSArray的基本方法coun<span class="variable">t:2</span>  -objectIn<span class="symbol">&lt;Key&gt;</span>AtIndex:</span><br><span class="line"></span><br><span class="line">-<span class="symbol">&lt;key&gt;</span>AtIndexe<span class="variable">s:</span>//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexe<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">-<span class="built_in">get</span><span class="symbol">&lt;Key&gt;</span>:<span class="built_in">range</span>://不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObject<span class="variable">s:range</span>:</span><br><span class="line"></span><br><span class="line">-insertObjec<span class="variable">t:in</span><span class="symbol">&lt;Key&gt;</span>AtIndex:</span><br><span class="line"></span><br><span class="line">-<span class="keyword">insert</span><span class="symbol">&lt;Key&gt;</span>:atIndexe<span class="variable">s:</span>//两个必须实现一个，类似于 NSMutableArray 的方法 insertObjec<span class="variable">t:atIndex</span>: 和 insertObject<span class="variable">s:atIndexes</span>:</span><br><span class="line"></span><br><span class="line">-removeObjectFrom<span class="symbol">&lt;Key&gt;</span>AtIndex:</span><br><span class="line"></span><br><span class="line">-<span class="built_in">remove</span><span class="symbol">&lt;Key&gt;</span>AtIndexe<span class="variable">s:</span>//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexe<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">-replaceObjectIn<span class="symbol">&lt;Key&gt;</span>AtIndex:withObjec<span class="variable">t:</span></span><br><span class="line"></span><br><span class="line">-replace<span class="symbol">&lt;Key&gt;</span>AtIndexe<span class="variable">s:with</span><span class="symbol">&lt;Key&gt;</span>://可选的，如果在此类操作上有性能问题，就需要考虑实现之</span><br></pre></td></tr></table></figure><p>无序集合对应方法如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-countOf<span class="symbol">&lt;Key&gt;</span>//必须实现，对应于NSArray的基本方法coun<span class="variable">t:</span></span><br><span class="line"></span><br><span class="line">-objectIn<span class="symbol">&lt;Key&gt;</span>AtIndex:</span><br><span class="line"></span><br><span class="line">-<span class="symbol">&lt;key&gt;</span>AtIndexe<span class="variable">s:</span>//这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexe<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">-<span class="built_in">get</span><span class="symbol">&lt;Key&gt;</span>:<span class="built_in">range</span>://不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObject<span class="variable">s:range</span>:</span><br><span class="line"></span><br><span class="line">-insertObjec<span class="variable">t:in</span><span class="symbol">&lt;Key&gt;</span>AtIndex:</span><br><span class="line"></span><br><span class="line">-<span class="keyword">insert</span><span class="symbol">&lt;Key&gt;</span>:atIndexe<span class="variable">s:</span>//两个必须实现一个，类似于 NSMutableArray 的方法 insertObjec<span class="variable">t:atIndex</span>: 和 insertObject<span class="variable">s:atIndexes</span>:</span><br><span class="line"></span><br><span class="line">-removeObjectFrom<span class="symbol">&lt;Key&gt;</span>AtIndex:</span><br><span class="line"></span><br><span class="line">-<span class="built_in">remove</span><span class="symbol">&lt;Key&gt;</span>AtIndexe<span class="variable">s:</span>//两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexe<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">-replaceObjectIn<span class="symbol">&lt;Key&gt;</span>AtIndex:withObjec<span class="variable">t:</span></span><br><span class="line"></span><br><span class="line">-replace<span class="symbol">&lt;Key&gt;</span>AtIndexe<span class="variable">s:with</span><span class="symbol">&lt;Key&gt;</span>://这两个都是可选的，如果在此类操作上有性能问题，就需要考虑实现之</span><br></pre></td></tr></table></figure><p>2、一对多关系（To-Many）中的集合访问器方法</p><p>我们平时大部分使用的属性都是一对一关系（To-One）,比如Person类中的name属性，每个人只有一个名字。但也有一对多的关系，比如Person中有一个friendsName属性，这是个集合（在Objective-C中可以是NSArray，NSSet等），保存的是一个人的所有朋友的名字。</p><p>当操作一对多的属性中的内容时，我们有两种选择：</p><p>（1）间接操作<br>先通过KVC方法取到集合属性，然后通过集合属性操作集合中的元素。实际开发中最常用的方法。</p><p>（2）直接操作<br>苹果为我们提供了一些方法模板（即上面提到的有序集合和无序集合对应的方法），我们可以以规定的格式实现这些方法来达到访问集合属性中元素的目的。不过在实际开发中一般不使用直接操作的方法，使用间接操作就足够了，苹果甚至都没有让这些方法以哪怕是非正式协议的形式出现，而只是在编程指南中提了一下。</p><p>3、KVC对数值和结构体型属性的支持</p><p>KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。</p><p>举个例子，Person类有个NSInteger类型的age属性，如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Person.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>（1）修改值</p><p>我们通过KVC技术使用如下方式设置age属性的值：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">person</span> setValue:[<span class="name">NSNumber</span> numberWithInteger:5] forKey:@<span class="string">"age"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>我们赋给age的是一个<code>NSNumber</code>对象，KVC会自动的将<code>NSNumber</code>对象转换成<code>NSInteger</code>对象，然后再调用相应的访问器方法设置age的值。</p><p>（2）获取值</p><p>同样，以如下方式获取age属性值：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">person</span> valueForKey:@<span class="string">"age"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这时，会以NSNumber的形式返回age的值。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *person = [[Person alloc]init];</span><br><span class="line">    [person setValue:[<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">5</span>] forKey:<span class="string">@"age"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age=%@"</span>,[person valueForKey:<span class="string">@"age"</span>]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-01-16</span> <span class="number">16</span>:<span class="number">31:55.709</span> Test[<span class="number">28586:2294177</span>] age=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>需要注意的是我们不能直接将一个数值通过KVC赋值的，我们需要把数据转为NSNumber和NSValue类型传入，那到底哪些类型数据要用NSNumber封装哪些类型数据要用NSValue封装呢？看下面这些方法的参数类型就知道了：</p><p>可以使用NSNumber的数据类型有：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithChar:(<span class="keyword">char</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithUnsignedChar:(unsignedchar)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithShort:(<span class="keyword">short</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithUnsignedShort:(unsignedshort)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithInt:(<span class="keyword">int</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithUnsignedInt:(unsignedint)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithLong:(<span class="keyword">long</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithUnsignedLong:(unsignedlong)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithLongLong:(longlong)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithUnsignedLongLong:(unsignedlonglong)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithFloat:(<span class="keyword">float</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithDouble:(<span class="keyword">double</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithBool:(<span class="built_in">BOOL</span>)value;</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithInteger:(<span class="built_in">NSInteger</span>)valueNS_AVAILABLE(<span class="number">10</span>_5,<span class="number">2</span>_0);</span><br><span class="line">+ (<span class="built_in">NSNumber</span>*)numberWithUnsignedInteger:(<span class="built_in">NSUInteger</span>)valueNS_AVAILABLE(<span class="number">10</span>_5,<span class="number">2</span>_0);</span><br></pre></td></tr></table></figure><p>就是一些常见的数值型数据。</p><p>可以使用NSValue的数据类型有：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSValue</span>*)valueWithCGPoint:(<span class="built_in">CGPoint</span>)point;</span><br><span class="line">+ (<span class="built_in">NSValue</span>*)valueWithCGSize:(<span class="built_in">CGSize</span>)size;</span><br><span class="line">+ (<span class="built_in">NSValue</span>*)valueWithCGRect:(<span class="built_in">CGRect</span>)rect;</span><br><span class="line">+ (<span class="built_in">NSValue</span>*)valueWithCGAffineTransform:(<span class="built_in">CGAffineTransform</span>)transform;</span><br><span class="line">+ (<span class="built_in">NSValue</span>*)valueWithUIEdgeInsets:(<span class="built_in">UIEdgeInsets</span>)insets;</span><br><span class="line">+ (<span class="built_in">NSValue</span>*)valueWithUIOffset:(<span class="built_in">UIOffset</span>)insetsNS_AVAILABLE_IOS(<span class="number">5</span>_0);</span><br></pre></td></tr></table></figure><p><code>NSValue</code>主要用于处理结构体型的数据，它本身提供了如上集中结构的支持。任何结构体都是可以转化成NSValue对象的，包括其它自定义的结构体。</p><p>三、<strong>KVC中使用KeyPath</strong></p><p>在开发过程中，一个类的成员变量有可能是其他的自定义类，你可以先用KVC获取出来该属性，然后再次用KVC来获取这个自定义类的属性，但这样是比较繁琐的，对此，KVC提供了一个解决方案，那就是键路径KeyPath。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;                  <span class="comment">//通过KeyPath来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;  <span class="comment">//通过KeyPath来设值</span></span><br></pre></td></tr></table></figure><p>KVC 同样允许我们通过关系来访问对象。假设 <code>people</code> 对象有属性 <code>address</code>，<code>address</code> 有属性 <code>country</code>，我们可以这样通过people 来访问country：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">people valueForKeyPath:@<span class="meta-string">"address.country"</span></span>]；</span><br></pre></td></tr></table></figure><p>值得注意的是这里我们调用 <code>-valueForKeyPath:</code> 而不是 <code>-valueForKey:</code>。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  TEST_OC</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/16.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Address</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Address</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span>* country;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Address</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span>* name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Address* address;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        People* people1 = [People new];</span><br><span class="line">        Address* add = [Address new];</span><br><span class="line">        add.country = <span class="string">@"China"</span>;</span><br><span class="line">        people1.address = add;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span>* country1 = people1.address.country;</span><br><span class="line">        <span class="built_in">NSString</span> * country2 = [people1 valueForKeyPath:<span class="string">@"address.country"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"country1:%@   country2:%@"</span>,country1,country2);</span><br><span class="line">        </span><br><span class="line">        [people1 setValue:<span class="string">@"USA"</span> forKeyPath:<span class="string">@"address.country"</span>];</span><br><span class="line">        country1 = people1.address.country;</span><br><span class="line">        country2 = [people1 valueForKeyPath:<span class="string">@"address.country"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"country1:%@   country2:%@"</span>,country1,country2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">01</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">42.443432</span> TEST_OC[<span class="number">29905</span>:<span class="number">2372748</span>] country1:China   country2:China</span><br><span class="line"><span class="number">2017</span>-<span class="number">01</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">42.444862</span> TEST_OC[<span class="number">29905</span>:<span class="number">2372748</span>] country1:USA   country2:USA</span><br><span class="line">Program ended with <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>KVC键值验证（Key-Value Validation）</p><p>KVC提供了验证Key对应的Value是否可用的方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>validateValue:<span class="params">(inoutid*)</span>ioValue forKey:<span class="params">(NSString*)</span>inKey error:<span class="params">(outNSError**)</span>outError;</span><br></pre></td></tr></table></figure><p>该方法默认的实现是调用一个如下格式的方法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BOOL</span>)validate&lt;<span class="built_in">Key</span>&gt;:<span class="built_in">error</span>:</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Address</span></span></span><br><span class="line">-(<span class="built_in">BOOL</span>)validateCountry:(<span class="keyword">id</span> *)value error:(<span class="keyword">out</span> <span class="built_in">NSError</span> * _Nullable __autoreleasing *)outError&#123;  <span class="comment">//在implementation里面加这个方法，它会验证是否设了非法的value</span></span><br><span class="line">    <span class="built_in">NSString</span>* country = *value;</span><br><span class="line">    country = country.capitalizedString;</span><br><span class="line">    <span class="keyword">if</span> ([country isEqualToString:<span class="string">@"Japan"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;                                                                             <span class="comment">//如果国家是日本，就返回NO，这里省略了错误提示，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span>* error;</span><br><span class="line"><span class="keyword">id</span> value = <span class="string">@"japan"</span>;</span><br><span class="line"><span class="built_in">NSString</span>* key = <span class="string">@"country"</span>;</span><br><span class="line"><span class="built_in">BOOL</span> result = [add validateValue:&amp;value forKey:key error:&amp;error]; <span class="comment">//如果没有重写-(BOOL)-validate&lt;Key&gt;:error:，默认返回Yes</span></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"键值匹配"</span>);</span><br><span class="line">    [add setValue:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"键值不匹配"</span>); <span class="comment">//不能设为日本，基他国家都行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSString</span>* country = [add valueForKey:<span class="string">@"country"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"country:%@"</span>,country);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-01-16</span> 17<span class="selector-pseudo">:27</span><span class="selector-pseudo">:46.424332</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[29905:2372748]</span> 键值不匹配</span><br><span class="line">2017<span class="selector-tag">-01-16</span> 17<span class="selector-pseudo">:27</span><span class="selector-pseudo">:46.424332</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[29905:2372748]</span> <span class="selector-tag">country</span><span class="selector-pseudo">:China</span></span><br></pre></td></tr></table></figure><p>这样就给了我们一次纠错的机会。需要指出的是，KVC是不会自动调用键值验证方法的，就是说我们如果想要键值验证则需要手动验证。但是有些技术，比如CoreData会自动调用。</p><p>上面的代码简单在展示了KeyPath是怎么用的。如果你不小心错误的使用了key而非KeyPath的话，KVC会直接查找address.country这个属性，很明显，这个属性并不存在，所以会再调用UndefinedKey相关方法。而KVC对于KeyPath是搜索机制第一步就是分离key，用小数点.来分割key，然后再像普通key一样按照先前介绍的顺序搜索下去。接下来就来研究KVC是怎么寻找Key的。</p><p>四、<strong>用KVC中的函数操作集合</strong></p><p>KVC同时还提供了很复杂的函数，主要有下面这些：<br>1、简单集合运算符<br>简单集合运算符共有<code>@avg， @count ， @max ， @min ，@sum5</code>种，都表示什么直接看下面例子就明白了， 目前还不支持自定义。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  TEST_OC</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/16.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)  <span class="built_in">NSString</span>* name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)  <span class="built_in">CGFloat</span> price;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Book *book1 = [Book new];</span><br><span class="line">        book1.name = <span class="string">@"The Great Gastby"</span>;</span><br><span class="line">        book1.price = <span class="number">10</span>;</span><br><span class="line">        Book *book2 = [Book new];</span><br><span class="line">        book2.name = <span class="string">@"Time History"</span>;</span><br><span class="line">        book2.price = <span class="number">20</span>;</span><br><span class="line">        Book *book3 = [Book new];</span><br><span class="line">        book3.name = <span class="string">@"Wrong Hole"</span>;</span><br><span class="line">        book3.price = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        Book *book4 = [Book new];</span><br><span class="line">        book4.name = <span class="string">@"Wrong Hole"</span>;</span><br><span class="line">        book4.price = <span class="number">40</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSArray</span>* arrBooks = @[book1,book2,book3,book4];</span><br><span class="line">        <span class="built_in">NSNumber</span>* sum = [arrBooks valueForKeyPath:<span class="string">@"@sum.price"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"sum:%f"</span>,sum.floatValue);</span><br><span class="line">        <span class="built_in">NSNumber</span>* avg = [arrBooks valueForKeyPath:<span class="string">@"@avg.price"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"avg:%f"</span>,avg.floatValue);</span><br><span class="line">        <span class="built_in">NSNumber</span>* count = [arrBooks valueForKeyPath:<span class="string">@"@count"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"count:%f"</span>,count.floatValue);</span><br><span class="line">        <span class="built_in">NSNumber</span>* min = [arrBooks valueForKeyPath:<span class="string">@"@min.price"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"min:%f"</span>,min.floatValue);</span><br><span class="line">        <span class="built_in">NSNumber</span>* max = [arrBooks valueForKeyPath:<span class="string">@"@max.price"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"max:%f"</span>,max.floatValue);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:53</span><span class="selector-pseudo">:23.235907</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37115:3010741]</span> <span class="selector-tag">sum</span><span class="selector-pseudo">:100.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:53</span><span class="selector-pseudo">:23.236161</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37115:3010741]</span> <span class="selector-tag">avg</span><span class="selector-pseudo">:25.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:53</span><span class="selector-pseudo">:23.236227</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37115:3010741]</span> <span class="selector-tag">count</span><span class="selector-pseudo">:4.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:53</span><span class="selector-pseudo">:23.236280</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37115:3010741]</span> <span class="selector-tag">min</span><span class="selector-pseudo">:10.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:53</span><span class="selector-pseudo">:23.236322</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37115:3010741]</span> <span class="selector-tag">max</span><span class="selector-pseudo">:40.000000</span></span><br><span class="line"><span class="selector-tag">Program</span> <span class="selector-tag">ended</span> <span class="selector-tag">with</span> <span class="selector-tag">exit</span> <span class="selector-tag">code</span>: 0</span><br></pre></td></tr></table></figure><p>2、对象运算符<br>比集合运算符稍微复杂，能以数组的方式返回指定的内容，一共有两种：<br><code>@distinctUnionOfObjects</code><br><code>@unionOfObjects</code><br>它们的返回值都是NSArray，区别是前者返回的元素都是唯一的，是去重以后的结果；后者返回的元素是全集。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  TEST_OC</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/16.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)  <span class="built_in">NSString</span>* name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)  <span class="built_in">CGFloat</span> price;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Book *book1 = [Book new];</span><br><span class="line">        book1.name = <span class="string">@"The Great Gastby"</span>;</span><br><span class="line">        book1.price = <span class="number">40</span>;</span><br><span class="line">        Book *book2 = [Book new];</span><br><span class="line">        book2.name = <span class="string">@"Time History"</span>;</span><br><span class="line">        book2.price = <span class="number">20</span>;</span><br><span class="line">        Book *book3 = [Book new];</span><br><span class="line">        book3.name = <span class="string">@"Wrong Hole"</span>;</span><br><span class="line">        book3.price = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        Book *book4 = [Book new];</span><br><span class="line">        book4.name = <span class="string">@"Wrong Hole"</span>;</span><br><span class="line">        book4.price = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSArray</span>* arrBooks = @[book1,book2,book3,book4];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"distinctUnionOfObjects"</span>);</span><br><span class="line">        <span class="built_in">NSArray</span>* arrDistinct = [arrBooks valueForKeyPath:<span class="string">@"@distinctUnionOfObjects.price"</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *price <span class="keyword">in</span> arrDistinct) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,price.floatValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"unionOfObjects"</span>);</span><br><span class="line">        <span class="built_in">NSArray</span>* arrUnion = [arrBooks valueForKeyPath:<span class="string">@"@unionOfObjects.price"</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *price <span class="keyword">in</span> arrUnion) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,price.floatValue);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606011</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> <span class="selector-tag">distinctUnionOfObjects</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606506</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 10<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606564</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 20<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606583</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 30<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606621</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 40<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606654</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> <span class="selector-tag">unionOfObjects</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606694</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 40<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606704</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 20<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606712</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 30<span class="selector-class">.000000</span></span><br><span class="line">2017<span class="selector-tag">-01-17</span> 11<span class="selector-pseudo">:57</span><span class="selector-pseudo">:11.606719</span> <span class="selector-tag">TEST_OC</span><span class="selector-attr">[37189:3016637]</span> 10<span class="selector-class">.000000</span></span><br><span class="line"><span class="selector-tag">Program</span> <span class="selector-tag">ended</span> <span class="selector-tag">with</span> <span class="selector-tag">exit</span> <span class="selector-tag">code</span>: 0</span><br></pre></td></tr></table></figure><p>五、<strong>setValue:forKey:方法赋值的原理</strong></p><p>例如对于：[item setValue:@”value” forKey:@”property”]，具体实现为：</p><ol><li>首先去模型中查找有没有setProperty,找到,直接调用赋值 [self setProperty:@”value”]</li></ol><ol start="2"><li>去模型中查找有没有property属性,有,直接访问属性赋值  property = value</li></ol><ol start="3"><li>去模型中查找有没有_property属性,有,直接访问属性赋值 _property = value</li></ol><ol start="4"><li>找不到,就会直接报错 setValue:forUndefinedKey:报找不到的错误</li></ol><p>如果开发者想让这个类禁用KVC里，那么重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到set<key>:属性名时，会直接用setValue：forUNdefinedKey：方法。</key></p><p>所以，我们使用KVC要有以下三个条件：</p><ol><li>必须保证模型中定义的属性要大于或等于字典中key的数量。</li></ol><ol start="2"><li>模型中的基本数据类型无法进行转换。</li></ol><ol start="3"><li>属性的名字必须和键相同，否则找不到相关属性会报错。</li></ol><p>六、<strong>KVC异常处理</strong></p><p>KVC中最常见的异常就是不小心使用了错误的Key，或者在设值中不小心传递了nil的值，KVC中有专门的方法来处理这些异常。<br>通常在用KVC操作Model时，抛出异常的那两个方法是需要重写的。虽然一般很小出现传递了错误的Key值这种情况，但是如果不小心出现了，直接抛出异常让APP崩溃显然是不合理的。一般在这里直接让这个Key打印出来即可，或者有些特殊情况需要特殊处理。<br>通常情况下，KVC不允许你要在调用<em>setValue：属性值 forKey：@”name”</em>(或者keyPath)时对<strong>非对象</strong>传递一个nil的值。很简单，因为值类型是不能为nil的。如果你不小心传了，KVC会调用<em>setNilValueForKey:</em>方法。这个方法默认是抛出异常，所以一般而言最好还是重写这个方法。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[people1 <span class="built_in">set</span>Value:nil <span class="keyword">for</span>Key:@<span class="string">"age"</span>]</span><br><span class="line"></span><br><span class="line">*** Terminating app due <span class="keyword">to</span> uncaught exception 'NSInvalidArgumentException', reason: '[<span class="variable">&lt;People 0x100200080&gt;</span> <span class="built_in">set</span>NilValueForKey]: could not <span class="built_in">set</span> nil as the value <span class="keyword">for</span> the key age.' // 调用<span class="built_in">set</span>NilValueForKey抛出异常</span><br></pre></td></tr></table></figure><p>如果重写<em>setNilValueForKey:</em>就没问题了:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"不能将%@设成nil"</span>,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>七、<strong>KVC和字典</strong></p><p>当对NSDictionary对象使用KVC时，<em>valueForKey:</em>的表现行为和<em>objectForKey:</em>一样。所以使用<em>valueForKeyPath:</em>用来访问多层嵌套的字典是比较方便的。</p><p>KVC里面还有两个关于NSDictionary的方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure><p><code>dictionaryWithValuesForKeys:</code>是指输入一组key，返回这组key对应的属性，再组成一个字典。<br><code>setValuesForKeysWithDictionary</code>是用来修改Model中对应key的属性。下面直接用代码会更直观一点:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  TEST_OC</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/1/16.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Address</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Address</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span>* country;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span>* province;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span>* city;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span>* district;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Address</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模型转字典</span></span><br><span class="line">        Address* add = [Address new];</span><br><span class="line">        add.country = <span class="string">@"China"</span>;</span><br><span class="line">        add.province = <span class="string">@"Guang Dong"</span>;</span><br><span class="line">        add.city = <span class="string">@"Shen Zhen"</span>;</span><br><span class="line">        add.district = <span class="string">@"Nan Shan"</span>;</span><br><span class="line">        <span class="built_in">NSArray</span>* arr = @[<span class="string">@"country"</span>,<span class="string">@"province"</span>,<span class="string">@"city"</span>,<span class="string">@"district"</span>];</span><br><span class="line">        <span class="built_in">NSDictionary</span>* dict = [add dictionaryWithValuesForKeys:arr]; <span class="comment">//把对应key所有的属性全部取出来</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dict);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字典转模型</span></span><br><span class="line">        <span class="built_in">NSDictionary</span>* modifyDict = @&#123;<span class="string">@"country"</span>:<span class="string">@"USA"</span>,<span class="string">@"province"</span>:<span class="string">@"california"</span>,<span class="string">@"city"</span>:<span class="string">@"Los angle"</span>&#125;;</span><br><span class="line">        [add setValuesForKeysWithDictionary:modifyDict];            <span class="comment">//用key Value来修改Model的属性</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"country:%@  province:%@ city:%@"</span>,add.country,add.province,add.city);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">01</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">36.200448</span> TEST_OC[<span class="number">33394</span>:<span class="number">2683077</span>] &#123;</span><br><span class="line">    city = <span class="string">"Shen Zhen"</span>;</span><br><span class="line">    country = China;</span><br><span class="line">    district = <span class="string">"Nan Shan"</span>;</span><br><span class="line">    province = <span class="string">"Guang Dong"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2017</span>-<span class="number">01</span>-<span class="number">16</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">36.202199</span> TEST_OC[<span class="number">33394</span>:<span class="number">2683077</span>] country:USA  province:california city:Los angle</span><br><span class="line">Program ended with <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>打印出来的结果完全符合预期。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> KVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS RunLoop详解</title>
      <link href="/article/487/"/>
      <url>/article/487/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>一般来说，一个线程只能执行一个任务，执行完就会退出，如果我们需要一种机制，让线程能随时处理时间但并不退出，那么 RunLoop 就是这样的一个机制。Runloop是事件接收和分发机制的一个实现。</p><p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p><p>在开始Runloop内容之前，大家先考虑下面几个问题（后面会对这些问题逐个讲解）：</p><p>（1）基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？<br>（2）延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的吗？<br>（3）事件响应和手势识别底层处理是一致的吗，为什么？<br>（4）界面刷新时，是在什么时候会真正执行刷新，为什么会刷新不及时？<br>（5）项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？<br>（6）当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？</p><p>二、<strong>RunLoop基本作用</strong></p><p>1、保持程序持续运行</p><p>程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行。</p><p>2、处理App中的各种事件</p><p>比如：触摸事件，定时器事件，Selector事件等。</p><p>3、节省CPU资源，提高程序性能</p><p>程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情。</p><p>我们先通过API内一张图片来简单看一下RunLoop内部运行原理：</p><p><img src="/images/2017/01/20160506091116579.png" alt="20160506091116579"></p><p>通过上图可以看出，RunLoop在跑圈过程中，当接收到Input sources 或者 Timer sources时就会交给对应的处理方去处理。当没有事件消息传入的时候，RunLoop就休息了。</p><p>三、<strong>RunLoop的开启</strong></p><p>大家应该都知道程序的入口是main函数，iOS程序的入口当然也为main函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。</p><p>进入上面main函数返回的UIApplicationMain函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">int</span> <span class="built_in">UIApplicationMain</span>(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> principalClassName, <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> delegateClassName);</span><br></pre></td></tr></table></figure><p>我们发现它返回的是一个int类型的值，那么我们对main函数做一些修改：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> re = <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，我们发现只会打印开始，并不会打印结束，这说明<strong>在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行</strong>。</p><p>我们来看到RunLoop的源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;    <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现RunLoop确实是do while通过判断result的值实现的。因此，我们可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。</p><p>四、<strong>RunLoop对象</strong></p><p>RunLoop对象包括Fundation中的NSRunLoop对象和CoreFoundation中的CFRunLoopRef对象。因为Fundation框架是基于CFRunLoopRef的封装，因此我们学习RunLoop还是要研究CFRunLoopRef 源码。</p><p>1、获得RunLoop对象</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Foundation</span></span><br><span class="line"><span class="selector-attr">[NSRunLoop currentRunLoop]</span>; <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="selector-attr">[NSRunLoop mainRunLoop]</span>; <span class="comment">// 获得主线程的RunLoop对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Core Foundation</span></span><br><span class="line"><span class="selector-tag">CFRunLoopGetCurrent</span>(); <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="selector-tag">CFRunLoopGetMain</span>(); <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure><p>五、<strong>RunLoop和线程</strong></p><p>1、RunLoop和线程之间的关系</p><p>（1）每条线程都有唯一的一个与之对应的RunLoop对象。</p><p>（2）主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建。</p><p>（3）RunLoop在第一次获取时创建，在线程结束时销毁。</p><p>2、主线程相关联的RunLoop创建</p><p>CFRunLoopRef源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字典</span></span><br><span class="line"> <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主线程 根据传入的主线程创建主线程对应的RunLoop</span></span><br><span class="line"> <span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存主线程 将主线程-key和RunLoop-Value保存到字典中</span></span><br><span class="line"> <span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br></pre></td></tr></table></figure><p>3、创建与子线程相关联的RunLoop</p><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p><p>CFRunLoopRef源码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。<strong>RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时</strong>。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><p><code>[NSRunLoop currentRunLoop];</code>方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。</p><p>六、<strong>RunLoop相关类</strong></p><p>Core Foundation中关于RunLoop的5个类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span>  <span class="comment">//获得当前RunLoop和主RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopModeRef</span>  <span class="comment">//运行模式，只能选择一种，在不同模式中做不同的操作</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span>  <span class="comment">//事件源，输入源</span></span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span> <span class="comment">//定时器时间</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> <span class="comment">//观察者</span></span><br></pre></td></tr></table></figure><p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p><p><img src="/images/2017/01/RunLoop_0.png" alt="RunLoop_0"></p><p>1、 CFRunLoopModeRef</p><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p><p>系统默认注册了5个Mode，其中常见的有1.2两种：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> kCFRunLoopDefaultMode：App的默认<span class="keyword">Mode</span>，通常主线程是在这个<span class="keyword">Mode</span>下运行</span><br><span class="line"><span class="number">2.</span> UITrackingRunLoopMode：界面跟踪 <span class="keyword">Mode</span>，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 <span class="keyword">Mode</span> 影响</span><br><span class="line"><span class="number">3.</span> UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 <span class="keyword">Mode</span>，启动完成后就不再使用</span><br><span class="line"><span class="number">4.</span> GSEventReceiveRunLoopMode: 接受系统事件的内部 <span class="keyword">Mode</span>，通常用不到</span><br><span class="line"><span class="number">5.</span> kCFRunLoopCommonModes: 这是一个占位用的<span class="keyword">Mode</span>，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的<span class="keyword">Mode</span></span><br></pre></td></tr></table></figure><p>上面的 Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><p>Mode间的切换：</p><p>我们平时在开发中一定遇到过，当我们使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况，我们通过一段代码来看一下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];</span></span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 加入到RunLoop中才可以运行</span></span><br><span class="line">    <span class="comment">// 1. 把定时器添加到RunLoop中，并且选择默认运行模式NSDefaultRunLoopMode = kCFRunLoopDefaultMode</span></span><br><span class="line">    <span class="comment">// [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span></span><br><span class="line">    <span class="comment">// 当textFiled滑动的时候，timer失效，停止滑动时，timer恢复</span></span><br><span class="line">    <span class="comment">// 原因：当textFiled滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 当我们将timer添加到UITrackingRunLoopMode模式中，此时只有我们在滑动textField时timer才会运行</span></span><br><span class="line">    <span class="comment">// [[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 那个如何让timer在两个模式下都可以运行呢？</span></span><br><span class="line">    <span class="comment">// 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer</span></span><br><span class="line">    <span class="comment">// 3.2 使用站位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，下面两种模式被打上标签</span></span><br><span class="line">    <span class="comment">//0 : &lt;CFString 0x10b7fe210 [0x10a8c7a40]&gt;&#123;contents = "UITrackingRunLoopMode"&#125;</span></span><br><span class="line">    <span class="comment">//2 : &lt;CFString 0x10a8e85e0 [0x10a8c7a40]&gt;&#123;contents = "kCFRunLoopDefaultMode"&#125;</span></span><br><span class="line">    <span class="comment">// 因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSRunLoop</span> mainRunLoop]);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)show</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可以看出，NSTimer不管用是因为Mode的切换，因为如果我们在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当我们停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所有NSTimer就又管用了。<br>同样道理的还有ImageView的显示，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet&lt;UITouch *&gt; *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">    <span class="comment">// performSelector默认是在default模式下运行，因此在滑动ScrollView时，图片不会加载</span></span><br><span class="line">    <span class="comment">// [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@"abc"] afterDelay:2.0 ];</span></span><br><span class="line">    <span class="comment">// inModes: 传入Mode数组</span></span><br><span class="line">    [self.imageView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">setImage:</span>) <span class="string">withObject:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"abc"</span>] <span class="string">afterDelay:</span><span class="number">2.0</span> <span class="string">inModes:</span>@[NSDefaultRunLoopMode,UITrackingRunLoopMode]];</span><br></pre></td></tr></table></figure><p>使用GCD也可以创建计时器，而且更为精确：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//1.创建一个GCD定时器</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一个参数:表明创建的是一个定时器</span></span><br><span class="line"><span class="comment">     第四个参数:队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="comment">// 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块</span></span><br><span class="line">    <span class="comment">// 局部变量，让指针强引用</span></span><br><span class="line">    <span class="keyword">self</span>.timer = timer;</span><br><span class="line">    <span class="comment">//2.设置定时器的开始时间,间隔时间,精准度</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第1个参数:要给哪个定时器设置</span></span><br><span class="line"><span class="comment">     第2个参数:开始时间</span></span><br><span class="line"><span class="comment">     第3个参数:间隔时间</span></span><br><span class="line"><span class="comment">     第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能</span></span><br><span class="line"><span class="comment">     GCD的单位是纳秒 所以要*NSEC_PER_SEC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.设置定时器要执行的事情</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---%@--"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、CFRunLoopSourceRef</p><p>Source分为两种：</p><p>Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕）<br>Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）<br>注意：Source1在处理的时候会分发一些操作给Source0去处理</p><p>3、CFRunLoopObserverRef</p><p><strong>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变。</strong><br>我们直接来看代码，给RunLoop添加监听者，监听其运行状态：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//创建监听者</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一个参数 CFAllocatorRef allocator：分配存储空间 CFAllocatorGetDefault()默认分配</span></span><br><span class="line"><span class="comment">     第二个参数 CFOptionFlags activities：要监听的状态 kCFRunLoopAllActivities 监听所有状态</span></span><br><span class="line"><span class="comment">     第三个参数 Boolean repeats：YES:持续监听 NO:不持续</span></span><br><span class="line"><span class="comment">     第四个参数 CFIndex order：优先级，一般填0即可</span></span><br><span class="line"><span class="comment">     第五个参数 ：回调 两个参数observer:监听者 activity:监听的事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     所有事件</span></span><br><span class="line"><span class="comment">     typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span></span><br><span class="line"><span class="comment">     kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop</span></span><br><span class="line"><span class="comment">     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span></span><br><span class="line"><span class="comment">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span></span><br><span class="line"><span class="comment">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span></span><br><span class="line"><span class="comment">     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒</span></span><br><span class="line"><span class="comment">     kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</span></span><br><span class="line"><span class="comment">     kCFRunLoopAllActivities = 0x0FFFFFFFU</span></span><br><span class="line"><span class="comment">     &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"RunLoop进入"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"RunLoop要处理Timers了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"RunLoop要处理Sources了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"RunLoop要休息了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"RunLoop醒来了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"RunLoop退出了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给RunLoop添加监听者</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一个参数 CFRunLoopRef rl：要监听哪个RunLoop,这里监听的是主线程的RunLoop</span></span><br><span class="line"><span class="comment">     第二个参数 CFRunLoopObserverRef observer 监听者</span></span><br><span class="line"><span class="comment">     第三个参数 CFStringRef mode 要监听RunLoop在哪种运行模式下的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     CF的内存管理（Core Foundation）</span></span><br><span class="line"><span class="comment">     凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release</span></span><br><span class="line"><span class="comment">     GCD本来在iOS6.0之前也是需要我们释放的，6.0之后GCD已经纳入到了ARC中，所以我们不需要管了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/2017/01/1434508-106d3e9fca39903f.png" alt="1434508-106d3e9fca39903f"></p><p>七、<strong>RunLoop处理逻辑</strong></p><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p><p><img src="/images/2017/01/RunLoop_1.png" alt="RunLoop_1"></p><p>其内部代码整理如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0</span>e10, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = <span class="variable">__CFRunLoopFindMode</span>(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">__CFRunLoopModeIsEmpty</span>(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    <span class="variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    <span class="variable">__CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            <span class="variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            <span class="variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            <span class="variable">__CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = <span class="variable">__CFRunLoopDoSources0</span>(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            <span class="variable">__CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">__Source0DidDispatchPortLastTime</span>) &#123;</span><br><span class="line">                Boolean hasMsg = <span class="variable">__CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="built_in">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                <span class="variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            <span class="variable">__CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            <span class="variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                <span class="variable">__CFRunLoopDoTimers</span>(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                <span class="variable">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = <span class="variable">__CFRunLoopModeFindSourceForMachPort</span>(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = <span class="variable">__CFRunLoopDoSource1</span>(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            <span class="variable">__CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">__CFRunLoopIsStopped</span>(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">__CFRunLoopModeIsEmpty</span>(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    <span class="variable">__CFRunLoopDoObservers</span>(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><p>八、<strong>RunLoop退出</strong></p><p>（1）主线程销毁RunLoop退出。</p><p>（2）Mode中有一些Timer 、Source、 Observer，这些保证Mode不为空时保证RunLoop没有空转并且是在运行的，当Mode中为空的时候，RunLoop会立刻退出。</p><p>（3）我们在启动RunLoop的时候可以设置什么时候停止。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]runUntilDate:&lt;<span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nonnull</span> <span class="variable">NSDate</span> *)</span></span>#&gt;</span><br><span class="line">[NSRunLoop currentRunLoop]runMode:&lt;<span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nonnull</span> <span class="variable">NSString</span> *)</span></span>#&gt; beforeDate:&lt;<span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nonnull</span> <span class="variable">NSDate</span> *)</span></span>#&gt;</span><br></pre></td></tr></table></figure><p>九、<strong>回答概述中留的几个问题</strong></p><p>1、基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？</p><p>这个问题前面已经讲解过了，这里不再浪费时间重讲一次，没意义。</p><p>2、延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的吗？</p><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><p>3、事件响应和手势识别底层处理是一致的吗，为什么？</p><h4 id="事件响应："><a href="#事件响应：" class="headerlink" title="事件响应："></a>事件响应：</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><p>#### </p><h4 id="手势识别："><a href="#手势识别：" class="headerlink" title="手势识别："></a>手势识别：</h4><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><p>4、界面刷新时，是在什么时候会真正执行刷新，为什么会刷新不及时？</p><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。所以说界面刷新并不一定是在setNeedsLayout相关的代码执行后立刻进行的<strong>。</strong></p><p>5、项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？</p><p>这个问题在峰哥之前的文章《<a href="http://www.imlifengfeng.com/blog/?p=302" target="_blank" rel="noopener"><em>iOS开发之内存管理</em></a>》中也有讲述，感兴趣的可以自己去看。这里再详细讲解一遍：</p><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，一般情况下开发者也不必显示创建 Pool 了。</p><p>6、当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？</p><p>首先引入一个概念：Event_loop，一般一个线程执行完任务后就会退出，当需要保证该线程不退出，可以通过类似以下方式：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启一个循环，保证线程不退出，这就是Event_loop模型。这是在很多操作系统中都使用的模型，例如OS/iOS中的RunLoop。这种模型最大的作用就是管理事件/消息，在有新消息到来时立刻唤醒处理，没有待处理消息时线程休眠，避免资源浪费。</p><p>以上就是关于iOS  RunLoop的全部总结，花了峰哥好长时间，结合自己的理解并参考了官方文档和网上大量相关文章总结而成。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS instancetype和id区别详解</title>
      <link href="/article/485/"/>
      <url>/article/485/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>instancetype是clang 3.5开始提供的一个关键字，与id一样表示某个方法返回的未知类型的Objective-C对象。但是instancetype和id区别到底有什么区别呢？</p><p>二、<strong>关联返回类型和非关联返回类型</strong></p><p>要搞懂id 和instancetype的异同 首先要弄懂iOS中两个概念：关联返回类型和非关联返回类型。</p><p>1、关联返回类型</p><p>根据Cocoa的命名规则，满足下述规则的方法：<br>（1）类方法中，以alloc或new开头<br>（2）实例方法中，以autorelease，init，retain或self开头<br>会返回一个方法所在类类型的对象，这些方法就被称为是关联返回类型的方法。换句话说，这些方法的返回结果以方法所在的类为类型。</p><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>  </span></span><br><span class="line">+ (<span class="keyword">id</span>)alloc;  </span><br><span class="line">- (<span class="keyword">id</span>)init;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>当我们使用如下方式初始化NSArray时：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = <span class="comment">[<span class="comment">[NSArray alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure><p>按照Cocoa的命名规则，[NSArray alloc]与[[NSArray alloc]init]返回的都为NSArray的对象。</p><p>2、非关联返回类型</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span>  </span></span><br><span class="line">+ (<span class="keyword">id</span>)constructAnArray;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>当我们使用如下方式初始化NSArray时：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[NSArray constructAnArray]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id。</p><p>但是如果使用instancetype作为返回类型，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span>  </span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)constructAnArray;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>当使用相同方式初始化NSArray时：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[NSArray constructAnArray]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>得到的返回类型和方法所在类的类型相同，是NSArray*!</p><p>总结一下，instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！</p><p>三、<strong>instancetype和id区别</strong></p><p>（1）id在编译的时候不能判断对象的真实类型</p><p>instancetype在编译的时候可以判断对象的真实类型</p><p>（2）如果init方法的返回值是instancetype,那么将返回值赋值给一个其它的对象会报一个警告</p><p>如果是在以前, init的返回值是id,那么将init返回的对象地址赋值给其它对象是不会报错的</p><p>（3）id可以用来定义变量, 可以作为返回值, 可以作为形参</p><p>instancetype只能用于作为返回值，例如：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//err,expected a type  </span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(instancetype)<span class="keyword">value</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//do something  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">就是错的，应该写成：</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(id)<span class="keyword">value</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：以后但凡自定义构造方法, 返回值尽量使用instancetype, 不要使用id</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> id </tag>
            
            <tag> instancetype </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS UIApplicationDelegate与UIViewController生命周期</title>
      <link href="/article/478/"/>
      <url>/article/478/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>UIApplicationDelegate是什么？</strong></p><p>每个 iPhone 应用程序都有一个 UIApplication，UIApplication 是 iPhone 应用程序的开始并且负责初始化并显示 UIWindow，并负责加载应用程序的第一个 UIView 到 UIWindow 窗体中。</p><p>UIApplication 的另一个任务是帮助管理应用程序的生命周期，而 UIApplication 通过一个名字为 UIApplicationDelegate 的代理类来履行这个任务。尽管 UIApplication 会负责接收事件，而 UIApplicationDelegate 则决定应用程序如何去响应这些事件，UIApplicationDelegate 可以处理的事件包括应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警 告）。如下图：</p><p><img src="/images/2017/01/1933920-acb1107656c1a483.png" alt="1933920-acb1107656c1a483"></p><p>通常是没必要修改UIApplication的，只需要知道 UIApplication 接收系统事件即可。处理系统事件需要编写一个继承自 UIApplicationDelegate 接口的类，而 UIApplicationDelegate 接口提供生命周期函数来处理应用程序以及应用程序的系统事件。我们新建项目的时候，往往会自动生成一个继承自 UIApplicationDelegate 接口的类AppDelegate。</p><p>二、<strong>UIApplicationDelegate的生命周期</strong></p><p>下面通过一个小demo理解UIApplicationDelegate常用生命周期中的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark 在应用程序加载完毕之后调用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didFinishLaunchingWithOptions-加载完毕"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个窗口</span></span><br><span class="line">    <span class="keyword">self</span>.window = [[[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]] autorelease];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入xib文件名来初始化一个控制器</span></span><br><span class="line">    <span class="keyword">self</span>.viewController = [[[MJViewController alloc] initWithNibName:<span class="string">@"MJViewController"</span> bundle:<span class="literal">nil</span>] autorelease];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置窗口的根控制器</span></span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.viewController;</span><br><span class="line">    <span class="comment">// 上面的代码内部执行了下面代码的操作</span></span><br><span class="line">    <span class="comment">// [self.window addSubview:self.viewController.view];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 窗口不会默认显示，需要调用方法来显示</span></span><br><span class="line">    <span class="comment">// keyWindow是主窗口，只有主窗口才能跟用户正常交互</span></span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">    <span class="comment">// self.window.hidden = NO;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 程序失去焦点的时候调用（不能跟用户进行交互了）</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"applicationWillResignActive-失去焦点"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 当应用程序进入后台的时候调用（点击HOME键）</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"applicationDidEnterBackground-进入后台"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 当应用程序进入前台的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"applicationWillEnterForeground-进入前台"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 当应用程序获取焦点的时候调用</span></span><br><span class="line"><span class="comment">// 获取焦点之后才可以跟用户进行交互</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"applicationDidBecomeActive-获取焦点"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 程序在某些情况下被终结时会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"applicationWillTerminate-被关闭"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目启动后：</p><p>Test[517:c07] didFinishLaunchingWithOptions-加载完毕<br>Test[517:c07] applicationDidBecomeActive-获取焦点<br>按下home键：</p><p>Test[517:c07] applicationWillResignActive-失去焦点<br>Test[517:c07] applicationDidEnterBackground-进入后台</p><p>再按程序：<br>Test[517:c07] applicationWillEnterForeground-进入前台<br>Test[517:c07] applicationDidBecomeActive-获取焦点</p><p>三、<strong>UIViewController是什么</strong></p><p>UIViewController（后面简称ViewController）是iOS开发中MVC模式中的C，ViewController是view的controller，ViewController的职责主要包括管理内部各个view的加载显示和卸载，同时负责与其他ViewController的通信和协调。</p><p>在IOS中，有两类ViewController，一类是显示内容的，比如UIViewController、UITableViewController等，同时还可以自定义继承自UIViewController的ViewController；另一类是ViewController容器，UINavigationViewController和UITabBarController等，UINavigationController是以Stack的形式来存储和管理ViewController，UITabBarController是以Array的形式来管理ViewController。和Android中Activity一样，IOS开发中，ViewController也有自己的生命周期。</p><p>四、<strong>UIViewController的生命周期</strong></p><p>1、view的加载和卸载</p><p>既然ViewController负责管理内部各个view的加载显示和卸载，那我们先来看看View的加载过程，如下图：</p><p><img src="/images/2017/01/1354776680_2123.png" alt="1354776680_2123"></p><p>从图中可以看到，在view加载过程中首先会调用loadView方法，在这个方法中主要完成一些关键view的初始化工作，比如UINavigationViewController和UITabBarController等容器类的ViewController；</p><p>接下来就是加载view，加载成功后，会接着调用viewDidLoad方法，这里要记住的一点是，<strong>在loadView之前，是没有view的</strong>，也就是说，在这之前，view还没有被初始化。完成viewDidLoad方法后，ViewController里面就成功的加载view了，如上图右下角所示。</p><p>在Controller中创建view有两种方式，一种是通过代码创建、一种是通过Storyboard或Interface Builder来创建，后者可以比较直观的配置view的外观和属性，Storyboard配合IOS6后推出的AutoLayout，应该是Apple之后主推的一种UI定制解决方案。</p><p>接下来我们看看ViewController中的view是如何被卸载的，如下图：</p><p><img src="/images/2017/01/1354776741_7366.png" alt="1354776741_7366"></p><p>从图中可以看到，当系统发出内存警告时，会调用didReceiveMemoeryWarning方法，如果当前有能被释放的view，系统会调用viewWillUnload方法来释放view，完成后调用viewDidUnload方法，至此，view就被卸载了。此时原本指向view的变量要被置为nil，具体操作是在viewDidUnload方法中调用self.myView = nil;</p><p>2、ViewController的生命周期</p><p>ViewController的生命周期中各方法执行流程如下图：</p><p><img src="/images/2017/01/2954611-1695623d06b209cc.png" alt="2954611-1695623d06b209cc"></p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ViewController 初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:coder];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ViewController 从归档初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:nibNameOrNil bundle:nibBundleOrNil];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ViewController 从xib初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    [<span class="keyword">super</span> loadView];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 开始加载视图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 已经加载视图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillLayoutSubviews];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 开始布局子视图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLayoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLayoutSubviews];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 完成布局子视图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 即将显示"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 已经显示"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 即将消失"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidDisappear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 已经消失"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController 收到内存警告"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.422</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 从归档初始化</span><br><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.433</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 开始加载视图</span><br><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.434</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 已经加载视图</span><br><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.434</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 即将显示</span><br><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.440</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 开始布局子视图</span><br><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.440</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 完成布局子视图</span><br><span class="line">2017<span class="selector-tag">-01-11</span> 12<span class="selector-pseudo">:02</span><span class="selector-pseudo">:55.443</span> <span class="selector-tag">Test</span><span class="selector-attr">[11948:560350]</span> <span class="selector-tag">ViewController</span> 已经显示</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Category详解</title>
      <link href="/article/474/"/>
      <url>/article/474/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>Category是Objective-C 2.0之后添加的语言特性，Category又叫分类、类别、类目，能够在不改变原来类内容的基础上，为类增加一些方法。除此之外，Category还有以下功能：</p><p>（1）将类的实现分开写在几个分类里面。<br>这样做的好处:</p><ul><li>可以减少单个文件的体积</li></ul><ul><li>可以把不同的功能组织到不同的Category里</li></ul><ul><li>可以由多个开发者共同完成一个类</li></ul><ul><li>可以按需加载想要的category</li></ul><p>（2）声明私有的方法。</p><p>（3）模拟多继承。</p><p>二、<strong>Category的定义与使用</strong></p><p>为了便于理解，这里直接通过一个小例子去讲解其用法。</p><p>例如，我们创建一个Person类，并为其创建一个Category命名为MyCategory。创建Category很简单，如下图：</p><p><img src="/images/2017/01/Snip20170109_5.png" alt="snip20170109_5"></p><p><img src="/images/2017/01/Snip20170109_8.png" alt="snip20170109_8"></p><p>为Person创建一个名为MyCategory的Category后，会自动生成Person+MyCategory.h和Person+MyCategory.m文件。我们在MyCategory中声明和实现一个read方法，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Person+MyCategory.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">MyCategory</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Person+MyCategory.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person+MyCategory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">MyCategory</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)read&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了MyCategory的read方法！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后我们可以在ViewController或其他地方使用分类中添加的方法，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person+MyCategory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    [p read];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-01-09</span> 16<span class="selector-pseudo">:27</span><span class="selector-pseudo">:39.089</span> <span class="selector-tag">Test</span><span class="selector-attr">[5347:483009]</span> 调用了<span class="selector-tag">MyCategory</span>的<span class="selector-tag">read</span>方法！</span><br></pre></td></tr></table></figure><p>[successbox title=”使用注意”]</p><ol><li>分类只能增加方法，不能增加成员变量。</li></ol><ol start="2"><li>分类方法实现中可以访问原来类中声明的成员变量。</li></ol><ol start="3"><li>分类可以重新实现原来类中的方法，但是会覆盖掉原来的方法，会导致原来的方法没法再使用（实际上并没有真的替换，而是Category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的Category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法）。</li></ol><ol start="4"><li>当分类、原来类、原来类的父类中有相同方法时，方法调用的优先级：分类(最后参与编译的分类优先) –&gt; 原来类  –&gt; 父类，即先去调用分类中的方法，分类中没这个方法再去原来类中找，原来类中没有再去父类中找。</li></ol><ol start="5"><li>Category是在runtime时候加载，而不是在编译的时候。</li></ol><p>[/successbox]<br>三、<strong>Category与成员变量、属性</strong></p><p>如果你在你Category的.h文件中写如下代码：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSString *str1<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Xcode会报如下错误:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instance <span class="built_in">variable</span> may <span class="literal">not</span> be placed <span class="keyword">in</span> categories</span><br></pre></td></tr></table></figure><p>通过这句话我们知道Xcode是不允许我们在Category中添加成员变量的。</p><p>为什么不能添加成员变量呢？</p><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>objc_class结构体的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>            <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>   <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>    <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 协议链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>在上面的objc_class结构体中，ivars是objc_ivar_list（成员变量列表）指针；methodLists是指向objc_method_list指针的指针。在Runtime中，objc_class结构体大小是固定的，不可能往这个结构体中添加数据，只能修改。所以ivars指向的是一个固定区域，只能修改成员变量值，不能增加成员变量个数。methodList是一个二维数组，所以可以修改*methodLists的值来增加成员方法，虽没办法扩展methodLists指向的内存区域，却可以改变这个内存区域的值（存储的是指针）。因此，可以动态添加方法，不能添加成员变量。</p><p>Category不能添加成员变量（instance variables），那到底能不能添加属性（property）呢？</p><p>这个我们要从Category的结构体开始分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">//类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;  <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>  <span class="comment">//category中所有给类添加的实例方法的列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>  <span class="comment">//category中所有添加的类方法的列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>  <span class="comment">//category实现的所有协议的列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>  <span class="comment">//category中添加的所有属性</span></span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure><p>从Category的定义也可以看出Category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p><p>但是为什么网上很多人都说Category不能添加属性呢？</p><p>实际上，Category实际上允许添加属性的，同样可以使用@property，但是不会生成_变量（带下划线的成员变量），也不会生成添加属性的getter和setter方法，所以，尽管添加了属性，也无法使用点语法调用getter和setter方法。但实际上可以使用runtime去实现Category为已有的类添加新的属性并生成getter和setter方法。详细内容可以看峰哥之前的文章：《<a href="http://www.imlifengfeng.com/blog/?p=397" target="_blank" rel="noopener"><em>iOS Runtime之四：关联对象</em></a>》</p><p>四、<strong>Category与Extension</strong></p><p>1、Extension的基本用法</p><p>Extension的创建方法与Category一样，只要在原来选择Category选择Extension即可，比如我们为Person创建一个名为MyExtension的Extension，则最终会生成一个Person_MyExtension.h文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Person_MyExtension.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>但要注意的是和Category不同的是它不会生成Person_MyExtension.m文件。之后我们可以在Person_MyExtension.h中<strong>直接添加成员变量、属性和方法</strong>，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Person_MyExtension.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * _address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span>*)WhereAmI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>他常用的形式不是创建一个单独的文件，而是在实现文件中添加私有的成员变量、属性和方法。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>  Person.m</span><br><span class="line"></span><br><span class="line"><span class="comment">#import "Person.h"</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">/Extension start/</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></span><br><span class="line"></span><br><span class="line">@interface Person ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _address;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic) NSInteger age;</span><br><span class="line"></span><br><span class="line">-(NSString*)WhereAmI;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">/Extension end/</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">-(NSString*)WhereAmI&#123;</span><br><span class="line">    return @<span class="string">"谁知道你在哪里"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>2、Extension与Category区别</p><ul><li>Extension</li></ul><pre><code>* 在编译器决议，是类的一部分，在编译器和头文件的@interface和实现文件里的@implement一起形成了一个完整的类。* 伴随着类的产生而产生，也随着类的消失而消失。* Extension一般用来隐藏类的私有消息，你必须有一个类的源码才能添加一个类的Extension，所以对于系统一些类，如NSString，就无法添加类扩展</code></pre><ul><li>Category</li></ul><pre><code>* 是运行期决议的* 类扩展可以添加实例变量，分类不能添加实例变量* 原因：因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局，这对编译性语言是灾难性的。</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Delegate用法</title>
      <link href="/article/472/"/>
      <url>/article/472/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>为什么我把本篇文章命名为《iOS Delegate用法》而不是《iOS Delegate详解》呢？因为Delegate并没有什么好说的，因为Delegate是基于Protocol实现的。所以这里只讲用法。</p><p>二、<strong>Delegate用法</strong></p><p>第一步：</p><p>在使用协议的AClass类中定义一个协议，常以”类名+Delegate “命名，比如AClassDelegate，在协议中定义需要使用的方法，比如定义的方法为：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> AClassDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line"></span><br><span class="line">- (void)<span class="attribute">year</span>:(NSString *)year <span class="attribute">month</span>:(NSString *)month <span class="attribute">day</span>:(NSString *)day;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>第二步：</p><p>在类中声明属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;AClassDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>第三步：</p><p>在AClass中定义一个事件（方法），在事件的实现中书写事件代码，并通知代理（即调用BClass那里实现的这个代理方法）：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> ([self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">year</span>:<span class="attribute">month</span>:<span class="attribute">day</span>:)]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="selector-attr">[self.delegate year:@”2015”  month:@”8”  day:@”1”]</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第四步：</p><p>其他类BClass中遵守AClassDelegate协议，并使用self. delegate = self;将这个其他设置为AClass的代理。并实现代理方法，当第三步中的事件发生时候会自动调用BClass里实现的代理方法，可以通过代理方法获得第三步传过来的数据:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="built_in">year</span>:(NSString *)<span class="built_in">year</span> <span class="built_in">month</span>:(NSString *)<span class="built_in">month</span> <span class="built_in">day</span>:(NSString *)<span class="built_in">day</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    NSLog([NSString stringWithFormat:@<span class="string">"%@年%@月%@日"</span>,<span class="built_in">year</span>,<span class="built_in">month</span>,<span class="built_in">day</span>];)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Delegate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Protocol详解</title>
      <link href="/article/469/"/>
      <url>/article/469/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>Protocol（协议）的声明看起来类似一个类的接口，不同的是Protocol没有父类也不能定义实例变量。Protocol是一种特殊的程序设计结构，用于声明专门被别的类实现的方法。因为OC是单继承的，由于不支持多继承，所以很多时候都是用Protocol和Category来代替实现多继承。Protocol只能定义公用的一套接口，但不能提供具体的实现方法。也就是说，它只告诉你要做什么，但具体怎么做，它不关心。</p><p>Protocol的基本用途：</p><p>（1）可以用来声明一大堆方法（不能声明成员变量）</p><p>（2）只要某个类遵守了这个协议，就相当于拥有这个协议中的所有方法声明</p><p>（3）只要父类遵守了某个协议，就相当于子类也遵守了</p><p>（4）和java中的接口很相似，但比接口功能更丰富</p><p>二、<strong>创建与遵守Protocol</strong></p><p>1、创建Protocol</p><p>创建Protocol很简单，如下图：</p><p><img src="/images/2017/01/Snip20170109_1.png" alt="snip20170109_1"></p><p><img src="/images/2017/01/Snip20170109_2.png" alt="snip20170109_2"></p><p>比如我们填写的文件名为MyProtocol，之后会生成一个MyPotocol.h文件，文件内容如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意下面的NSObject是基协议，而不是之前的基类</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在此声明方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后我们就<strong>在其中声明需要的方法，但要注意的是这里只做声明，不做实现。并且不能声明变量</strong>。具体的实现要在遵守这个协议的类中实现，综上，protocol就是用来声明方法的。</p><p>协议可用定义在单独.h文件中，也可用定义在某个类中：</p><p>（1） 如果这个协议只用在某个类中，应该把协议定义在该类中</p><p>（2） 如果这个协议用在很多类中，就应该定义在单独文件中</p><p>2、基协议</p><p>（1）NSObject是一个基类，是最根本最基本的类，任何其他类最终都要继承它</p><p>（2）<strong>其实还有一个协议，名字也叫NSObject，它是一个基协议，最根本最基本的协议</strong></p><p>（3）NSObject协议中声明了很多最基本的方法，比如description、retain、release等</p><p>（4）建议每个新协议都要遵守NSObject协议</p><p>3、协议中方法声明的关键字</p><p>（1） @<strong>required</strong> (默认)</p><p>要求实现，如果没有实现，会发出警告，但不报错</p><p>（2） @<strong>optional</strong></p><p>不要求实现，不实现也不会有警告</p><p>例如：</p><p>@require</p><ul><li>(void)test;</li></ul><p>@optional</p><ul><li>(void)test2;</li></ul><p>4、遵守协议</p><p>首先要<em>#import “协议文件名.h”</em>或者<em>@protocol 协议名称</em>，但是使用<em>@protocol 协议名称</em>时只是告诉下面代码这是一个协议，但不知道协议里面有什么东西，一般只在用到协议内容的时候在<em>#import”协议文件名.h”</em>。在实际开发中常用<em>@protocol 协议名称</em>。</p><p>（1） 类遵守协议</p><p>@interface 类名 : 父类名 &lt;协议名称1, 协议名称2&gt;</p><p>@end</p><p>（2） 协议遵守协议</p><p>@protocol 协议名称 &lt;其他协议名称1, 其他协议名称2&gt;</p><p>@end</p><p>5、定义一个变量的时候，限制这个变量保存的对象遵守某个协议</p><p>类名&lt;协议名称&gt; <strong>*</strong>变量名;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject&lt;MyProtocol&gt; *obj<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>id&lt;协议名称&gt; 变量名;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&lt;MyProtocol&gt; obj2<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>如果obj和obj2没有遵守MyProtocol的协议，编译器会警告。</p><p>6、@property中声明的属性也可用做一个遵守协议的限制</p><p>@property (nonatomic, strong) 类名&lt;协议名称&gt; *属性名;</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic, strong) Dog<span class="tag">&lt;MyProtocol&gt;</span> *dog;</span><br></pre></td></tr></table></figure><p>@property (nonatomic, strong) id&lt;协议名称&gt; 属性名;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;MyProtocol&gt; dog2;</span><br></pre></td></tr></table></figure><p>三、<strong>Protocol的一个简单示例</strong></p><p>例如：</p><p>我们新建一个Protocol，命名为HelloProtocol，然后就只会生成一个HelloProtocol.h文件，注意肯定没有.m文件，协议只是用来声明方法，并不是来实现的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">HelloProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认就是required;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)requiredMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)optionalMethod;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>新建Person类，在Person.h中引入协议，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"HelloProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span>&lt;<span class="title">HelloProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Person.m如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)requiredMethod&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"requiredMethod——必须实现的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)optionalMethod&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"optionalMethod——选择实现的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后在main.m中创建Person的对象去调用这些方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  @autoreleasepool &#123;</span><br><span class="line">    </span><br><span class="line">    Person *jack = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    [jack requiredMethod];</span><br><span class="line">    [jack optionalMethod];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子很简单，这里不做过多讲解~</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Block详解</title>
      <link href="/article/457/"/>
      <url>/article/457/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>闭包 = 一个函数「或指向函数的指针」+ 该函数执行的外部的上下文变量「也就是自由变量」；Block 是 Objective-C 对于闭包的实现。</p><p>其中，Block：</p><ul><li>可以嵌套定义，定义 Block 方法和定义函数方法相似</li></ul><ul><li>Block 可以定义在方法内部或外部</li></ul><ul><li>只有调用 Block 时候，才会执行其{}体内的代码</li></ul><ul><li>本质是对象，使代码高聚合</li></ul><p>使用 clang 将 OC 代码转换为 C++ 文件查看 block 的方法：</p><ul><li>在命令行输入代码 <em>clang -rewrite-objc 需要编译的OC文件.m</em></li></ul><ul><li>这时查看当前的文件夹里 多了一个相同的名称的 .cpp 文件，在命令行输入 <em>open main.cpp</em> 查看文件</li></ul><p>二、<strong>Block的定义与使用</strong></p><p>1、无参数无返回值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，无参数，无返回值，声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^MyBlockOne)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"无参数，无返回值"</span>);  </span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line">MyBlockOne();<span class="comment">//block的调用</span></span><br></pre></td></tr></table></figure><p>2、有参数无返回值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2，有参数，无返回值，声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^MyblockTwo)(<span class="keyword">int</span> a) = ^(<span class="keyword">int</span> a)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"@ = %d我就是block，有参数，无返回值"</span>,a);</span><br><span class="line"></span><br><span class="line">  &#125;;  </span><br><span class="line">MyblockTwo(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>3、有参数有返回值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3，有参数，有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(^MyBlockThree)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;    </span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%d我就是block，有参数，有返回值"</span>,a + b);returna + b; </span><br><span class="line"></span><br><span class="line"> &#125;;  </span><br><span class="line">MyBlockThree(<span class="number">12</span>,<span class="number">56</span>);</span><br></pre></td></tr></table></figure><p>4、无参数有返回值(很少用到)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4，无参数，有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(^MyblockFour)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"无参数，有返回值"</span>);</span><br><span class="line">        return45;</span><br><span class="line">  &#125;;</span><br><span class="line">MyblockFour();</span><br></pre></td></tr></table></figure><p>5、实际开发中常用typedef 定义Block</p><p>例如，用typedef定义一个block：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(^MyBlock)</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这时，MyBlock就成为了一种Block类型<br>在定义类的属性时可以这样：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic,copy) MyBlock myBlockOne;</span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.myBlockOne = ^<span class="keyword">int</span> (<span class="keyword">int</span> ,<span class="keyword">int</span>)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、<strong>Block与外界变量</strong></p><p>1、截获自动变量（局部变量）值</p><p>（1）默认情况</p><p>对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。也就是说block的自动变量截获只针对block内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于block的结构体内部, 会导致block体积变大。特别要注意的是默认情况下block只能访问不能修改局部变量的值。</p><p><img src="/images/2017/01/1862021-631904c4e9aba96d.jpg" alt="1862021-631904c4e9aba96d"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">myBlock <span class="keyword">block </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"age = %d"</span>, age)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">age = <span class="number">18</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>（2） __block 修饰的外部变量</p><p>对于用 <strong>block 修饰的外部变量引用，block 是复制其引用地址来实现访问的。block可以修改</strong>block 修饰的外部变量的值。</p><p><img src="/images/2017/01/1862021-9d41b9401608ce22.jpg" alt="1862021-9d41b9401608ce22"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block int age = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">myBlock <span class="keyword">block </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"age = %d"</span>, age)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">age = <span class="number">18</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>为什么使用__block 修饰的外部变量的值就可以被block修改呢？</p><p>我们使用 clang 将 OC 代码转换为 C++ 文件：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -<span class="built_in">rewrite</span>-objc 源代码文件名</span><br></pre></td></tr></table></figure><p>便可揭开其真正面纱：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block int val = <span class="number">10</span>;</span><br><span class="line">转换成</span><br><span class="line">__Block_byref_val_0 val = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &amp;val,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    sizeof(__Block_byref_val_0),</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>会发现一个局部变量加上<strong>block修饰符后竟然跟block一样变成了一个</strong>Block_byref_val_0结构体类型的自动变量实例！！！！</p><p>此时我们在block内部访问val变量则需要通过一个叫<strong>forwarding的成员变量来间接访问val变量(下面会对</strong>forwarding进行详解)</p><p>四、<strong>Block的copy操作</strong></p><p>1、Block的存储域及copy操作</p><p>在开始研究Block的copy操作之前，先来思考一下：Block是存储在栈上还是堆上呢？</p><p>我们先来看看一个由C/C++/OBJC编译的程序占用内存分布的结构：</p><p><img src="/images/2017/01/memory_structure.jpg" alt="memory_structure"></p><p>其实，block有三种类型：</p><ul><li>全局块(_NSConcreteGlobalBlock)</li></ul><ul><li>栈块(_NSConcreteStackBlock)</li></ul><ul><li>堆块(_NSConcreteMallocBlock)</li></ul><p>这三种block各自的存储域如下图：</p><p><img src="/images/2017/01/2107810-db72f760c3eaa8ab.jpg" alt="2107810-db72f760c3eaa8ab"></p><ul><li>全局块存在于全局内存中, 相当于单例.</li></ul><ul><li>栈块存在于栈内存中, 超出其作用域则马上被销毁</li></ul><ul><li>堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存</li></ul><p>简而言之，存储在栈中的Block就是栈块、存储在堆中的就是堆块、既不在栈中也不在堆中的块就是全局块。</p><p>遇到一个Block，我们怎么这个Block的存储位置呢？</p><p>（1）Block不访问外界变量（包括栈中和堆中的变量）</p><p>Block 既不在栈又不在堆中，在代码段中，ARC和MRC下都是如此。此时为全局块。</p><p>（2）Block访问外界变量</p><p>MRC 环境下：访问外界变量的 Block 默认存储<strong>栈</strong>中。<br>ARC 环境下：访问外界变量的 Block 默认存储在<strong>堆</strong>中（<strong>实际是放在栈区，然后ARC情况下自动又拷贝到堆区</strong>），自动释放。</p><p>ARC下，访问外界变量的 Block为什么要自动从栈区拷贝到堆区呢？</p><p>栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，如同一般的自动变量。当然，Block中的__block变量也同时被废弃。如下图：</p><p><img src="/images/2017/01/3629436-49cdbfca00a85bb6.png" alt="3629436-49cdbfca00a85bb6"></p><p>为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们需要把Block复制到堆中，延长其生命周期。开启ARC时，大多数情况下编译器会恰当地进行判断是否有需要将Block从栈复制到堆，如果有，自动生成将Block从栈上复制到堆上的代码。<strong>Block的复制操作执行的是copy实例方法</strong>。Block只要调用了copy方法，栈块就会变成堆块。</p><p>如下图：</p><p><img src="/images/2017/01/3629436-bb42e22148f1c747.png" alt="3629436-bb42e22148f1c747"></p><p>例如下面一个返回值为Block类型的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(^<span class="keyword">blk_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate) &#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> count) &#123; <span class="keyword">return</span> rate * count; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知：上面的函数返回的Block是配置在栈上的，所以返回函数调用方时，Block变量作用域就结束了，Block会被废弃。但在ARC有效，这种情况编译器会自动完成复制。</p><p>在非ARC情况下则需要开发者调用copy方法手动复制，由于开发中几乎都是ARC模式，所以手动复制内容不再过多研究。</p><p>将Block从栈上复制到堆上相当消耗CPU，所以当Block设置在栈上也能够使用时，就不要复制了，因为此时的复制只是在浪费CPU资源。</p><p>Block的复制操作执行的是copy实例方法。不同类型的Block使用copy方法的效果如下表：</p><p><img src="/images/2017/01/Snip20170108_2.png" alt="snip20170108_2"></p><p>根据表得知，Block在堆中copy会造成引用计数增加，这与其他Objective-C对象是一样的。虽然Block在栈中也是以对象的身份存在，但是栈块没有引用计数，因为不需要，我们都知道栈区的内存由编译器自动分配释放。关于堆区和栈区详细内容可以参考下峰哥之前的文章：《<a href="http://www.imlifengfeng.com/blog/?p=147" target="_blank" rel="noopener">总结：堆、栈、队列</a>》</p><p>不管Block存储域在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。</p><p>在ARC有效时，多次调用copy方法完全没有问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blk = [[[[blk <span class="built_in">copy</span>] <span class="built_in">copy</span>] <span class="built_in">copy</span>] <span class="built_in">copy</span>];</span><br><span class="line"><span class="comment">// 经过多次复制，变量blk仍然持有Block的强引用，该Block不会被废弃。</span></span><br></pre></td></tr></table></figure><p>2、<strong>block变量与</strong>forwarding</p><p>在copy操作之后，既然<strong>block变量也被copy到堆上去了, 那么访问该变量是访问栈上的还是堆上的呢?**</strong>forwarding** 终于要闪亮登场了，如下图：</p><p><img src="/images/2017/01/1862021-100fdd59e5b0c03a.png" alt="1862021-100fdd59e5b0c03a"></p><p>通过<strong>forwarding, 无论是在block中还是 block外访问</strong>block变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个__block变量。</p><p>五、<strong>防止 Block 循环引用</strong></p><p>Block 循环引用的情况：<br>某个类将 block 作为自己的属性变量，然后该类在 block 的方法体里面又使用了该类本身，如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.someBlock = ^(<span class="keyword">Type</span> <span class="built_in">var</span>)&#123;</span><br><span class="line">    <span class="meta">[</span><span class="built_in">self</span> dosomething<span class="meta">]</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>（1）ARC 下：使用 __weak</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(<span class="built_in">self</span>) weakSelf = <span class="built_in">self</span>;</span><br><span class="line"><span class="built_in">self</span>.someBlock = ^(<span class="keyword">Type</span> <span class="built_in">var</span>)&#123;</span><br><span class="line">   <span class="meta">[</span>weakSelf dosomething<span class="meta">]</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）MRC 下：使用 __block</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__block</span> typeof(<span class="keyword">self) </span><span class="keyword">blockSelf </span>= <span class="keyword">self;</span></span><br><span class="line"><span class="keyword">self.someBlock </span>= ^(Type var)&#123;</span><br><span class="line">   [<span class="keyword">blockSelf </span>dosomething]<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在ARC下，使用 __block 也有可能带来的循环引用，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用 self -&gt; _attributBlock -&gt; tmp -&gt; self</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)();</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObj</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Block _attributBlock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObj</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    __block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.attributBlock = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Self = %@"</span>,tmp);</span><br><span class="line">        tmp = <span class="literal">nil</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">    <span class="keyword">self</span>.attributBlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类</span></span><br><span class="line"><span class="keyword">id</span> obj = [[TestObj alloc] init];</span><br><span class="line">[obj execBlock]; <span class="comment">// 如果不调用此方法，tmp 永远不会置 nil，内存泄露会一直在</span></span><br></pre></td></tr></table></figure><p>六、<strong>Block的使用示例</strong></p><p>1、Block作为变量（Xcode快捷键：inlineBlock）</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^<span class="keyword">sum</span>) (<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个 Block 变量 sum</span></span><br><span class="line"><span class="comment">// 给 Block 变量赋值</span></span><br><span class="line"><span class="comment">// 一般 返回值省略：sum = ^(int a,int b)…</span></span><br><span class="line"><span class="keyword">sum</span> = ^<span class="keyword">int</span> (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;  </span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;; <span class="comment">// 赋值语句最后有 分号</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">sum</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 调用 Block 变量</span></span><br></pre></td></tr></table></figure><p>2、Block作为属性（Xcode 快捷键：typedefBlock）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 给  Calculate 类型 sum变量 赋值「下定义」</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^Calculate)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// calculate就是类型名</span></span><br><span class="line">Calculate sum = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123; </span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a = sum(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 调用 sum变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 作为对象的属性声明，copy 后 block 会转移到堆中和对象一起</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) Calculate sum;    <span class="comment">// 使用   typedef</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">int</span> (^sum)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 不使用 typedef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明，类外</span></span><br><span class="line"><span class="keyword">self</span>.sum = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用，类内</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">self</span>.sum(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>3、作为 OC 中的方法参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---- 无参数传递的 Block ---------------------------</span></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)testTimeConsume:(<span class="keyword">void</span>(^)())middleBlock &#123;</span><br><span class="line">    <span class="comment">// 执行前记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> startTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    middleBlock();</span><br><span class="line">    <span class="comment">// 执行后记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> endTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">return</span> endTime - startTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">[<span class="keyword">self</span> testTimeConsume:^&#123;</span><br><span class="line">       <span class="comment">// 放入 block 中的代码 </span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 有参数传递的 Block ---------------------------</span></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)testTimeConsume:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> * name))middleBlock &#123;</span><br><span class="line">    <span class="comment">// 执行前记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> startTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSString</span> *name = <span class="string">@"有参数"</span>;</span><br><span class="line">    middleBlock(name);</span><br><span class="line">    <span class="comment">// 执行后记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> endTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">[<span class="keyword">self</span> testTimeConsume:^(<span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">   <span class="comment">// 放入 block 中的代码，可以使用参数 name</span></span><br><span class="line">   <span class="comment">// 参数 name 是实现代码中传入的，在调用时只能使用，不能传值    </span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>4、<strong>Block回调</strong></p><p>Block回调是关于Block最常用的内容，比如网络下载，我们可以用Block实现下载成功与失败的反馈。开发者在block没发布前，实现回调基本都是通过代理的方式进行的，比如负责网络请求的原生类NSURLConnection类，通过多个协议方法实现请求中的事件处理。而在最新的环境下，使用的NSURLSession已经采用block的方式处理任务请求了。各种第三方网络请求框架也都在使用block进行回调处理。这种转变很大一部分原因在于block使用简单，逻辑清晰，灵活等原因。</p><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DownloadManager.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadManager</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// block 重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^DownloadHandler)(<span class="built_in">NSData</span> * receiveData, <span class="built_in">NSError</span> * error);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadWithURL:(<span class="built_in">NSString</span> *)URL parameters:(<span class="built_in">NSDictionary</span> *)parameters handler:(DownloadHandler)handler ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DownloadManager.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DownloadManager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DownloadManager</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadWithURL:(<span class="built_in">NSString</span> *)URL parameters:(<span class="built_in">NSDictionary</span> *)parameters handler:(DownloadHandler)handler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> * request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:URL]];</span><br><span class="line">    <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行请求任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> * task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                handler(data,error);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面通过封装NSURLSession的请求，传入一个处理请求结果的block对象，就会自动将请求任务放到工作线程中执行实现，我们在网络请求逻辑的代码中调用如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)buttonClicked:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="meta">#define DOWNLOADURL @<span class="meta-string">"https://codeload.github.com/AFNetworking/AFNetworking/zip/master"</span></span></span><br><span class="line">    <span class="comment">//下载类</span></span><br><span class="line">    DownloadManager * downloadManager = [[DownloadManager alloc] init];</span><br><span class="line">    [downloadManager downloadWithURL: DOWNLOADURL parameters:<span class="literal">nil</span> handler:^(<span class="built_in">NSData</span> *receiveData, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"下载失败：%@"</span>,error);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"下载成功，%@"</span>,receiveData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加深理解，再来一个简单的小例子：</p><p>A，B两个界面，A界面中有一个label，一个buttonA。点击buttonA进入B界面，B界面中有一个UITextfield和一个buttonB，点击buttonB退出B界面并将B界面中UITextfield的值传到A界面中的label。</p><p>A界面中，也就是ViewController类中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键demo：</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttonAction &#123;  </span><br><span class="line">    MyFirstViewController *myVC = [[MyFirstViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:myVC animated:<span class="literal">YES</span> completion:^&#123;    </span><br><span class="line">    &#125;];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;<span class="comment">//防止循环引用</span></span><br><span class="line"><span class="comment">//用属性定义的注意：这里属性是不会自动补全的，方法就会自动补全</span></span><br><span class="line">    [myVC setBlock:^(<span class="built_in">NSString</span> *string)&#123;</span><br><span class="line">        weakSelf.labelA.text = string;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B界面中，也就是MyFirstViewController类中.m文件:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)<span class="keyword">buttonBAction </span>&#123;</span><br><span class="line">    [self <span class="keyword">dismissViewControllerAnimated:YES </span>completion:^&#123;</span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">      self.<span class="keyword">block(_myTextfielf.text);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>.h文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef定义一下block，为了更好用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^MyBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyFirstViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MyBlock block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>看了以上两个Block回调示例，是不是感觉比delegate清爽了不少？</p><p><em>PS：Block是个值得深入学习的东西，这篇文章整整花了峰哥两天时间整理，但是觉得很值得~</em></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>@property参数详解</title>
      <link href="/article/453/"/>
      <url>/article/453/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>@property参数</strong></p><p>1、第一组<br>内存管理特性：retain assign copy strong weak unsafe_unretained autoreleasing</p><p>2、第二组<br>读 /写特性：readwrite readonly</p><p>3、第三组<br>多线程特性：nonatomic atomic</p><p>4、第四组<br>方法名特性：setter getter</p><p>二、<strong>参数作用</strong></p><p>1、第一组（retain assign copy strong weak unsafe_unretained autoreleasing）用于：set方法内存管理</p><p>assign（默认参数）：setter方法直接赋值，不进行任何retain操作，不改变引用计数。该方法只会针对“纯量类型”(CGFloat或NSInteger等)和C数据类型（int, float, double, char, 等等）的简单赋值操作，id类型也要用assign，所以一般iOS中的代理delegate属性都会用assign来标示。</p><p>retain：生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量。</p><p>copy：生成符合内存管理的set方法（release旧值，copy新值），适用于NSString、NSArray等不可变对象。和strong类似，不过该属性会被复制一个新的副本。很多时候使用copy是为了防止Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。</p><p>strong：强引用，其存亡直接决定了所指向对象的存亡。使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，即引用计数+1。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。适用于一般OC对象。</p><p>weak：表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被置为nil。weak引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到weak。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。相比于assign，声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为 nil。这样的好处能有效的防止野指针。因为ViewController对控件强引用，如果delegate声明为strong，UI控件代理一般指向ViewController本身，那么就会造成循环引用。不过非UI控件的delegate的属性声明是weak还是strong就要视情况而定。一般iOS的ARC中的代理delegate属性都会用weak，<strong>有时候</strong>也用于UI控件(如果是懒加载则必须用strong)。<br>[successbox title=”UI控件到底用weak还是strong？”]</p><p>1、从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了如下的引用关系,以UIButton为例：<br>UIViewController-&gt;UIView-&gt;subView-&gt;UIButton<br>然后你为这个UIButton声明一个weak属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) IBOOutlet UIButton *btn;</span><br></pre></td></tr></table></figure><p>相当于xib/sb对这个Button是强引用，你声明的属性对它是弱引用。</p><p>2、代码创建控件<br>（a）将控件声明成strong</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) UIButton *btn;</span><br></pre></td></tr></table></figure><p>那么你在实现这个控件时只需这样：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_btn = <span class="comment">[<span class="comment">[UIButton alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[self.view addSubview:_btn]</span></span><br></pre></td></tr></table></figure><p>（b）将控件声明成weak</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) UIButton *btn;</span><br></pre></td></tr></table></figure><p>那么你在实现这个控件时需要这样：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">UIButton</span> *<span class="keyword">button </span>= [[UIButton alloc]init]<span class="comment">;</span></span><br><span class="line"><span class="symbol">_btn</span> = <span class="keyword">button;</span></span><br><span class="line"><span class="keyword">[self.view </span><span class="keyword">addSubview:_btn];</span></span><br></pre></td></tr></table></figure><p>[/successbox]</p><p>[successbox title=”Delegate到底用weak还是assign？”]</p><p>为了在 Delegate 关系中防止强引用循环。在 ARC 特性下，通常我们应该设置 Delegate 属性为 weak 的。但是这里有一个疑问，我们常用到的 UITableView 的 delegate 属性是这样定义的： @property (nonatomic, assign) id<uitableviewdelegate> delegate;，为什么用的修饰符是 assign 而不是 weak？其实这个 assign 在 ARC 中意义等同于 __unsafe_unretaied（后面会讲到），它是为了在 ARC 特性下兼容 iOS4 及更低版本来实现弱引用机制。一般情况下，你应该<strong>尽量使用 weak</strong>。</uitableviewdelegate></p><p>[/successbox]</p><p>unsafe_unretained：和weak一样，唯一的区别就是当对象被释放后，该属性不会被设置为nil，当该对象指针指向的内存地址被释放后，如果我们没有将其设置为nil，则在调用时会造成野指针，因为指向的内存释放了，所以是unsafe的，访问野指针的内存就造成crash， 所以尽量少用。</p><p>注意：</p><p>（1）weak与Strong一般在开启ARC机制下使用</p><p>（2）Strong决定了对象的存亡（一个对象如果没有强指针指向（引用计数器为0）时，对象将被销毁，释放内存），其指向一个对象，相当于该对象做了一次retain操作。</p><p>非ARC的retain，相当于ARC的strong，ARC的弱引用weak相当于非ARC的assign</p><p>使用copy参数与使用retain参数产生的set方法一致（将生成set方法中的retain改为copy即可）</p><p>strong,weak, unsafe_unretained往往都是用来声明属性的，如果想声明临时变量就得用<strong>strong, </strong>weak, <strong>unsafe_unretained, </strong>autoreleasing, 其用法与上面介绍的类似。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSString</span> *yourString = <span class="string">@"Your String"</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *myString = yourString;</span><br><span class="line"></span><br><span class="line">yourString = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *theirString = myString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在所有的指针都为nil</span></span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSString</span> *yourString = <span class="string">@"Your String"</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *myString = yourString;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *theirString = myString;</span><br><span class="line"></span><br><span class="line">yourString = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在yourString与myString的指针都为nil,而theirString不为nil,但是是野指针。</span></span><br></pre></td></tr></table></figure><p><strong>autoreleasing：在c/c++，objective-c内存管理中有一条是：谁分配谁释放。 </strong>autoreleasing则可以使对像延迟释放。比如你想传一个未初始 化地对像引用到一个方法当中，在此方法中实例化此对像，那么这种情况将是__autoreleasing表演的时候。例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) generateErrorInVariable:(__autoreleasing <span class="built_in">NSError</span> **)paramError&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *objects = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"A simple error"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *keys = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="built_in">NSLocalizedDescriptionKey</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *errorDictionary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjects:objects forKeys:keys];</span><br><span class="line"></span><br><span class="line">    *paramError = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="string">@"MyApp"</span>code:<span class="number">1</span> userInfo:errorDictionary];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)test&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> generateErrorInVariable:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error = %@"</span>, error);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样即便在函数内部申请的空间，在函数外部也可以使用，同样也适合谁分配谁释放的原则。</p><p>同样下面的代码也是类似原因, 只不过在没有开启ARC的情况下适用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)stringTest</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *retStr = [<span class="built_in">NSString</span> stringWithString:<span class="string">@"test"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>[[retStr <span class="keyword">retain</span>] autorelease];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启ARC后，应改为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)stringTest</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    __autoreleasing <span class="built_in">NSString</span> *retStr = [<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、第二组（readwrite readonly）用于：是否要生成set方法</p><p>readwrite（默认参数）：同时生成set、get方法的声明与实现，可读、可写</p><p>readonly：只生成get方法的声明与实现（不生成set的方法的声明与实现），只读</p><p>3、第三组（nonatomic atomic）用于：多线程管理</p><p>atomic（默认参数）：原子性，性能低（一般开发OC中的APP不推荐使用，做金融等要求高安全的时候使用）</p><p>nonatomic：非原子性，性能高（强烈推荐使用，性能高）</p><p>atomic：（原子性操作），会被加锁，就是一个操作执行过程不能被中断,要不就执行完,要不就不执行（一个操作不可以在中途被cpu暂停然后调度）。如果一个操作是原子性的,那么在多线程环境下,就不会出现变量被修改等奇怪的问题（保证数据同步）。原子操作就是不可再分的操作，在多线程程序中原子操作是一个非常重要的概念，它常常用来实现一些同步机制，同时也是一些常见的多线程Bug的源头。</p><p>nonatomic：（非原子性操作）操作是直接从内存中取数值（不考虑其是否被占用），因为它是从内存中取得数据，它并没有一个加锁的保护来用于cpu中的寄存器计算Value，它只是单纯的从内存地址中，当前的内存存储的数据结果来进行使用。在多线程环境下可提高性能，但无法保证数据同步。</p><p>4、第四组（setter getter）用于：set、get方法重命名（常用于BOOL类型的成员变量的get方法,BOOL方法常以is开头（set方法很少用））</p><p>setter：给成员变量的set方法重命名，set方法默认命名：- （void） set成员变量名（成员变量名首字母大写）：（成员变量数据类型）成员变量名。</p><p>getter：给成员变量的set方法重命名，get方法默认命名：- （成员变量数据类型） 成员变量名。<br>synthesize ：合成访问器方法，实现property所声明的方法的定义。其实说直白就像是：property声明了一些成员变量的访问方法，synthesize则定义了由property声明的方法。</p><p>他们之前的对应关系是:property 声明方法 -&gt;头文件中申明getter和setter方法 synthesize定义方法 -&gt; m文件中实现getter和setter方法。在.m文件中同时实现getter和setter时候需要@synthesize age = _age。</p><p>在Xcode4.5及以后的版本中，可以省略@synthesize，编译器会自动帮你加上get 和 set 方法的实现，并且默认会去访问_age这个成员变量，如果找不到_age这个成员变量，会自动生成一个叫做 _age的私有成员变量。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> @property </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之七：拾遗</title>
      <link href="/article/404/"/>
      <url>/article/404/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>这是峰哥最后一篇iOS Runtime总结，前面几篇的博文通过浅显易懂的描述涵盖了大部分知识点，相信有人会发现我的所有博文都是使用一种非常易懂的语言描述，没有那些高大上但难以理解的词汇，我整理iOS Runtime也是对自己学习的一个总结。这里还有几个重要但琐碎的知识点，就不像前面那样详细总结了。</p><p>二、<strong>其他知识点</strong></p><p>1、super</p><p>在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到super，如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MyViewController</span>: UIViewController</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> MyViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>如何使用super我们都知道。现在的问题是，它是如何工作的呢？</p><p>首先我们需要知道的是super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义：</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123; id receiver; Class superClass; &#125;;</span><br></pre></td></tr></table></figure><p>这个结构体有两个成员：</p><p>（1）receiver：即消息的实际接收者</p><p>（2）superClass：指针当前类的父类</p><p>当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。</p><p>接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper ( <span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ... );</span><br></pre></td></tr></table></figure><p>该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&gt;receiver去调用这个selector，而此时的操作就是如下方式了：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">objc_msgSend</span>(objc_super-&gt;receiver, <span class="variable">@selector</span>(viewDidLoad))</span><br></pre></td></tr></table></figure><p>由于objc_super-&gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">objc_msgSend</span>(self, <span class="variable">@selector</span>(viewDidLoad))</span><br></pre></td></tr></table></figure><p>为了便于理解，我们看以下实例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">MyClass </span>: NSObject</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> MyClass</span><br><span class="line">- (void)test &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"self class: %@"</span>, self.class);</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"super class: %@"</span>, super.class);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>调用MyClass的test方法后，其输出是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">00</span>:<span class="number">44</span>:<span class="number">03.256</span> [<span class="number">824</span>:<span class="number">209297</span>] self <span class="class"><span class="keyword">class</span>: <span class="type">MyClass</span></span></span><br><span class="line"><span class="number">2016</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">00</span>:<span class="number">44</span>:<span class="number">03.256</span> [<span class="number">824</span>:<span class="number">209297</span>] <span class="keyword">super</span> <span class="class"><span class="keyword">class</span>: <span class="type">MyClass</span></span></span><br></pre></td></tr></table></figure><p>从上例中可以看到，两者的输出都是MyClass。</p><p>2、库相关的操作</p><p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的Objective-C框架和动态库的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> ** <span class="title">objc_copyImageNames</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">class_getImageName</span> <span class="params">( Class cls )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> ** <span class="title">objc_copyClassNamesForImage</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br></pre></td></tr></table></figure><p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"获取指定类所在动态库"</span>)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"UIView's Framework: %s"</span>, class_getImageName(<span class="name">NSClassFromString</span>(@<span class="string">"UIView"</span>)))<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"获取指定库或框架中所有类的类名"</span>)<span class="comment">;</span></span><br><span class="line">const char ** classes = objc_copyClassNamesForImage(<span class="name">class_getImageName</span>(<span class="name">NSClassFromString</span>(@<span class="string">"UIView"</span>)), <span class="symbol">&amp;outCount</span>)<span class="comment">;</span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; outCount; i++) &#123;</span></span><br><span class="line">    NSLog(@<span class="string">"class name: %s"</span>, classes[i])<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.689</span> [<span class="number">747:184013</span>] 获取指定类所在动态库</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.690</span> [<span class="number">747:184013</span>] UIView's Framework: /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.690</span> [<span class="number">747:184013</span>] 获取指定库或框架中所有类的类名</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.691</span> [<span class="number">747:184013</span>] class name: UIKeyboardPredictiveSettings</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.691</span> [<span class="number">747:184013</span>] class name: _UIPickerViewTopFrame</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.691</span> [<span class="number">747:184013</span>] class name: _UIOnePartImageView</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.692</span> [<span class="number">747:184013</span>] class name: _UIPickerViewSelectionBar</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.692</span> [<span class="number">747:184013</span>] class name: _UIPickerWheelView</span><br><span class="line"><span class="number">2016-12-27</span> <span class="number">00</span>:<span class="number">47:32.692</span> [<span class="number">747:184013</span>] class name: _UIPickerViewTestParameters</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>3、块操作</p><p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span> <span class="params">( id block )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span> <span class="params">( IMP anImp )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span> <span class="params">( IMP anImp )</span></span>;</span><br></pre></td></tr></table></figure><p>imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="string">MyRuntimeBlock :</span> NSObject</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"><span class="meta">@implementation</span> MyRuntimeBlock</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">IMP imp = imp_implementationWithBlock(^(id obj, NSString *str) &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, str);</span><br><span class="line">&#125;);</span><br><span class="line">class_addMethod(MyRuntimeBlock.<span class="keyword">class</span>, <span class="meta">@selector</span>(<span class="string">testBlock:</span>), imp, <span class="string">"v@:@"</span>);</span><br><span class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</span><br><span class="line">[runtime <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">testBlock:</span>) <span class="string">withObject:</span>@<span class="string">"hello world!"</span>];</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016<span class="selector-tag">-12-27</span> 00<span class="selector-pseudo">:49</span><span class="selector-pseudo">:19.779</span> <span class="selector-attr">[1172:395446]</span> <span class="selector-tag">hello</span> <span class="selector-tag">world</span>!</span><br></pre></td></tr></table></figure><p>4、弱引用操作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载弱引用指针引用的对象并返回</span></span><br><span class="line"><span class="keyword">id</span> objc_loadWeak ( <span class="keyword">id</span> *location );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储__weak变量的新值</span></span><br><span class="line"><span class="keyword">id</span> objc_storeWeak ( <span class="keyword">id</span> *location, <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure><p>objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。</p><p>objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。</p><p>5、宏定义</p><p>在runtime中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示BOOL值的YES/NO；而有些值不常用，如OBJC_ROOT_CLASS。在此我们做一个简单的介绍：</p><p>（1）布尔值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YES  (BOOL)1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO   (BOOL)0</span></span><br></pre></td></tr></table></figure><p>这两个宏定义定义了表示布尔值的常量，需要注意的是YES的值是1，而不是非0值。</p><p>（2）空值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nil  __DARWIN_NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Nil  __DARWIN_NULL</span></span><br></pre></td></tr></table></figure><p>其中nil用于空的实例对象，而Nil用于空类对象。</p><p>（3）分发函数原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_OLD_DISPATCH_PROTOTYPES  1</span></span><br></pre></td></tr></table></figure><p>该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换</p><p>（4）Objective-C根类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_ROOT_CLASS</span></span><br></pre></td></tr></table></figure><p>如果我们定义了一个Objective-C根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。</p><p>其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)</span><br><span class="line">OBJC_ROOT_CLASS</span><br><span class="line">OBJC_EXPORT</span><br><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以参考这种方式来定义我们自己的根类。</p><p>（5）局部变量存储时长</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_VALID_UNTIL_END_OF_SCOPE</span></span><br></pre></td></tr></table></figure><p>该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。</p><p>我们将局部变量标记为id类型或者是指向ObjC对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之六：Method Swizzling</title>
      <link href="/article/400/"/>
      <url>/article/400/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>Objective-C 中的 Method Swizzling 是一项异常强大的技术，它可以允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。</p><p>Method Swizzling 是一把双刃剑，使用得当可以让我们非常轻松地实现复杂的功能，而如果一旦误用，它也很可能会给我们的程序带来毁灭性的伤害。但是我们不能因噎废食，当我们理解了Method Swizzling原理之后，它将会变成我们强大的武器。</p><p>二、<strong>Method Swizzling 的原理</strong></p><p>在上篇博文中我们讲过在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。所以下面两个方法在 runtime 看来就是同一个方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>viewWillAppear:<span class="params">(BOOL)</span>animated;</span><br><span class="line">- <span class="params">(void)</span>viewWillAppear:<span class="params">(NSString *)</span>string;</span><br></pre></td></tr></table></figure><p>而下面两个方法却是可以共存的：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>viewWillAppear:<span class="params">(BOOL)</span>animated;</span><br><span class="line">+ <span class="params">(void)</span>viewWillAppear:<span class="params">(BOOL)</span>animated;</span><br></pre></td></tr></table></figure><p>因为实例方法和类方法是分别保存在类对象和元类对象中的。</p><p>原则上，方法的名称 <code>name</code> 和方法的实现 <code>imp</code> 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。如下图所示：</p><p>[caption id=”attachment_401” align=”alignnone” width=”600”]<img src="/images/2016/12/270478-efc2eea5e79a172f.png" alt="270478-efc2eea5e79a172f"> 图一[/caption]</p><p>[caption id=”attachment_402” align=”alignnone” width=”600”]<img src="/images/2016/12/270478-998fcd4ad6c248da.png" alt="270478-998fcd4ad6c248da"> 图二[/caption]</p><p>上面图一中selector2原本对应着IMP2，但是为了更方便的实现特定业务需求，我们在图二中添加了selector3和IMP3，并且让selector2指向了IMP3，而selector3则指向了IMP2，这样就实现了“方法互换”。</p><p>在OC语言的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP(一个IMP可以对应多个SEL)，通过这个IMP找到对应的方法调用。</p><p>在每个类中都有一个Dispatch Table，这个Dispatch Table本质是将类中的SEL和IMP(可以理解为函数指针)进行对应。而我们的Method Swizzling就是对这个table进行了操作，让SEL对应另一个IMP。</p><p>三、<strong>Method Swizzling使用</strong></p><p>想必大家都用过友盟统计，我们需要在每个页面的 view controller 中添加如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillAppear:</span>(BOOL)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillAppear:</span>animated];</span><br><span class="line">    [MobClick <span class="string">beginLogPageView:</span>@<span class="string">"PageOne"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillDisappear:</span>(BOOL)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillDisappear:</span>animated];</span><br><span class="line">    [MobClick <span class="string">endLogPageView:</span>@<span class="string">"PageOne"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最简单的方法，直接简单粗暴的在每个控制器中加入统计，复制、粘贴、复制、粘贴…<br>实际上非常不建议使用这种方法的，不仅消耗时间而且以后非常难以维护。那我们有其他什么好的办法吗？</p><p>当然我们还可以用以下两种方法：</p><p>（1）直接修改每个页面的 view controller 代码，简单粗暴。</p><p>（2）子类化 view controller ，并让我们的 view controller 都继承这些子类。</p><p>第 1 种方式的缺点是不仅会产生大量重复的代码，而且还很容易遗漏某些页面，非常难维护；第 2 种方式稍微好一点，但是也同样需要我们子类化 UIViewController 、UITableViewController 和 UITabBarController 等不同类型的 view controller 。</p><p>除此之外还有什么比较简单优雅的解决方案吗？答案是肯定的，Method Swizzling 就是解决此类问题的最佳方式。</p><p>在实现Method Swizzling时，核心代码主要就是一个runtime的C语言API：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BJC_EXPORT void method_exchangeImplementations(<span class="function"><span class="keyword">Method</span> <span class="title">m1</span>, <span class="title">Method</span> <span class="title">m2</span>) </span></span><br><span class="line"><span class="function"> __<span class="title">OSX_AVAILABLE_STARTING</span><span class="params">(__MAC_10_5, __IPHONE_2_0)</span>;</span></span><br></pre></td></tr></table></figure><p>下面我们通过<code>Method Swizzling</code>简单的实现上面那个添加统计的需求。</p><p>我们先给UIViewController添加一个Category，然后在Category中的+(void)load方法中添加Method Swizzling方法，我们用来替换的方法也写在这个Category中。由于load类方法是程序运行时这个类被加载到内存中就调用的一个方法，执行比较早，并且不需要我们手动调用。而且这个方法具有唯一性，也就是只会被调用一次，不用担心资源抢夺的问题。</p><p>定义Method Swizzling中我们自定义的方法时，需要注意尽量加前缀，以防止和其他地方命名冲突，Method Swizzling的替换方法命名一定要是唯一的，至少在被替换的类中必须是唯一的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"UIViewController+swizzling.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">swizzling</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// 通过class_getInstanceMethod()函数从当前对象中的method list获取method结构体，如果是类方法就使用class_getClassMethod()函数获取。</span></span><br><span class="line">    Method fromMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidLoad));</span><br><span class="line">    Method toMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzlingViewDidLoad));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  我们在这里使用class_addMethod()函数对Method Swizzling做了一层验证，如果self没有实现被交换的方法，会导致失败。</span></span><br><span class="line"><span class="comment">     *  而且self没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。</span></span><br><span class="line"><span class="comment">     *  所以我们在这里通过class_addMethod()的验证，如果self实现了这个方法，class_addMethod()函数将会返回NO，我们就可以对其进行交换了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzlingViewDidLoad), method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) &#123;</span><br><span class="line">        method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己实现的方法，也就是和self的viewDidLoad方法进行交换的方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)swizzlingViewDidLoad &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="keyword">self</span>.class];</span><br><span class="line">    <span class="comment">// 我们在这里加一个判断，将系统的UIViewController的对象剔除掉</span></span><br><span class="line">    <span class="keyword">if</span>(![str containsString:<span class="string">@"UI"</span>])&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"统计打点 : %@"</span>, <span class="keyword">self</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> swizzlingViewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>不知道大家注意没有，swizzlingViewDidLoad方法中又调用了[self swizzlingViewDidLoad];，这难道不会产生递归调用吗？</p><p>实际上是不会的，Method Swizzling的实现原理可以理解为”方法互换“。假设我们将A和B两个方法进行互换，向A方法发送消息时执行的却是B方法，向B方法发送消息时执行的是A方法。</p><p>例如我们上面的代码，系统调用UIViewController的viewDidLoad方法时，实际上执行的是我们实现的swizzlingViewDidLoad方法。而我们在swizzlingViewDidLoad方法内部调用[self swizzlingViewDidLoad];时，执行的是UIViewController的viewDidLoad方法。</p><p>四、<strong>Method Swizzling类簇</strong></p><p>在我们项目开发过程中，经常因为NSArray数组越界或者NSDictionary的key或者value值为nil等问题导致的崩溃，我们可以尝试使用前面知识对NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等类进行Method Swizzling，但是结果发现Method Swizzling根本就不起作用，到底为什么呢？</p><p>这是因为Method Swizzling对NSArray这些的类簇是不起作用的。因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex:方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。</p><p>所以也就是我们对NSArray类进行操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。</p><p>下面我们实现了防止NSArray因为调用objectAtIndex:方法，取下标时数组越界导致的崩溃：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+ MyArray.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"objc/runtime.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> <span class="title">MyArray</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    Method fromMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(objectAtIndex:));</span><br><span class="line">    Method toMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(my_objectAtIndex:));</span><br><span class="line">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)my_objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count<span class="number">-1</span> &lt; index) &#123;</span><br><span class="line">        <span class="comment">// 这里做一下异常处理，不然都不知道出错了。</span></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> my_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// 在崩溃后会打印崩溃信息，方便我们调试。</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"---------- %s Crash Because Method %s  ----------\n"</span>, class_getName(<span class="keyword">self</span>.class), __func__);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [exception callStackSymbols]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">@finally</span> &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> my_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说__NSArrayI才是NSArray真正的类。我们可以通过runtime函数获取真正的类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_getClass</span><span class="params">(<span class="string">"__NSArrayI"</span>)</span></span></span><br></pre></td></tr></table></figure><p>下面我们列举一些常用的类簇的“真身”：</p><p><img src="/images/2016/12/Snip20161227_1.png" alt="snip20161227_1"></p><p>五、<strong>Method Swizzling使用注意事项</strong></p><p>1、Swizzling应该总是在+load中执行 </p><p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p><p>2、Swizzling应该总是在dispatch_once中执行</p><p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p><p>3、Method Swizzling有成熟的第三方框架可用</p><p>在项目中我们肯定会在很多地方用到<code>Method Swizzling</code>，而且在使用这个特性时有很多需要注意的地方。我们可以将<code>Method Swizzling</code>封装起来，也可以使用一些比较成熟的第三方。<br>在这里我推荐<strong>Github</strong>上星最多的一个第三方－<a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">jrswizzle</a></p><p>里面核心就两个类，代码看起来非常清爽。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JRSwizzle</span>)</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)jr_swizzleMethod:(SEL)origSel_ withMethod:(SEL)altSel_ error:(<span class="built_in">NSError</span>**)error_;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)jr_swizzleClassMethod:(SEL)origSel_ withClassMethod:(SEL)altSel_ error:(<span class="built_in">NSError</span>**)error_;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MethodSwizzle类</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/objc.h&gt;</span></span></span><br><span class="line"><span class="built_in">BOOL</span> ClassMethodSwizzle(Class klass, SEL origSel, SEL altSel);</span><br><span class="line"><span class="built_in">BOOL</span> MethodSwizzle(Class klass, SEL origSel, SEL altSel);</span><br></pre></td></tr></table></figure><p>具体使用方法大家自己研究。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> Method Swizzling </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之五：方法与消息</title>
      <link href="/article/398/"/>
      <url>/article/398/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>基础数据类型</strong></p><p>1、SEL</p><p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure><p>方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。如下代码所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEL sel1 = <span class="meta">@selector(method1)</span>;</span><br><span class="line">NSLog(@<span class="string">"sel : %p"</span>, sel1);</span><br></pre></td></tr></table></figure><p>上面的输出为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016<span class="selector-tag">-12-25</span> 23<span class="selector-pseudo">:40</span><span class="selector-pseudo">:07.518</span> <span class="selector-tag">RuntimeTest</span><span class="selector-attr">[52734:466626]</span> <span class="selector-tag">sel</span> : 0<span class="selector-tag">x100002d72</span></span><br></pre></td></tr></table></figure><p><strong>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的</strong>。<strong>每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行</strong>。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">int</span>)<span class="built_in">width</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)<span class="built_in">width</span>;</span><br></pre></td></tr></table></figure><p>这样的定义被认为是一种编译错误，所以我们不能像C++, JAVA那样。而是需要像下面这样来声明：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setWidthIntValue:(<span class="keyword">int</span>)<span class="built_in">width</span>;</span><br><span class="line">-(<span class="keyword">void</span>)setWidthDoubleValue:(<span class="keyword">double</span>)<span class="built_in">width</span>;</span><br></pre></td></tr></table></figure><p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</p><p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p><p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p><p>（1）sel_registerName函数</p><p>（2）Objective-C编译器提供的@selector()</p><p>（3）NSSelectorFromString()方法</p><p>2、IMP</p><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (<span class="name">*IMP</span>)(<span class="name">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure><p>这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。</p><p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p><p>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p><p>3、Method</p><p>Method用于表示类定义中的方法，定义如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line">struct objc_method <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名</span></span><br><span class="line"><span class="comment">    char *method_types                  OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p><p>4、objc_method_description</p><p>objc_method_description定义了一个Objective-C方法，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span> SEL name; <span class="keyword">char</span> *types; &#125;;</span><br></pre></td></tr></table></figure><p>二、<strong>方法相关操作函数</strong></p><p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。</p><p>1、方法操作相关函数</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现</span></span><br><span class="line">id method_invoke ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></span><br><span class="line">void method_invoke_stret ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">SEL method_getName ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line">IMP method_getImplementation ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="keyword">const</span> char * method_getTypeEncoding ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line">char * method_copyReturnType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line">char * method_copyArgumentType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">index</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line">void method_getReturnType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">char</span> *<span class="title">dst</span>, <span class="title">size_t</span> <span class="title">dst_len</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line">unsigned int method_getNumberOfArguments ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line">void method_getArgumentType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">index</span>, <span class="title">char</span> *<span class="title">dst</span>, <span class="title">size_t</span> <span class="title">dst_len</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line">struct objc_method_description * method_getDescription ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line">IMP method_setImplementation ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">IMP</span> <span class="title">imp</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations ( <span class="function"><span class="keyword">Method</span> <span class="title">m1</span>, <span class="title">Method</span> <span class="title">m2</span> );</span></span><br></pre></td></tr></table></figure><p>其中：</p><p>（1）method_invoke函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比method_getImplementation和method_getName更快。</p><p>（2）method_getName函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用sel_getName(method_getName(method))。</p><p>（3）method_getReturnType函数，类型字符串会被拷贝到dst中。</p><p>（4）method_setImplementation函数，注意该函数返回值是方法之前的实现。</p><p>2、方法选择器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">sel_getName</span> <span class="params">( SEL sel )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_getUid</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="function">BOOL <span class="title">sel_isEqual</span> <span class="params">( SEL lhs, SEL rhs )</span></span>;</span><br></pre></td></tr></table></figure><p>其中：</p><p>sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</p><p>三、<strong>方法调用流程</strong></p><p>1、消息发送</p><p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector)</span></span></span><br></pre></td></tr></table></figure><p>如果消息中还有其它参数，则该方法的形式如下所示：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span>(<span class="params">receiver, selector, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure><p>这个函数完成了动态绑定的所有事情：</p><p>（1）首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</p><p>（2）它调用方法实现，并将接收者对象及方法的所有参数传给它。</p><p>（3）最后，它将实现返回的值作为它自己的返回值。</p><p>消息的关键在于我们前面讨论过的结构体objc_class，这个结构体有两个字段是我们在分发消息的关注的：</p><p>（1）指向父类的指针</p><p>（2）一个类的方法分发表，即methodLists。</p><p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p><p>下图演示了这样一个消息的基本框架：</p><p><img src="/images/2016/12/no5XHEckAMPaXkII.gif" alt="no5xheckampaxkii"></p><p>当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程，这个我们在后面讨论。</p><p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址（前面讲过，这里不再重复）。</p><p>2、隐藏参数</p><p>objc_msgSend有两个隐藏参数：</p><p>（1）消息接收对象</p><p>（2）方法的selector</p><p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</p><p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd来引用选择器。如下代码所示：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    SEL <span class="function"><span class="keyword">method</span> =</span> getTheMethod();</span><br><span class="line">    <span class="keyword">if</span> ( target == <span class="built_in">self</span> || <span class="function"><span class="keyword">method</span> =</span>= _cmd )</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> [target performSelector:<span class="function"><span class="keyword">method</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这两个参数我们用得比较多的是self，_cmd在实际中用得比较少。</p><p>3、获取方法地址</p><p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p><p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p><p>NSObject类提供了methodForSelector:方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将methodForSelector:返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p><p>我们通过以下代码来看看methodForSelector:的使用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target</span><br><span class="line">    methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意的就是函数指针的前两个参数必须是id和SEL。</p><p>当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，methodForSelector:是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p><p>四、<strong>消息转发</strong></p><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</p><p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> ([self <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(method)]) &#123;</span><br><span class="line">    <span class="selector-attr">[self performSelector:@selector(method)]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们这边想讨论下不使用respondsToSelector:判断的情况。这才是我们的重点。</p><p>当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[SUTRuntimeMethod method]: unrecognized selector sent to<span class="built_in"> instance </span>0x100111940</span><br><span class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to<span class="built_in"> instance </span>0x100111940'</span><br></pre></td></tr></table></figure><p>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p><p>消息转发机制基本上分为三个步骤：</p><p>（1）动态方法解析</p><p>（2）备用接收者 </p><p>（3）完整转发 </p><p>下面我们详细讨论一下这三个步骤。</p><p>1、动态方法解析</p><p>对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method1"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种方案更多的是为了实现@dynamic属性。</p><p>2、备用接收者 </p><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id)</span>forwardingTargetForSelector:<span class="params">(SEL)</span>aSelector</span><br></pre></td></tr></table></figure><p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p><p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethodHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethodHelper</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="meta">#pragma mark -</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethod</span> () </span>&#123;</span><br><span class="line">    SUTRuntimeMethodHelper *_helper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethod</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)object &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        _helper = [[SUTRuntimeMethodHelper alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method2)];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="comment">// 将消息转发给_helper来处理</span></span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method2"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> _helper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><p>3、完整转发 </p><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>forwardInvocation:<span class="params">(NSInvocation *)</span>anInvocation</span><br></pre></td></tr></table></figure><p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象。</p><p>forwardInvocation:方法的实现有两个任务：</p><p>（1）定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</p><p>（2）使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</p><p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p><p>还有一个很重要的问题，我们必须重写以下方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(NSMethodSignature *)</span>methodSignatureForSelector:<span class="params">(SEL)</span>aSelector</span><br></pre></td></tr></table></figure><p>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</p><p>完整的示例如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([SUTRuntimeMethodHelper <span class="string">instancesRespondToSelector:</span>aSelector]) &#123;</span><br><span class="line">            signature = [SUTRuntimeMethodHelper <span class="string">instanceMethodSignatureForSelector:</span>aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([SUTRuntimeMethodHelper <span class="string">instancesRespondToSelector:</span>anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p><p>从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p><p>4、消息转发与多重继承</p><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p><p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如respondsToSelector:和isKindOfClass:只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector   &#123;</span><br><span class="line">       <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )         </span><br><span class="line"><span class="built_in">       return</span> YES;     </span><br><span class="line">       <span class="keyword">else</span> &#123;          </span><br><span class="line">       /* Here, test whether <span class="keyword">the</span> aSelector message can     *            </span><br><span class="line">       * be forwarded <span class="keyword">to</span> another object <span class="keyword">and</span> whether <span class="keyword">that</span>  *            </span><br><span class="line">      * object can respond <span class="keyword">to</span> <span class="keyword">it</span>. Return YES <span class="keyword">if</span> <span class="keyword">it</span> can.  */      </span><br><span class="line">       &#125;</span><br><span class="line"><span class="built_in">      return</span> NO;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> 方法与消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之四：关联对象</title>
      <link href="/article/397/"/>
      <url>/article/397/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>如何给NSArray添加一个属性（不能使用继承）？不能用继承，难道用分类？但是分类只能添加方法不能添加属性啊（<strong>Category不允许为已有的类添加新的成员变量，实际上允许添加属性的，同样可以使用@property，但是不会生成_变量（带下划线的成员变量），也不会生成添加属性的getter和setter方法，所以，尽管添加了属性，也无法使用点语法调用getter和setter方法。但实际上可以使用runtime去实现Category为已有的类添加新的属性并生成getter和setter方法</strong>），这篇博文则告诉你方法。</p><p>关联对象是指某个OC对象通过一个唯一的key连接到一个类的实例上。<br>举个例子：xiaoming是Person类的一个实例，他的dog（一个OC对象）通过一根绳子（key）被他牵着散步，这可以说xiaoming和dog是关联起来的，当然xiaoming可以牵着多个dog。</p><p>二、<strong>如何关联对象</strong></p><p>runtime提供给我们的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取关联的对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除关联的对象</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id <span class="keyword">object</span>：被关联的对象（如xiaoming）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *key：关联的key，要求唯一</span><br><span class="line">id <span class="keyword">value</span>：关联的对象（如dog）</span><br><span class="line">objc_AssociationPolicy policy：内存管理的策略</span><br></pre></td></tr></table></figure><p>objc_AssociationPolicy policy的enum值有：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line"></span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    </span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    </span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象被释放时，会根据这个策略来决定是否释放关联的对象，当策略是RETAIN/COPY时，会释放（release）关联的对象，当是ASSIGN，将不会释放。<br>值得注意的是，我们不需要主动调用removeAssociated来接触关联的对象，如果需要解除指定的对象，可以使用setAssociatedObject置nil来实现。</p><p>三、<strong>应用实例（Category添加属性并生成getter和setter方法）</strong></p><p>我们现在来解决峰哥在概述中提出的问题：如何给NSArray添加一个属性（不能使用继承）？</p><p>我们现在为NSArray增加一个blog属性：</p><p>我们先按照往常方式创建一个NSArray的Category，NSArray+MyCategory.h文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NSArray+MyCategory.h</span></span><br><span class="line"><span class="comment">//  RunTimeTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2016/12/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">MyCategory</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不会生成添加属性的getter和setter方法，必须我们手动生成</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *blog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>NSArray+MyCategory.m文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NSArray+MyCategory.m</span></span><br><span class="line"><span class="comment">//  RunTimeTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2016/12/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+MyCategory.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">MyCategory</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义关联的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"blog"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> blog的getter方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)blog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> blog的setter方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setBlog:(<span class="built_in">NSString</span> *)blog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></span><br><span class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></span><br><span class="line">    <span class="comment">// 第三个参数：关联的value</span></span><br><span class="line">    <span class="comment">// 第四个参数:关联的策略</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, blog, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)categoryTest&#123;</span><br><span class="line">    NSArray *myArray = [[NSArray alloc]init]<span class="comment">;</span></span><br><span class="line">    myArray.<span class="keyword">blog </span>= @<span class="string">"http://www.imlifengfeng.com"</span><span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"谁说Category不能添加属性？我用Category为NSArray添加了一个blog属性，blog=%@"</span>,myArray.<span class="keyword">blog);</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016-12-25</span> <span class="number">20</span>:<span class="number">00:37.824</span> RunTimeTest[<span class="number">9447</span>:<span class="number">958867</span>] 谁说Category不能添加属性？我用Category为NSArray添加了一个blog属性，blog=http://www.imlifengfeng.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> Category </tag>
            
            <tag> 关联对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之三：成员变量和属性</title>
      <link href="/article/395/"/>
      <url>/article/395/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>不知道大家有没有想过这么个问题：”成员变量和属性的本质是什么？”，本文则是对该问题的回答。</p><p>上篇博文中已经简单介绍了成员变量和属性的一些操作方法，这篇博文则是对成员变量和属性更深入的学习。</p><p>在讨论之前，我们先介绍一个重要的概念：类型编码。</p><p>二、<strong>类型编码</strong></p><p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以用于@encode()。</p><p><em>注意：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</em></p><p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">NSLog(@<span class="string">"array encoding type: %s"</span>, @encode(typeof(a)));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-12-24 22:53:54.731 RuntimeTest[942:50791]<span class="built_in"> array </span>encoding type: [3f]</span><br></pre></td></tr></table></figure><p>另外，还有些编码类型，@encode虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。</p><p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等。</p><p>三、<strong>成员变量</strong></p><p>1、定义<br>Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                 OBJC2_UNAVAILABLE;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                 OBJC2_UNAVAILABLE;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                 OBJC2_UNAVAILABLE;  <span class="comment">// 基地址偏移字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                       OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、操作函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">ivar_getName</span> <span class="params">( Ivar v )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">ivar_getTypeEncoding</span> <span class="params">( Ivar v )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line"><span class="keyword">ptrdiff_t</span> ivar_getOffset ( Ivar v );</span><br></pre></td></tr></table></figure><p>3、使用实例</p><p>Model的头文件声明如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Model</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">        <span class="built_in">NSString</span> * _str1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> * str2;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> * dict1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>获取其成员变量：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">Ivar * ivars = class_copyIvarList([Model <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">      Ivar ivar = ivars[i];</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> * name = ivar_getName(ivar);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> * type = ivar_getTypeEncoding(ivar);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"类型为 %s 的 %s "</span>,type, name);</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtimeIvar<span class="string">[602:16885]</span> 类型为 @<span class="string">"NSString"</span> 的 _str1 </span><br><span class="line">runtimeIvar<span class="string">[602:16885]</span> 类型为 @<span class="string">"NSString"</span> 的 _str2 </span><br><span class="line">runtimeIvar<span class="string">[602:16885]</span> 类型为 @<span class="string">"NSDictionary"</span> 的 _dict1</span><br></pre></td></tr></table></figure><p>三、<strong>属性</strong></p><p>1、定义<br>objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_property</span> *<span class="title">Property</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_property</span> *<span class="title">objc_property_t</span>;</span><span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure><p>2、操作函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取属性列表，注意：使用class_copyPropertyList并不会获取无@property声明的成员变量</span></span><br><span class="line"><span class="keyword">objc_property_t</span> * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性名  </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> charchar * <span class="title">property_getName</span> <span class="params">( <span class="keyword">objc_property_t</span> property )</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取属性特性描述字符串  </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> charchar * <span class="title">property_getAttributes</span> <span class="params">( <span class="keyword">objc_property_t</span> property )</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取属性中指定的特性  </span></span><br><span class="line"><span class="function">charchar * <span class="title">property_copyAttributeValue</span> <span class="params">( <span class="keyword">objc_property_t</span> property, <span class="keyword">const</span> charchar *attributeName )</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取属性的特性列表  </span></span><br><span class="line"><span class="keyword">objc_property_attribute_t</span> * property_copyAttributeList ( <span class="keyword">objc_property_t</span> property, <span class="keyword">unsigned</span> intint *outCount );</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）class_copyPropertyList、property_copyAttributeList 函数，返回的数组在使用完后一定要调用free()释放，防止内存泄露。</p><p>（2）property_getAttributes函数返回objc_property_attribute_t结构体列表，objc_property_attribute_t结构体包含name和value，常用的属性如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">属性类型  <span class="keyword">name</span>值：T  <span class="keyword">value</span>：变化</span><br><span class="line">编码类型  <span class="keyword">name</span>值：C(copy) &amp;(strong) W(weak) 空(<span class="keyword">assign</span>) 等 <span class="keyword">value</span>：无</span><br><span class="line">非/原子性 <span class="keyword">name</span>值：空(atomic) N(Nonatomic)  <span class="keyword">value</span>：无</span><br><span class="line">变量名称  <span class="keyword">name</span>值：V  <span class="keyword">value</span>：变化</span><br></pre></td></tr></table></figure><p><img src="/images/2016/12/20160126194324825.png" alt="20160126194324825"></p><p>3、使用实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">objc_property_t</span> * properties = class_copyPropertyList([Model class], &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">    <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line">    <span class="comment">//属性名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name = property_getName(property);</span><br><span class="line">    <span class="comment">//属性描述</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * propertyAttr = property_getAttributes(property);</span><br><span class="line">    NSLog(@<span class="string">"属性描述为 %s 的 %s "</span>, propertyAttr, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性的特性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attrCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> * attrs = property_copyAttributeList(property, &amp;attrCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; attrCount; j ++) &#123;</span><br><span class="line">        <span class="keyword">objc_property_attribute_t</span> attr = attrs[j];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * name = attr.name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * value = attr.value;</span><br><span class="line">        NSLog(@<span class="string">"属性的描述：%s 值：%s"</span>, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(attrs);</span><br><span class="line">    NSLog(@<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(properties);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性描述为 T@<span class="string">"NSString"</span>,&amp;,V_str2 的 str2 </span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：T 值：@<span class="string">"NSString"</span></span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：&amp; 值：</span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：V 值：_str2</span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> </span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性描述为 T@<span class="string">"NSDictionary"</span>,C,N,V_dict1 的 dict1 </span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：T 值：@<span class="string">"NSDictionary"</span></span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：C 值：</span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：N 值：</span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span> 属性的描述：V 值：_dict1</span><br><span class="line">runtimeIvar<span class="string">[661:27041]</span></span><br></pre></td></tr></table></figure><p>四、<strong>应用实例</strong></p><p>1、Json到Model的转化</p><p>在开发中相信最常用的就是接口数据需要转化成Model了，也就是所谓的字典转模型（json-&gt;字典-&gt;模型）。很多开发者也都使用著名的第三方库如JsonModel、Mantle或MJExtension等，如果只用而不知其所以然，那真和“搬砖”没啥区别了，下面我们使用runtime去解析json来给Model赋值。</p><p>原理：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。</p><p>具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithDict:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="comment">//(1)获取类的属性及属性对应的类型</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> * keys = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> * attributes = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 例子</span></span><br><span class="line"><span class="comment">         * name = value3 attribute = T@"NSString",C,N,V_value3</span></span><br><span class="line"><span class="comment">         * name = value4 attribute = T^i,N,V_value4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        objc_property_t * properties = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            <span class="comment">//通过property_getName函数获得属性的名字</span></span><br><span class="line">            <span class="built_in">NSString</span> * propertyName = [<span class="built_in">NSString</span> stringWithCString:property_getName(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            [keys addObject:propertyName];</span><br><span class="line">            <span class="comment">//通过property_getAttributes函数可以获得属性的名字和@encode编码</span></span><br><span class="line">            <span class="built_in">NSString</span> * propertyAttribute = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            [attributes addObject:propertyAttribute];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//立即释放properties指向的内存</span></span><br><span class="line">        free(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(2)根据类型给属性赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> * key <span class="keyword">in</span> keys) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([dict valueForKey:key] == <span class="literal">nil</span>) <span class="keyword">continue</span>;</span><br><span class="line">            [<span class="keyword">self</span> setValue:[dict valueForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以进一步思考：<br>（1）如何识别基本数据类型的属性并处理<br>（2）空（nil，null）值的处理<br>（3）json中嵌套json（Dict或Array）的处理<br>尝试解决以上问题，你也能写出属于自己的功能完备的Json转Model库。</p><p>2、快速归档</p><p>有时候我们要对一些信息进行归档，如用户信息类UserInfo，这将需要重写initWithCoder和encodeWithCoder方法，并对每个属性进行encode和decode操作。那么问题来了：当属性只有几个的时候可以轻松写完，如果有几十个属性呢？那不得写到天荒地老？</p><p>原理：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。<br>具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        Ivar * ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            <span class="built_in">NSString</span> * key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [<span class="keyword">self</span> setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSString</span> * key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[<span class="keyword">self</span> valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、访问私有变量</p><p>我们知道，OC中没有真正意义上的私有变量和方法，要让成员变量私有，要放在m文件中声明，不对外暴露。如果我们知道这个成员变量的名称，可以通过runtime获取成员变量，再通过getIvar来获取它的值。<br>方法：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ivar ivar = <span class="keyword">class</span><span class="number">_</span>getInstanceVariable([Model <span class="keyword">class</span>], <span class="string">"_str1"</span>);</span><br><span class="line">NSString * str<span class="number">1</span> = <span class="keyword">object</span><span class="number">_</span>getIvar(model, ivar);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> 属性 </tag>
            
            <tag> 成员变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之二：类与对象的操作</title>
      <link href="/article/392/"/>
      <url>/article/392/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>类与对象的操作函数</strong></p><p>runtime提供了大量的函数来操作类与对象，操作类的函数一般前缀是class，而操作对象的函数一般前缀是objc。</p><p>1、类相关操作函数</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的类名</span><br><span class="line"><span class="keyword">const</span> char * class_getName ( <span class="class"><span class="keyword">Class</span> <span class="title">cls</span> );</span></span><br><span class="line">// 获取类的父类</span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">class_getSuperclass</span> ( <span class="title">Class</span> <span class="title">cls</span> );</span></span><br><span class="line"> </span><br><span class="line">// 判断给定的<span class="class"><span class="keyword">Class</span>是否是一个元类</span></span><br><span class="line">BOOL class_isMetaClass ( <span class="class"><span class="keyword">Class</span> <span class="title">cls</span> );</span></span><br><span class="line">// 获取实例大小</span><br><span class="line">size_t class_getInstanceSize ( <span class="class"><span class="keyword">Class</span> <span class="title">cls</span> );</span></span><br></pre></td></tr></table></figure><p>#### </p><p>2、成员变量相关操作函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意：</p><p>（1）class_copyIvarList：获取的是所有成员实例属性，与property获取不一样。</p><p>（2）class_addIvar:<strong> OC不支持往已存在的类中添加实例变量</strong>，因此不管是系统库提供的类，还是我们自定义的类，都无法动态给它添加成员变量。但，如果是我们通过运行时来创建的类，我们可以使用class_addIvar来添加。不过，需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)testIvar &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    <span class="keyword">if</span>(class_addIvar([Student <span class="keyword">class</span>], <span class="string">"_hell"</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="string">"@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Add Ivar Success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Add Ivar failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Ivar *ivarList = class_copyIvarList([Student <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *ivarName = ivar_getName(ivar);</span><br><span class="line">        ptrdiff_t offset = ivar_getOffset(ivar);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = ivar_getTypeEncoding(ivar);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ivar:%s, offset:%zd, type:%s"</span>, ivarName, offset, types);</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、属性操作函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line"><span class="keyword">objc_property_t</span> * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br></pre></td></tr></table></figure><p>这一种方法也是针对ivar来操作的，不过它只操作那些property的值，包括扩展中的property。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testProperty &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  添加property</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attribute1 = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attribute2 = &#123;<span class="string">"C"</span>, <span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attribute3 = &#123;<span class="string">"N"</span>, <span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attribute4 = &#123;<span class="string">"V"</span>, <span class="string">"_lcg"</span>&#125;;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> attributesList[] = &#123;attribute1, attribute2, attribute3, attribute4&#125;;</span><br><span class="line">    <span class="keyword">if</span>(class_addProperty([Student class], <span class="string">"lcg"</span>, attributesList, <span class="number">4</span>)) &#123;</span><br><span class="line">        NSLog(@<span class="string">"add property success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        NSLog(@<span class="string">"add property failure!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  打印property的name和property_attribute_t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    <span class="keyword">objc_property_t</span> *propertyList = class_copyPropertyList([Student class], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        <span class="keyword">objc_property_t</span> property = propertyList[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *attribute = property_getAttributes(property);</span><br><span class="line">        NSLog(@<span class="string">"propertyName: %s, attribute: %s"</span>, propertyName, attribute);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount;</span><br><span class="line">        <span class="keyword">objc_property_attribute_t</span> *attributeList = property_copyAttributeList(property, &amp;attributeCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; attributeCount; j++) &#123;</span><br><span class="line">            <span class="keyword">objc_property_attribute_t</span> attribute = attributeList[j];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = attribute.name;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *value = attribute.value;</span><br><span class="line">            NSLog(@<span class="string">"attribute name: %s, value: %s"</span>, name, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有几个知识点需要说一下：</p><p>(1) 其中property_attribute的相关内容需要说明下。</p><p>property_attribute为T@”NSString”、&amp;、N、V_exprice时：</p><ol><li>T 是固定的，放在第一个</li></ol><ol start="2"><li>@”NSString” 代表这个property是一个字符串对象</li></ol><ol start="3"><li>&amp; 代表强引用，其中与之并列的是：’C’代表Copy，’&amp;’代表强引用，’W’表示weak，assign为空，默认为assign。</li></ol><ol start="4"><li>N 区分的nonatomic和atomic，默认为atomic，atomic为空，’N’代表是nonatomic</li></ol><ol start="5"><li>V_exprice V代表变量，后面紧跟着的是成员变量名，代表这个property的成员变量名为_exprice</li></ol><p>property_attribute为T@”NSNumber”、R、N、V_yearsOld时：</p><ol><li>T 是固定的，放在第一个</li></ol><ol start="2"><li>@”NSNumber” 代表这个property是一个NSNumber对象</li></ol><ol start="3"><li>R 代表readOnly属性，readwrite时为空</li></ol><ol start="4"><li>N 区分的nonatomic和atomic，默认为atomic，atomic为空，’N’代表是nonatomic</li></ol><ol start="5"><li>V_yearsOld V代表变量，后面紧跟着的是成员变量名，代表这个property的成员变量名为_yearsOld。</li></ol><p>（2）添加property，property_attribute_t是一个结构体，没有具体创建的方法，我们就只能使用{}这样结构体直接赋值过去。而且，添加property成功之后，它并不会生成实例属性、setter方法和getter方法。如果要真正调用的话，还需要我们自己添加对应的setter和getter方法。</p><p>4、协议相关函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span> <span class="params">( Class cls, Protocol *protocol )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span> <span class="params">( Class cls, Protocol *protocol )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line"><span class="function">Protocol * <span class="title">class_copyProtocolList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testProtocolList &#123;</span><br><span class="line">    <span class="comment">//添加协议</span></span><br><span class="line">    Protocol *p = <span class="class"><span class="keyword">@protocol</span>(<span class="title">StudentDataSource</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(class_addProtocol([Student <span class="keyword">class</span>], p)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加协议成功!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加协议失败!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否实现了指定的协议</span></span><br><span class="line">    <span class="keyword">if</span>(class_conformsToProtocol([Student <span class="keyword">class</span>], p)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"遵循 %s协议"</span>, protocol_getName(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"不遵循 %s协议"</span>, protocol_getName(p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类的协议列表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    Protocol * __<span class="keyword">unsafe_unretained</span> *protocolList = class_copyProtocolList([Student <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Protocol *protocol = protocolList[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = protocol_getName(protocol);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    free(protocolList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，可以使用runtime添加协议。</p><p>6、版本号（Version)</p><p>版本的使用两个方法，获取版本和设置版本，如下：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testVersion &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">version</span> = class_getVersion([Student <span class="keyword">class</span>]);</span><br><span class="line">    NSLog(@<span class="string">"%d"</span>, <span class="keyword">version</span>);</span><br><span class="line">    class_setVersion([Student <span class="keyword">class</span>], <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">version</span> = class_getVersion([Student <span class="keyword">class</span>]);</span><br><span class="line">    NSLog(@<span class="string">"%d"</span>, <span class="keyword">version</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、<strong>动态创建类和对象</strong></p><p>1、动态创建类</p><p>涉及以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新类和元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span> <span class="params">( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span> <span class="params">( Class cls )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span> <span class="params">( Class cls )</span></span>;</span><br></pre></td></tr></table></figure><p>其中：</p><p>（1）objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</p><p>（2）为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。</p><p>（3）实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p><p>（4）objc_disposeClassPair只能销毁由objc_allocateClassPair创建的类，当有实例存在或者它的子类存在时，调用这个函数会抛出异常。</p><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)addClassTest&#123;</span><br><span class="line">    Class MyClass = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">"myclass"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型</span></span><br><span class="line">    <span class="keyword">if</span> (class_addIvar(MyClass, <span class="string">"myIvar"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="string">"@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"add ivar success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//myclasstest是已经实现的函数，"v@:"这种写法见参数类型连接</span></span><br><span class="line">    class_addMethod(MyClass, <span class="keyword">@selector</span>(method0:), (IMP)mothod1, <span class="string">"v@:"</span>);</span><br><span class="line">    <span class="comment">//注册这个类到runtime系统中就可以使用他了</span></span><br><span class="line">    objc_registerClassPair(MyClass);</span><br><span class="line">    <span class="comment">//生成了一个实例化对象</span></span><br><span class="line">    <span class="keyword">id</span> myobj = [[MyClass alloc] init];</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"lifengfeng"</span>;</span><br><span class="line">    <span class="comment">//给刚刚添加的变量赋值</span></span><br><span class="line">    <span class="comment">//object_setInstanceVariable(myobj, "myIvar", (void *)&amp;str);在ARC下不允许使用</span></span><br><span class="line">    [myobj setValue:str forKey:<span class="string">@"myIvar"</span>];</span><br><span class="line">    <span class="comment">//调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息</span></span><br><span class="line">    [myobj method0:<span class="number">10</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法实际上没有被调用,但是必须实现否则不会调用下面的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)method0:(<span class="keyword">int</span>)a</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用的是这个方法</span></span><br><span class="line"><span class="keyword">void</span> mothod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">int</span> a) <span class="comment">//self和_cmd是必须的，在之后可以随意添加其他参数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    Ivar v = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"myIvar"</span>);</span><br><span class="line">    <span class="comment">//返回名为itest的ivar的变量的值</span></span><br><span class="line">    <span class="keyword">id</span> o = object_getIvar(<span class="keyword">self</span>, v);</span><br><span class="line">    <span class="comment">//成功打印出结果</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, o);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"int a is %d"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016<span class="selector-tag">-12-23</span> 12<span class="selector-pseudo">:19</span><span class="selector-pseudo">:40.842</span> <span class="selector-tag">RunTimeTest</span><span class="selector-attr">[3512:207171]</span> <span class="selector-tag">add</span> <span class="selector-tag">ivar</span> <span class="selector-tag">success</span></span><br><span class="line">2016<span class="selector-tag">-12-23</span> 12<span class="selector-pseudo">:19</span><span class="selector-pseudo">:40.843</span> <span class="selector-tag">RunTimeTest</span><span class="selector-attr">[3512:207171]</span> <span class="selector-tag">lifengfeng</span></span><br><span class="line">2016<span class="selector-tag">-12-23</span> 12<span class="selector-pseudo">:19</span><span class="selector-pseudo">:40.844</span> <span class="selector-tag">RunTimeTest</span><span class="selector-attr">[3512:207171]</span> <span class="selector-tag">int</span> <span class="selector-tag">a</span> <span class="selector-tag">is</span> 10</span><br></pre></td></tr></table></figure><p>上面为类添加了成员变量（ivar），也可以结合属性操作方法为类添加属性（property）。</p><p>属性和成员变量区别：成员变量主要是适用于iOS5之前的开发，需要程序员手动进行内存管理。iOS5之后（包括iOS5）引入了ARC（Automatic Reference Counting）同过在property中使用strong,weak等标记自动对内存进行管理。也就是说进行iOS5及以后系统版本的开发，可以放心的使用property，而无需对其进行手动的内存管理。</p><p>2、动态创建对象</p><p>动态创建对象的函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="function">id <span class="title">class_createInstance</span> <span class="params">( Class cls, <span class="keyword">size_t</span> extraBytes )</span></span>;</span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="function">id <span class="title">objc_constructInstance</span> <span class="params">( Class cls, <span class="keyword">void</span> *bytes )</span></span>;</span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">objc_destructInstance</span> <span class="params">( id obj )</span></span>;</span><br></pre></td></tr></table></figure><p>class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</p><p>调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016<span class="selector-tag">-12-23</span> 02<span class="selector-pseudo">:33</span><span class="selector-pseudo">:34.781</span> <span class="selector-tag">RuntimeTest</span><span class="selector-attr">[4039:89088]</span> <span class="selector-tag">NSString</span></span><br><span class="line">2016<span class="selector-tag">-12-23</span> 02<span class="selector-pseudo">:33</span><span class="selector-pseudo">:34.781</span> <span class="selector-tag">RuntimeTest</span><span class="selector-attr">[4039:89088]</span> __<span class="selector-tag">NSCFConstantString</span></span><br></pre></td></tr></table></figure><p>可以看到，使用class_createInstance函数获取的是NSString实例，而不是类簇中的默认占位符类__NSCFConstantString。</p><p>objc_constructInstance方法：在指定的位置(bytes)创建类实例。</p><p>objc_destructInstance方法：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p><p>三、其他类和对象相关操作函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span> <span class="params">( Class *buffer, <span class="keyword">int</span> bufferCount )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line"><span class="function">Class * <span class="title">objc_copyClassList</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回指定类的类定义</span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</span><br><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</span><br><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line">Class object_getClass ( <span class="keyword">id</span> obj );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS Runtime之一：Class和meta-class</title>
      <link href="/article/390/"/>
      <url>/article/390/</url>
      
        <content type="html"><![CDATA[<p>一、<strong>类和对象的数据结构</strong></p><p>1、<strong>Class</strong></p><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>objc_class结构体的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>            <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>   <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>    <span class="title">OBJC2_UNAVAILABLE</span>;</span>  <span class="comment">// 协议链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>在这个定义中，下面几个字段是我们感兴趣的</p><p>（1）isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)，我们会在后面介绍它。</p><p>（2）super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</p><p>（3）cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</p><p>（4）version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</p><p>针对cache，我们用下面例子来说明其执行过程：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = <span class="comment">[<span class="comment">[NSArray alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure><p>其流程是：</p><p>（1）[NSArray alloc]先被执行。先去NSArray中查找+alloc方法，因为NSArray没有+alloc方法，于是去父类NSObject去查找。</p><p>（2）检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</p><p>（3）接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</p><p>（4）在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</p><p>2、<strong>objc_object与id</strong></p><p>objc_object是表示一个类的实例的结构体，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p><p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p><p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p><p>3、<strong>objc_cache</strong></p><p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体的字段描述如下：</p><p>（1）mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</p><p>（2）occupied：一个整数，指定实际占用的缓存bucket的总数。</p><p>（3）buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</p><p>4、<strong>元类(Meta Class)</strong></p><p>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="keyword">array</span> = [NSArray <span class="keyword">array</span>];</span><br></pre></td></tr></table></figure><p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针，这个isa指针也要指向这个类所属的类。那么这些就有一个问题了，这个isa指针指向什么呢？这就引出了meta-class的概念：</p><p><strong>meta-class是一个类对象的类</strong></p><p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p><p>meta-class 是必须的，因为它为一个 Class 存储类方法。每个Class都必须有一个唯一的 meta-class，因为每个Class的类方法基本不可能完全相同。</p><p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向<strong>基类的meta-class</strong>，以此作为它们的所属类。即，<strong>任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类</strong>（<em>在一定程度上可以理解为若一个Class继承自NSObject，则这个Class的meta-class继承自NSObject的meta-class</em><strong>）</strong>，而<strong>基类的meta-class的isa指针是指向它自己，</strong>这就是说 <strong>NSObject 的 meta-class 的 isa 指针指向NSObject 的 meta-class自己</strong>。这样就形成了一个完美的闭环。</p><p>如下图所示：</p><p><img src="/images/2016/12/128529-b2aeea6630b9514a.jpg" alt="128529-b2aeea6630b9514a"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Class </tag>
            
            <tag> iOS </tag>
            
            <tag> meta-class </tag>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android实现微信自动抢红包</title>
      <link href="/article/50/"/>
      <url>/article/50/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>之前我写过实现QQ微信自动抢红包的APP，实现方法比较复杂。但是我最近偶然看到了一个实现自动抢红包更简单的方式，本文介绍这种微信自动抢红包的实现方法，掌握了相关方法后你也可以实现QQ抢红包，主要实现以下几个功能：</p><ul><li>自动拆开屏幕上出现的红包</li></ul><ul><li>处于桌面或聊天列表时接收到红包信息时自动进入聊天界面并拆红包</li></ul><ul><li>日志功能，记录抢红包的详细日志</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h2><ul><li>利用AccessibilityService辅助服务，监测屏幕内容，实现自动拆红包的目的。</li></ul><ul><li>利用ActiveAndroid数据库简单记录红包日志</li></ul><ul><li>利用preference实现监控选项纪录</li></ul><h2 id="抢红包核心代码"><a href="#抢红包核心代码" class="headerlink" title="抢红包核心代码"></a><strong>抢红包核心代码</strong></h2><h3 id="AccessibilityService配置"><a href="#AccessibilityService配置" class="headerlink" title="AccessibilityService配置"></a><strong>AccessibilityService配置</strong></h3><p>android:accessibilityEventTypes 设置触发监听回调的事件类型；<br>android:packageNames 设置监听的应用，这里监听的是微信，因此填上微信的包名com.tencent.mm</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;accessibility-service xmlns:<span class="attribute">android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:<span class="attribute">accessibilityEventTypes</span>=<span class="string">"typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged"</span></span><br><span class="line">    android:<span class="attribute">accessibilityFeedbackType</span>=<span class="string">"feedbackGeneric"</span></span><br><span class="line">    android:<span class="attribute">accessibilityFlags</span>=<span class="string">"flagDefault"</span></span><br><span class="line">    android:<span class="attribute">canRetrieveWindowContent</span>=<span class="string">"true"</span></span><br><span class="line">    android:<span class="attribute">description</span>=<span class="string">"@string/accessibility_description"</span></span><br><span class="line">    android:<span class="attribute">notificationTimeout</span>=<span class="string">"100"</span></span><br><span class="line">    android:<span class="attribute">packageNames</span>=<span class="string">"com.tencent.mm"</span></span><br><span class="line"> android:<span class="attribute">settingsActivity</span>=<span class="string">"com.oden.annotations.app.activity.ManActivity"</span> /&gt;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中声明:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".app.service.HongbaoService_"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:permission</span>=<span class="string">"android.permission.BIND_ACCESSIBILITY_SERVICE"</span> &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice.AccessibilityService"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:resource</span>=<span class="string">"@xml/accessibility_service_config"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="抢红包实现代码"><a href="#抢红包实现代码" class="headerlink" title="抢红包实现代码"></a><strong>抢红包实现代码</strong></h3><p>接收系统发送来的AccessibilityEvent</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> GET_RED_PACKET = <span class="string">"领取红包"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> CHECK_RED_PACKET = <span class="string">"查看红包"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> RED_PACKET_PICKED = <span class="string">"手慢了，红包派完了"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> RED_PACKET_PICKED2 = <span class="string">"手气"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> RED_PACKET_PICKED_DETAIL = <span class="string">"红包详情"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> RED_PACKET_SAVE = <span class="string">"已存入零钱"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> RED_PACKET_NOTIFICATION = <span class="string">"[微信红包]"</span>;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onAccessibilityEvent(AccessibilityEvent event) &#123;</span><br><span class="line">        L.d(<span class="string">"RECEIVE EVENT!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (watchedFlags == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">/* 检测通知消息 */</span></span><br><span class="line">        <span class="keyword">if</span> (!mMutex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedFlags.<span class="built_in">get</span>(<span class="string">"pref_watch_notification"</span>) &amp;&amp; watchNotifications(event)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (watchedFlags.<span class="built_in">get</span>(<span class="string">"pref_watch_list"</span>) &amp;&amp; watchList(event)) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!watchedFlags.<span class="built_in">get</span>(<span class="string">"pref_watch_chat"</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.rootNodeInfo = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (rootNodeInfo == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        mReceiveNode = <span class="keyword">null</span>;</span><br><span class="line">        mUnpackNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        checkNodeInfo();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 如果已经接收到红包并且还没有戳开 */</span></span><br><span class="line">        <span class="keyword">if</span> (mLuckyMoneyReceived &amp;&amp; !mLuckyMoneyPicked &amp;&amp; (mReceiveNode != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            mMutex = <span class="keyword">true</span>;</span><br><span class="line">            AccessibilityNodeInfo cellNode = mReceiveNode;</span><br><span class="line">            cellNode.getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">            mLuckyMoneyReceived = <span class="keyword">false</span>;</span><br><span class="line">            mLuckyMoneyPicked = <span class="keyword">true</span>;</span><br><span class="line">            L.d(<span class="string">"正在打开！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 如果戳开但还未领取 */</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedUnpack &amp;&amp; (mUnpackNode != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            AccessibilityNodeInfo cellNode = mUnpackNode;</span><br><span class="line">            cellNode.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">            mNeedUnpack = <span class="keyword">false</span>;</span><br><span class="line">            L.d(<span class="string">"正在领取！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNeedBack) &#123;</span><br><span class="line">            performGlobalAction(GLOBAL_ACTION_BACK);</span><br><span class="line">            mMutex = <span class="keyword">false</span>;</span><br><span class="line">            mNeedBack = <span class="keyword">false</span>;</span><br><span class="line">            L.d(<span class="string">"正在返回！"</span>);</span><br><span class="line">            <span class="comment">//总次数和金额统计</span></span><br><span class="line">            <span class="keyword">if</span> (isGetMoney) &#123;</span><br><span class="line">                T.showShort(<span class="keyword">this</span>, <span class="string">"抢到一个红包: "</span> + gotMoney + <span class="string">"元!"</span>);</span><br><span class="line">                totalMoney = totalMoney + gotMoney;</span><br><span class="line">                totalSuccessNum++;</span><br><span class="line">                myPrefs.totalMoney().put(totalMoney);</span><br><span class="line">                myPrefs.successNum().put(totalSuccessNum);</span><br><span class="line">                L.d(<span class="string">"totalMoney: "</span> + totalMoney);</span><br><span class="line">                L.d(<span class="string">"totalSuccessNum: "</span> + totalSuccessNum);</span><br><span class="line">                saveToLog(hongbaoInfo);</span><br><span class="line">                isGetMoney = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检测监听事件的节点信息</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void checkNodeInfo() &#123;</span><br><span class="line">        L.d(<span class="string">"checkNodeInfo!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.rootNodeInfo == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">/* 聊天会话窗口，遍历节点匹配“领取红包”和"查看红包" */</span></span><br><span class="line">        List&lt;AccessibilityNodeInfo&gt; nodes1 = <span class="keyword">this</span>.findAccessibilityNodeInfosByTexts(<span class="keyword">this</span>.rootNodeInfo, new String[]&#123;</span><br><span class="line">                GET_RED_PACKET, CHECK_RED_PACKET&#125;);</span><br><span class="line">        <span class="keyword">if</span> (!nodes1.isEmpty()) &#123;</span><br><span class="line">        L.d(<span class="string">"!nodes1.isEmpty()"</span>);</span><br><span class="line">            AccessibilityNodeInfo targetNode = nodes1.<span class="keyword">get</span>(nodes1.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"android.widget.LinearLayout"</span>.equals(targetNode.getParent().getClassName()))<span class="comment">//避免被文字干扰导致外挂失效</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.signature.generateSignature(targetNode)) &#123;</span><br><span class="line">                    mLuckyMoneyReceived = <span class="literal">true</span>;</span><br><span class="line">                    mReceiveNode = targetNode;</span><br><span class="line">                    L.d(<span class="string">"signature:"</span> + <span class="keyword">this</span>.signature.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L.d(<span class="string">"this is text"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;AccessibilityNodeInfo&gt; nodes2 = <span class="keyword">this</span>.findAccessibilityNodeInfosByTexts(<span class="keyword">this</span>.rootNodeInfo, new String[]&#123;</span><br><span class="line">                <span class="string">"拆红包"</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span> (!nodes2.isEmpty()) &#123;</span><br><span class="line">            L.d(<span class="string">"node2 != null"</span>);</span><br><span class="line">            <span class="keyword">for</span> (AccessibilityNodeInfo nodeInfo : nodes2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nodeInfo.getClassName().equals(<span class="string">"android.widget.Button"</span>))</span><br><span class="line">                        nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">/* 戳开红包，红包还没抢完，遍历节点匹配“拆红包” */</span></span><br><span class="line">            AccessibilityNodeInfo node2 = (<span class="keyword">this</span>.rootNodeInfo.getChildCount() &gt; <span class="number">3</span>) ? <span class="keyword">this</span>.rootNodeInfo.getChild(<span class="number">3</span>) : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (node2 != <span class="literal">null</span> &amp;&amp; node2.getClassName().equals(<span class="string">"android.widget.Button"</span>)) &#123;</span><br><span class="line">                mUnpackNode = node2;</span><br><span class="line">                mNeedUnpack = <span class="literal">true</span>;</span><br><span class="line">                isToGetMoney = <span class="literal">true</span>;</span><br><span class="line">                L.d(<span class="string">"find red packet!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/* 戳开红包，红包已被抢完，遍历节点匹配“已存入零钱”和“手慢了” */</span></span><br><span class="line">        <span class="keyword">if</span> (mLuckyMoneyPicked) &#123;</span><br><span class="line">            List&lt;AccessibilityNodeInfo&gt; nodes3 = <span class="keyword">this</span>.findAccessibilityNodeInfosByTexts(<span class="keyword">this</span>.rootNodeInfo, new String[]&#123;</span><br><span class="line">                    RED_PACKET_PICKED, RED_PACKET_SAVE, RED_PACKET_PICKED2, RED_PACKET_PICKED_DETAIL&#125;);</span><br><span class="line">            <span class="keyword">if</span> (!nodes3.isEmpty()) &#123;</span><br><span class="line">                L.d(<span class="string">"!nodes3.isEmpty()"</span>);                </span><br><span class="line">                <span class="keyword">if</span> (rootNodeInfo.getChildCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    L.d(<span class="string">"RED_PACKET_PICKED!"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    L.d(<span class="string">"nodes3.get(0).toString(): "</span> + nodes3.<span class="keyword">get</span>(<span class="number">0</span>).getText().toString());</span><br><span class="line">                    <span class="keyword">if</span> (!nodes3.<span class="keyword">get</span>(<span class="number">0</span>).getText().toString().equals(RED_PACKET_PICKED_DETAIL)) &#123;</span><br><span class="line">                        AccessibilityNodeInfo targetNode = nodes3.<span class="keyword">get</span>(nodes3.size() - <span class="number">1</span>);</span><br><span class="line">                        hongbaoInfo.getInfo(targetNode);</span><br><span class="line">                        <span class="keyword">if</span> (isToGetMoney) &#123;</span><br><span class="line">                            isGetMoney = <span class="literal">true</span>;</span><br><span class="line">                            isToGetMoney = <span class="literal">false</span>;</span><br><span class="line">                            gotMoney = hongbaoInfo.getMoney();</span><br><span class="line">                            L.d(<span class="string">"gotMoney: "</span> + gotMoney);</span><br><span class="line">                        &#125;</span><br><span class="line">                        L.d(<span class="string">"RED_PACKET_SAVE!"</span>);</span><br><span class="line">                        L.d(<span class="string">"hongbaoInfo: "</span> + hongbaoInfo.toString());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        L.d(<span class="string">"this packet is myself!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                mNeedBack = <span class="literal">true</span>;</span><br><span class="line">                mLuckyMoneyPicked = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>主要通过检测“领取红包”等关键文字信息来判断是否有新红包</li></ul><ul><li>检测收到红包时判断是否”android.widget.LinearLayout”，屏蔽聊天信息中的文字干扰</li></ul><ul><li>拆红包时，由于微信版本可能不同，同时进行两种判断，以兼容部分版本</li></ul><ul><li>拆完红包需自动返回，有以下几种情况：抢到了，手慢了，以及该红包是自己发出的红包</li></ul><p>下面是监听聊天列表的代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">watchList</span>(<span class="params">AccessibilityEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Not a message</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">event</span>.getEventType() != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED || <span class="keyword">event</span>.getSource() == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;AccessibilityNodeInfo&gt; nodes = <span class="keyword">event</span>.getSource().findAccessibilityNodeInfosByText(RED_PACKET_NOTIFICATION);</span><br><span class="line">        <span class="keyword">if</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">            AccessibilityNodeInfo nodeToClick = nodes.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">            CharSequence contentDescription = nodeToClick.getContentDescription();</span><br><span class="line">            <span class="keyword">if</span> (contentDescription != <span class="literal">null</span> &amp;&amp; !lastContentDescription.<span class="keyword">equals</span>(contentDescription)) &#123;</span><br><span class="line">                nodeToClick.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">                lastContentDescription = contentDescription.toString();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code></code>下面是监听通知信息的代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">watchNotifications</span>(<span class="params">AccessibilityEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">       <span class="comment">// Not a notification</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">event</span>.getEventType() != AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Not a hongbao</span></span><br><span class="line">       String tip = <span class="keyword">event</span>.getText().toString();</span><br><span class="line">       <span class="keyword">if</span> (!tip.contains(RED_PACKET_NOTIFICATION)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       Parcelable parcelable = <span class="keyword">event</span>.getParcelableData();</span><br><span class="line">       <span class="keyword">if</span> (parcelable instanceof Notification) &#123;</span><br><span class="line">           Notification notification = (Notification) parcelable;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               notification.contentIntent.send();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="红包信息的获取，及日志的存储"><a href="#红包信息的获取，及日志的存储" class="headerlink" title="红包信息的获取，及日志的存储"></a><strong>红包信息的获取，及日志的存储</strong></h3><p>通过获取节点的子信息，分别获得红包发送者及抢到的金额、抢红包时间等信息，建立简单的表单分别记录该信息。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Table</span>(name = <span class="string">"HongbaoInfos"</span>)</span><br><span class="line"><span class="keyword">public</span> class HongbaoInfo extends Model &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">month</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">day</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">hour</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> sec;</span><br><span class="line"></span><br><span class="line">    @Column(name = <span class="string">"sender"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> sender;</span><br><span class="line"></span><br><span class="line">    @Column(name = <span class="string">"money"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> money;</span><br><span class="line"></span><br><span class="line">    @Column(name = <span class="string">"time"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> getInfo(AccessibilityNodeInfo node) &#123;</span><br><span class="line"></span><br><span class="line">        AccessibilityNodeInfo hongbaoNode = node.getParent();</span><br><span class="line">        sender = hongbaoNode.getChild(<span class="number">0</span>).getText().toString();</span><br><span class="line">        money = hongbaoNode.getChild(<span class="number">2</span>).getText().toString();</span><br><span class="line">        time = getStringTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> getStringTime() &#123;</span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="built_in">month</span> = c.<span class="built_in">get</span>(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">day</span> = c.<span class="built_in">get</span>(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="built_in">hour</span> = c.<span class="built_in">get</span>(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="built_in">min</span> = c.<span class="built_in">get</span>(Calendar.MINUTE);</span><br><span class="line">        sec = c.<span class="built_in">get</span>(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">month</span>+<span class="string">"月"</span>+<span class="built_in">day</span>+<span class="string">"日  "</span>+<span class="built_in">hour</span>+<span class="string">":"</span>+<span class="built_in">min</span>+<span class="string">":"</span>+sec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HongbaoInfo [sender="</span> + sender + <span class="string">", money="</span> + money + <span class="string">", time="</span> + time + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HongbaoInfo&gt; getAll() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Select()</span><br><span class="line">                .from(HongbaoInfo.class)</span><br><span class="line">                .orderBy(<span class="string">"Id ASC"</span>)</span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> deleteALL() &#123;</span><br><span class="line">        <span class="keyword">new</span> Delete().from(HongbaoInfo.class).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> getMoney() &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getSender() &#123;</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getTime() &#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储操作：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveToLog</span>(<span class="params">HongbaoInfo hongbaoInfo</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (watchedFlags.<span class="keyword">get</span>(<span class="string">"pref_etc_log"</span>)) &#123;</span><br><span class="line">           HongbaoInfo hongbaoInfo1 = <span class="keyword">new</span> HongbaoInfo();</span><br><span class="line">           hongbaoInfo1 = hongbaoInfo;</span><br><span class="line">           hongbaoInfo1.save();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           L.d(<span class="string">"log closed!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>主要的代码到这里基本结束，目前在微信最新版上测试ok，尚还存在以下几个问题：</p><ul><li>同一个人连续发的不能自动抢，因为为了防止重复点击做了过滤，同一个人的红包抢了后不会再次点击</li></ul><ul><li>AccessibilityService开启时间长后有时会被系统关掉</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抢红包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS单元测试详解</title>
      <link href="/article/32/"/>
      <url>/article/32/</url>
      
        <content type="html"><![CDATA[<p>其实单元测试用的好，开发起来也会快很多。单元测试对于我目前来说，就是为了方便测试一些功能是否正常运行，还有调试接口是否能正常使用。有时候你可能是为了测试某一个网络接口，然后每次都重新启动并且经过很多操作之后才测试到了那个网络接口。如果使用了单元测试，就可以直接测试那个方法，相对方便很多。 比如由于修改较多，我们想测试一下分享功能是否正常，这时候就有用了。（而不是重新启动程序，进入到分享界面，点击分享，填写分享内容。）其实单元测试并没有降低我们打代码的效率，我们可以在单元测试通过了，直接用到相应的地方。<br>当然也有一些高级的作用，比如自动发布、自动测试（特别在一些大的项目，以防止程序被误改或引起新的问题）。<br>现在，让我们先理清一下单元测试到底有些什么东西？<br><strong><a href="http://blog.csdn.net/jymn_chen/article/details/21552941" target="_blank" rel="noopener">    OCUnit</a></strong>（<code>即用XCTest进行测试</code>）其实就是苹果自带的测试框架，我们主要讲的就是这个。<strong><a href="http://blog.csdn.net/jymn_chen/article/details/21562869" target="_blank" rel="noopener">GHUnit</a></strong>是一个可视化的测试框架。（有了它，你可以点击APP来决定测试哪个方法，并且可以点击查看测试结果等。）<strong><a href="http://blog.csdn.net/jymn_chen/article/details/21562869" target="_blank" rel="noopener">OCMock</a></strong>就是模拟某个方法或者属性的返回值，你可能会疑惑为什么要这样做?使用用模型生成的模型对象，再传进去不就可以了？答案是可以的，但是有特殊的情况。比如你测试的是方法A，方法A里面调用到了方法B，而且方法B是有参数传入，但又不是方法A所提供。这时候，你可以使用OCMock来模拟方法B返回的值。（在不影响测试的情况下，就可以这样去模拟。）除了这些，在没有网络的情况下，也可以通过OCMock模拟返回的数据。<a href="http://www.cocoachina.com/ios/20150702/12253.html" target="_blank" rel="noopener">UITests</a>就是通过代码化来实现自动点击界面，输入文字等功能。靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UITests就可以帮助解决这个问题了。</p><p>最简单的单元测试</p><p>1.新建项目：</p><p><img src="/images/2016/12/18101525_hWA9.png.jpeg" alt="18101525_hwa9-png"></p><p>18CA997F-4911-4B99-9A83-2AB44A77E8E8.png<br>2.最简单的测试，注意截图路径的问题<br>进入到这个类，setUp是每个测试方法调用<strong>前</strong>执行，tearDown是每个测试方法调用<strong>后</strong>执行。testExample是测试方法，和我们新建的没有差别。不过测试方法必须testXXX的格式，且不能有参数，不然不会识别为测试方法。测试方法的执行顺序是字典序排序。<br>按快捷键Command + U进行单元测试，这个快捷键是全部测试。<br>testExample方法中输入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"自定义测试testExample"</span>)<span class="comment">;</span></span><br><span class="line">    int  a= <span class="number">3</span><span class="comment">;</span></span><br><span class="line">    XCTAssertTrue(<span class="name">a</span> == <span class="number">0</span>,<span class="string">"a 不能等于 0"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>点击播放按钮，开始单个方法的测试：</p><p><img src="/images/2016/12/18101525_riNN.png.jpeg" alt="18101525_rinn-png"></p><p>8F503AA4-C630-419A-9F66-C779C81A5581.png<br>出现如下结果，由于我们断言a是不能等于0的，所以测试没有通过。当然有其它的，用到再看，demo里都有。</p><p><img src="/images/2016/12/18101525_VKel.png.jpeg" alt="18101525_vkel-png"></p><p>8BAD5CD6-7FB7-4626-A1F8-CBC2B6B35E89.png</p><p>进行网络请求的测试</p><p>使用CocoaPods安装AFNetworking和STAlertView（<a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="noopener">CocoaPods安装和使用教程</a> ）<br>Pofile:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.5.0'</span></span><br><span class="line">pod <span class="string">'STAlertView'</span>, <span class="string">'~&gt; 1.0.0'</span></span><br></pre></td></tr></table></figure><p>这时会发现AFNetworking根本没法在单元测试里使用，因为没有找到库，所以我们需要配置一下：</p><p><img src="/images/2016/12/18101525_je0v.gif" alt="18101525_je0v"></p><p>UITestDemo设置</p><p><img src="/images/2016/12/18101525_xp3G.gif" alt="18101525_xp3g"></p><p>UITestDemo设置2<br>在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES。设置位置如下：</p><p><img src="/images/2016/12/18101525_KRFK.png.jpeg" alt="18101525_krfk-png"></p><p>A0F7275A-D79D-4DA4-955B-8BFE862D10E4.png</p><p>iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。（<a href="http://blog.csdn.net/diyagoanyhacker/article/details/8540239" target="_blank" rel="noopener">另一种异步函数的单元测试</a>）定义宏如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。</span></span><br><span class="line"><span class="meta">#define WAIT do &#123;\</span></span><br><span class="line">[<span class="keyword">self</span> expectationForNotification:<span class="string">@"RSBaseTest"</span> object:<span class="literal">nil</span> handler:<span class="literal">nil</span>];\</span><br><span class="line">[<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">30</span> handler:<span class="literal">nil</span>];\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#define NOTIFY \</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]postNotificationName:<span class="string">@"RSBaseTest"</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>增加测试方法testRequest：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testRequest&#123;</span><br><span class="line">    <span class="comment">// 1.获得请求管理者</span></span><br><span class="line">    AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];</span><br><span class="line">    mgr.responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"text/html"</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送GET请求</span></span><br><span class="line">    [mgr GET:<span class="string">@"http://www.weather.com.cn/adat/sk/101110101.html"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"responseObject:%@"</span>,responseObject);</span><br><span class="line">        <span class="built_in">XCTAssertNotNil</span>(responseObject, <span class="string">@"返回出错"</span>);</span><br><span class="line">        NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">    &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error:%@"</span>,error);</span><br><span class="line">        <span class="built_in">XCTAssertNil</span>(error, <span class="string">@"请求出错"</span>);</span><br><span class="line">        NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">    &#125;];</span><br><span class="line">    WAIT  <span class="comment">//暂停</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们想测试一下整个流程是否可以跑通，比如获取验证码、登录、上传头像，查询个人资料。其实只要输入验证码就可以完成整个测试。这时候就需要用到输入框了，以便程序继续执行。使用了一个第三方的弹出输入框STAlertView，前面已经设置。<br>STAlertView的使用方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.stAlertView = [[STAlertView alloc]<span class="string">initWithTitle:</span>@<span class="string">"验证码"</span> <span class="string">message:</span>nil <span class="string">textFieldHint:</span>@<span class="string">"请输入手机验证码"</span> <span class="string">textFieldValue:</span>nil <span class="string">cancelButtonTitle:</span>@<span class="string">"取消"</span> <span class="string">otherButtonTitle:</span>@<span class="string">"确定"</span> <span class="string">cancelButtonBlock:</span>^&#123;</span><br><span class="line">    <span class="comment">//点击取消返回后执行</span></span><br><span class="line">    [self testAlertViewCancel];</span><br><span class="line">    NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">&#125; <span class="string">otherButtonBlock:</span>^(NSString *b) &#123;</span><br><span class="line">    <span class="comment">//点击确定后执行</span></span><br><span class="line">    [self <span class="string">alertViewComfirm:</span>b];</span><br><span class="line">     NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">&#125;];</span><br><span class="line">[self.stAlertView show];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发之深复制和浅复制</title>
      <link href="/article/21/"/>
      <url>/article/21/</url>
      
        <content type="html"><![CDATA[<p><strong>1**</strong>、概述**</p><p>对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。</p><p>如下图：</p><p><img src="/images/2016/12/103648_Nn5O_2448717.png" alt="103648_nn5o_2448717"></p><p>再简单些说：<strong>浅复制就是指针拷贝；深复制就是内容拷贝。</strong></p><hr><p><strong>2**</strong>、集合的浅复制<strong>** (shallow copy)</strong></p><p>集合的浅复制有非常多种方法。当你进行浅复制时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。</p><p>现在让我们看三个浅复制的例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *shallowCopyArray = [someArray copyWithZone:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSSet</span> *shallowCopySet = [<span class="built_in">NSSet</span> mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *shallowCopyDict =</span><br><span class="line">[[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p><strong>2**</strong>、集合的深复制<strong>** (deep copy)</strong></p><p>集合的深复制有两种方法。</p><p><strong>方法一：</strong></p><p>可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span>  shallowCopyDict  =</span><br><span class="line">[[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深复制到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。</p><p><strong>方法二：</strong></p><p>将集合进行归档(archive)，然后解档(unarchive)，如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *trueDeepCopyArray =</span><br><span class="line">[<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:oldArray]];</span><br></pre></td></tr></table></figure><p><strong>3**</strong>、集合的单层深复制<strong>** (one-level-deep copy)</strong></p><p>看到这里，有同学会问：如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，苹果官网文档有这样一句话描述：</p><p>This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy…</p><p>If you need a true deep copy, such as when you have an array of arrays…</p><p>从文中可以看出，苹果认为这种复制不是真正的深复制，而是将其称为单层深复制(one-level-deep copy)。因此，网上有人对浅复制、深复制、单层深复制做了概念区分。</p><p><strong>浅复制**</strong>(shallow copy)<strong>**：</strong>在浅复制操作时，对于被复制对象的每一层都是指针复制。</p><p><strong>深复制**</strong>(one-level-deep copy)<strong>**：</strong>在深复制操作时，对于被复制对象，至少有一层是深复制。</p><p><strong>完全复制**</strong>(real-deep copy)<strong>**：</strong>在完全复制操作时，对于被复制对象的每一层都是对象复制。</p><p>当然，这些都是概念性的东西，没有必要纠结于此。只要知道进行拷贝操作时，被拷贝的是指针还是内容即可。</p><p><strong>4**</strong>、系统对象的<strong><strong>copy</strong></strong>与<strong><strong>mutableCopy</strong></strong>方法**</p><p>不管是集合类对象，还是非集合类对象，接收到copy和mutableCopy消息时，都遵循以下准则：</p><p>copy返回imutable对象（不可变对象）；所以，如果对copy返回值使用mutable对象接口就会crash；</p><p>mutableCopy返回mutable对象；</p><p>下面将针对非集合类对象和集合类对象的copy和mutableCopy方法进行具体的阐述</p><p><strong>（**</strong>1<strong><strong>）非集合类对象的</strong></strong>copy<strong><strong>与</strong></strong>mutableCopy**</p><p>系统非集合类对象指的是 NSString, NSNumber … 之类的对象。下面先看个非集合类immutable对象拷贝的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @<span class="string">"origin"</span>;</span><br><span class="line">NSString *stringCopy = [<span class="built_in">string</span> copy];</span><br><span class="line">NSMutableString *stringMCopy = [<span class="built_in">string</span> mutableCopy];</span><br></pre></td></tr></table></figure><p>通过查看内存，可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；</p><p>再看mutable对象拷贝例子：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *string = [NSMutableString stringWithString: @<span class="string">"origin"</span>];</span><br><span class="line"><span class="comment">//copy</span></span><br><span class="line">NSString *stringCopy = [<span class="built_in">string</span> copy];</span><br><span class="line">NSMutableString *mStringCopy = [<span class="built_in">string</span> copy];</span><br><span class="line">NSMutableString *stringMCopy = [<span class="built_in">string</span> mutableCopy];</span><br><span class="line"><span class="comment">//change value</span></span><br><span class="line">[mStringCopy appendString:@<span class="string">"mm"</span>]; <span class="comment">//crash</span></span><br><span class="line">[<span class="built_in">string</span> appendString:@<span class="string">" origion!"</span>];</span><br><span class="line">[stringMCopy appendString:@<span class="string">"!!"</span>];</span><br></pre></td></tr></table></figure><p>运行以上代码，会在第7行crash，原因就是 copy 返回的对象是 immutable 对象。注释第7行后再运行，查看内存，发现 string、stringCopy、mStringCopy、stringMCopy 四个对象的内存地址都不一样，说明此时都是做内容拷贝。</p><p>综上两个例子，我们可以得出结论：</p><p><strong>在非集合类对象中：对**</strong>immutable<strong><strong>对象进行</strong></strong>copy<strong><strong>操作，是指针复制，</strong></strong>mutableCopy<strong><strong>操作时内容复制；对</strong></strong>mutable<strong><strong>对象进行</strong></strong>copy<strong><strong>和</strong></strong>mutableCopy<strong>**都是内容复制。</strong></p><p><strong>用代码简单表示如下：</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">immutableObject copy</span>] <span class="comment">// 浅复制</span></span><br><span class="line">[<span class="meta">immutableObject mutableCopy</span>] <span class="comment">//深复制</span></span><br><span class="line">[<span class="meta">mutableObject copy</span>] <span class="comment">//深复制</span></span><br><span class="line">[<span class="meta">mutableObject mutableCopy</span>] <span class="comment">//深复制</span></span><br></pre></td></tr></table></figure><p><strong>（**</strong>2<strong><strong>）集合类对象的</strong></strong>copy<strong><strong>与</strong></strong>mutableCopy**</p><p>集合类对象是指NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用copy和mutableCopy的一个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@[<span class="string">@"a"</span>, <span class="string">@"b"</span>], @[<span class="string">@"c"</span>, <span class="string">@"d"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *copyArray = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure><p>查看内容，可以看到copyArray和array的地址是一样的，而mCopyArray和array的地址是不同的。说明copy操作进行了指针拷贝，mutableCopy进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝array这个对象，array集合内部的元素仍然是指针拷贝。这和上面的非集合immutable对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看mutable对象拷贝的例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array =</span><br><span class="line">[<span class="built_in">NSMutableArray</span> arrayWithObjects:[<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"a"</span>],<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *copyArray = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure><p>查看内存，如我们所料，copyArray、mCopyArray和array的内存地址都不一样，说明copyArray、mCopyArray都对array进行了内容拷贝。</p><p>同样，我们可以得出结论：</p><p><strong>在集合类对象中，对**</strong>immutable<strong><strong>对象进行</strong></strong>copy<strong><strong>，是指针复制，</strong></strong>mutableCopy<strong><strong>是内容复制；对</strong></strong>mutable<strong><strong>对象进行</strong></strong>copy<strong><strong>和</strong></strong>mutableCopy<strong>**都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。</strong></p><p><strong>用代码简单表示如下：</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">immutableObject copy</span>] <span class="comment">// 浅复制</span></span><br><span class="line">[<span class="meta">immutableObject mutableCopy</span>] <span class="comment">//单层深复制</span></span><br><span class="line">[<span class="meta">mutableObject copy</span>] <span class="comment">//单层深复制</span></span><br><span class="line">[<span class="meta">mutableObject mutableCopy</span>] <span class="comment">//单层深复制</span></span><br></pre></td></tr></table></figure><p>这个代码结论和非集合类的非常相似。</p><p>最后说个题外的东西，在搜集资料的过程中，发现一个有可能犯错的点：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *<span class="keyword">str</span> = @<span class="string">"string"</span>;</span><br><span class="line"><span class="keyword">str</span> = @<span class="string">"newString"</span>;</span><br></pre></td></tr></table></figure><p>上面这段代码，在执行第二行代码后，内存地址发生了变化。乍一看，有点意外。按照 C 语言的经验，初始化一个字符串之后，字符串的首地址就被确定下来，不管之后如何修改字符串内容，这个地址都不会改变。但此处第二行并不是对 str 指向的内存地址重新赋值，因为赋值操作符左边的 str 是一个指针，也就是说此处修改的是内存地址。</p><p>所以第二行应该这样理解：将@”newStirng”当做一个新的对象，将这段对象的内存地址赋值给str。</p><p>如下的两个方法查看内存地址</p><p><strong>方法一</strong>：p str （会打印对象本身的内存地址和对象内容）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(lldb)</span> p str</span><br><span class="line"><span class="comment">(NSString *)</span> $<span class="number">0</span> = <span class="number">0</span>x<span class="number">000000010</span>c<span class="number">913680</span> @<span class="string">"a"</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong>po &amp;str （打印的是引用对象的指针所在的地址）</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lldb</span>) po &amp;str</span><br><span class="line"><span class="number">0</span>x00007fff532fb6c0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅复制 </tag>
            
            <tag> 深复制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TabHost页和子Activity之间的通讯</title>
      <link href="/article/19/"/>
      <url>/article/19/</url>
      
        <content type="html"><![CDATA[<p>TabHost的各个Tab页，都是由activity组成。<br>现在，某个子Activity中处理数据后，要自动跳转到另外一个Tab页中。这样，需要有个TabHost页和子Activity之间的通讯的机制。</p><p>子Activity通知TabHost：<br>1、通过广播方式<br>1）在TabHost中定义广播<br>定义变量<br>protected MessageBroadcastReceiver myReceiver = null;</p><p>在onCreate中注册：<br>加入receiveBroadcast();</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">myReceiver = <span class="keyword">new</span> MessageBroadcastReceiver();</span><br><span class="line"><span class="comment">//Log.d(LOG_TAG, "receiveBroadcast() ::::: " + myReceiver.hashCode());</span></span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(<span class="string">"android.intent.action.MAIN"</span>);</span><br><span class="line">registerReceiver(myReceiver, intentFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onDestroy中释放广播</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myReceiver != <span class="literal">null</span>)</span><br><span class="line">unregisterReceiver(myReceiver);</span><br><span class="line"></span><br><span class="line"><span class="type">MessageBroadcastReceiver</span>类定义:</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MessageBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> action = intent.getAction();</span><br><span class="line"><span class="keyword">if</span> (action.equals(<span class="string">"android.intent.action.MAIN"</span>)) &#123;</span><br><span class="line">switch (intent.getIntExtra(<span class="string">"msg"</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Constant</span>.<span class="type">BROADCAST_KEY_TABHOST_CHANGE</span>: &#123;</span><br><span class="line">int tabIndex = intent.getIntExtra(<span class="string">"tabIndex"</span>, <span class="number">0</span>);</span><br><span class="line">animateChangeTab(tabIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="type">Log</span>.v(<span class="type">LOG_TAG</span>, e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在子Activity中调用</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(<span class="string">"android.intent.action.MAIN"</span>)<span class="comment">;</span></span><br><span class="line">intent.putExtra(<span class="string">"msg"</span>, Constant.<span class="keyword">BROADCAST_KEY_TABHOST_CHANGE);</span></span><br><span class="line"><span class="keyword">intent.putExtra("tabIndex", </span><span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">sendBroadcast(intent)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>2、通过handler接收消息<br>1）在TabHost中定义Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到主线程的Looper对象</span></span><br><span class="line">Looper looper = Looper.myLooper();</span><br><span class="line"><span class="comment">// 这个myHandler由主线程创建所以它与主线程关联</span></span><br><span class="line"><span class="keyword">public</span> MessageHandler msgHandler = <span class="keyword">new</span> MessageHandler(looper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送本次信息</span></span><br><span class="line">msgHandler.removeMessages(<span class="number">0</span>);</span><br><span class="line">Message m = msgHandler.obtainMessage(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, message); <span class="comment">// 构造要传递的消息</span></span><br><span class="line">msgHandler.sendMessage(m); <span class="comment">// 发送消息: 系统会自动调用handleMessage 方法来处理消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(looper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; <span class="comment">// 处理消息</span></span><br><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"><span class="keyword">case</span> Constant.BROADCAST_KEY_TABHOST_CHANGE:</span><br><span class="line"><span class="keyword">int</span> tabIndex = (Integer) msg.obj;</span><br><span class="line">animateChangeTab(tabIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">Toast.makeText(getApplicationContext(), msg.obj.toString(),</span><br><span class="line">Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在子Activity中调用</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BasketballMainActivity </span>t= (<span class="keyword">BasketballMainActivity) </span>getParent()<span class="comment">;</span></span><br><span class="line">Message message = new Message()<span class="comment">;</span></span><br><span class="line">message.what = Constant.<span class="keyword">BROADCAST_KEY_TABHOST_CHANGE;</span></span><br><span class="line"><span class="keyword">message.obj </span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">t.msgHandler.sendMessage(message)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>TabHost通知子Activity：<br>1、子Activity是活动的<br>在TabHost中增加</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Activity currentActivity = getCurrentActivity()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if (currentActivity <span class="keyword">instanceof </span>A) &#123;</span><br><span class="line">((A) currentActivity).处理方法XXX<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、子Activity是不是活动的<br>在子Activity的</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加逻辑即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TabHost </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android使用得图SDK开发VR播放器</title>
      <link href="/article/18/"/>
      <url>/article/18/</url>
      
        <content type="html"><![CDATA[<p>产品概述</p><p>Android SDK包含全景图片、VR视频、漫游主题等多种展示方式,支持小行星模式、陀螺仪、VR双屏沉浸式观看。文件下载、解码都在播放器中完成，您只需一个链接地址或是一条配置即可展现炫酷的全景效果。</p><p>注： 该SDK支持不低于4.0.0的Android版本（api14）。</p><p>下载并集成SDK</p><p>下载SDK最新版</p><p>下载最新版panoplay_android_jar SDK，解压SDK压缩包，将panoplay_android_jar文件夹中的’libs’和’res/raw’文件夹复制到你的项目工程根目录下（如使用’ADT 17’以下用户需要手动添加’libs’下的jar文件到工程Path中）。</p><p><a href="http://media.qicdn.detu.com/@/sdk-1.0.0/Android-SDK%E5%8C%85.rar" target="_blank" rel="noopener">sdk包下载</a></p><p><a href="http://media.qicdn.detu.com/@/sdk-1.0.0/Android%E7%89%88-demo.rar" target="_blank" rel="noopener">demo下载</a></p><p>AndroidManifest配置</p><p>增加权限</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span><br></pre></td></tr></table></figure><p>配置最低可运行版本</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-sdk</span><br><span class="line"></span><br><span class="line"><span class="symbol">android:</span>minSdkVersion=<span class="string">"14"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">android:</span>targetSdkVersion=<span class="string">"21"</span>   /&gt;</span><br></pre></td></tr></table></figure><p>在manifest根节点配置OpenGL版本: <uses-feature android:glesversion="0x00020000" android:required="true"></uses-feature></p><p>为了达到最好的播放效果建议开启硬件加速:在Application节点中声明android:hardwareAccelerated=”true”</p><p>初始化配置</p><p>由于本播放器使用universal-image-loader类库来管理图片,因此首先要在Application中初始化ImageLoader,若在您的项目中已使用到了该类库,只需保证 DisplayImageOptions 中bitmapConfig为Bitmap.Config.ARGB_8888类型，imageScaleType为ImageScaleType.NONE,并且开启了内存和磁盘缓存。 没有配置过的可以按以下方式配置：</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DisplayImageOptions</span> defaultOptions = <span class="function"><span class="keyword">new</span> <span class="title">DisplayImageOptions</span>.<span class="title">Builder</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">imageScaleType</span>(<span class="type">ImageScaleType</span>.<span class="type">NONE</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">cacheInMemory</span>(true)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">cacheOnDisk</span>(true)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">build</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ImageLoaderConfiguration</span> <span class="title">config</span> = <span class="title">new</span> <span class="title">ImageLoaderConfiguration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">Builder</span>(this)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">defaultDisplayImageOptions</span>(defaultOptions)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">threadPriority</span>(<span class="type">Thread</span>.<span class="type">NORM_PRIORITY</span> - <span class="number">2</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">denyCacheImageMultipleSizesInMemory</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">discCacheFileNameGenerator</span>(new <span class="type">Md5FileNameGenerator</span>())</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">tasksProcessingOrder</span>(<span class="type">QueueProcessingType</span>.<span class="type">FIFO</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.<span class="title">build</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ImageLoader</span>.<span class="title">getInstance</span>().<span class="title">init</span>(config);</span></span><br></pre></td></tr></table></figure><p>播放器引入</p><p>布局文件引用</p><p>播放器需要借助com.player.renderer.PanoPlayerSurfaceView(继承自android.opengl.GLSurfaceView)类来播放全景图片和视频,您可以根据需要自定义他的宽高和位置，还可以再继承自 PanoPlayerSurfaceView 根据需求自定义点击事件和滑动事件。</p><p>函数调用</p><p><strong>创建播放渲染器：</strong></p><p>播放器需要借助 com.player.panoplayer.PanoPlayer(PanoPlayerSurfaceView view, Context context)来控制OpenGL渲染。 首先获取布局文件播放器:</p><p>PanoPlayerSurfaceView ppsview;</p><p>创建渲染器并和播放器绑定:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PanoPlayer renderer=<span class="keyword">new</span> <span class="type">PanoPlayer</span>(ppsview, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">ppsvVideo.setRenderer(renderer);</span><br></pre></td></tr></table></figure><p><strong>创建播放文件链接：</strong></p><p>创建播放链接类PanoPlayerUrl加载文件 PanoPlayerUrl panoplayerurl = new PanoPlayerUrl()；</p><p><strong>加载视频或图像</strong></p><p>加载视频或图像有三种方法:</p><p>1) 通过网络地址直接加载</p><p>加载视频方法： panoplayerurl.SetVideoUrlImage(“视频地址”,””);</p><p>加载六面图方法： panoplayerurl.SetCubeUrlImage(“六面图地址”，”六面图的预览图”) 其中六面图的地址输入格式为：<a href="http://fwpano813.img.detuyun.cn/143461522655827dbad040a/oper/59gv8ty1gte1p9l2_html_%25s.jpg" target="_blank" rel="noopener">http://fwpano813.img.detuyun.cn/143461522655827dbad040a/oper/59gv8ty1gte1p9l2_html_%s.jpg</a>后面以%s结尾； 访问时可把%s换成f(/u/b/l/r/d);</p><p>加载2:1全景图方法： panoplayerurl.SetSphereUrlImage(“2:1图的地址”,””)；</p><p>2) 通过加载Xml文件： panoplayerurl. setXmlUrl(“xml文件”)</p><p>3) 通过构造xml加载：如构造一个鱼眼视频的xml</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String T =</span><br><span class="line"></span><br><span class="line"><span class="string">"&lt;DetuVr&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;settings init=<span class="subst">\"</span>pano1<span class="subst">\"</span> initmode=<span class="subst">\"</span>default<span class="subst">\"</span>  "</span>+<span class="string">"enablevr=<span class="subst">\"</span>false<span class="subst">\"</span> title=<span class="subst">\"</span><span class="subst">\"</span> /&gt;      &lt;scenes&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;scene name=<span class="subst">\"</span>pano1<span class="subst">\"</span> title=<span class="subst">\"</span><span class="subst">\"</span>  "</span>+ <span class="string">"thumburl=<span class="subst">\"</span><span class="subst">\"</span>&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;preview url=<span class="subst">\"</span>%s<span class="subst">\"</span> type=<span class="subst">\"</span>CUBESTRIP<span class="subst">\"</span>&gt;&lt;/preview&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;image type=<span class="subst">\"</span>%s<span class="subst">\"</span> "</span>+ <span class="string">"url=<span class="subst">\"</span>%s<span class="subst">\"</span> degree=<span class="subst">\"</span>%d<span class="subst">\"</span> device=<span class="subst">\"</span>%d<span class="subst">\"</span>/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/scene&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/scenes&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/DetuVr&gt;"</span>;</span><br></pre></td></tr></table></figure><p>初始化XML配置</p><p>String xmlstring = String.format(T,””,”video”, “需要加载的地址”, 240,1);</p><p>//[type=video，degree =240(鱼眼度数)，device=1(鱼眼设备类型)]</p><p>加载xml</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panoplayerurl.setXmlContent(xmlstring)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>开始播放</p><p>renderer.Play(panoplayerurl);</p><p>注: 可使用的文件路径规则:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://site.com/image.png"</span> <span class="comment">// from Web</span></span><br><span class="line"></span><br><span class="line"><span class="string">"file:///mnt/sdcard/image.png"</span> <span class="comment">// from SD card</span></span><br><span class="line"></span><br><span class="line"><span class="string">"assets://image.png"</span> <span class="comment">// from assets</span></span><br><span class="line"></span><br><span class="line"><span class="string">"drawable://"</span> + R<span class="selector-class">.drawable</span><span class="selector-class">.img</span> <span class="comment">// from drawables</span></span><br></pre></td></tr></table></figure><p>播放回调函数调用</p><p><strong>播放图片回调：</strong></p><p>在播放图片时可通过IPanoPlayerListener接口绑定播放事件:</p><p>renderer.setListener(IPanoPlayerListener listener);</p><p><strong>播放视频回调：</strong></p><p>在播放视频时需同时绑定IPanoPlayerListener和IPanoPlayerVideoPluginListener接口才可获取到完整的播放事件:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderer.setListener(IPanoPlayerListener listener)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">renderer.setVideoPluginListener(IPanoPlayerVideoPluginListener listener)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>播放回调说明：</strong></p><p><table cellpadding="0" cellspacing="0"></table></p><p><tbody></tbody></p><tr><td><strong>回调接口</strong><br></td><td><strong>包含回调</strong><br></td><td><strong>回调说明</strong><br></td><br></tr><br><tr><br><br><td>IPanoPlayerListener<br></td><td>void PanoPlayOnLoading()<br></td><td>播放器数据正在加载中<br></td><br></tr><br><tr><br><br><td><br></td><td>void PanoPlayOnLoaded()<br></td><td>播放器数据加载完成<br></td><br></tr><br><tr><br><br><td><br></td><td>void PanoPlayOnEnter(PanoramaData var1)<br></td><td>播放器场景加载完成<br></td><br></tr><br><tr><br><br><td><br></td><td>void PanoPlayOnLeave(PanoramaData var1);<br></td><td>播放器场景已移除<br></td><br></tr><br><tr><br><br><td><br></td><td>void PanoPlayOnError(PanoPlayerErrorCode var1)<br></td><td>播放出错<br></td><br></tr><br><tr><br><br><td>IPanoPlayerVideoPluginListener<br></td><td>void PluginVideoOnInit()<br></td><td>播放器数据初始化完成<br></td><br></tr><br><tr><br><br><td><br></td><td>void PluginVideoOnStatusChanged(PanoVideoPluginStatus status)<br></td><td>播放状态变化<br></td><br></tr><br><tr><br><br><td><br></td><td>void PluginVideoOnProgressChanged(int curTime, int bufTime, int maxTime)<br></td><td>播放进度变化。其中curTime为当前播放的位置；bufTime为缓冲位置；maxTime为视频总长度<br></td><br></tr><br><tr><br><br><td><br></td><td>void PluginVideoOnSeekFinished()<br></td><td>视频进度拖动完成<br></td><br></tr><br><tr><br><br><td><br></td><td>void PluginVideOnPlayerError(PanoPlayerErrorStatus var1, String var2)<br></td><td>播放出错<br></td><br></tr><br><br><br>模式切换<br><br>在播放图片和视频时还可进行模式切换,有两种方式: 直接切换和渐变切换,您可根据需要选择其中一种。<br><br>直接切换：<br><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.setViewMode(ViewMode mode)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br>渐变切换 :<br><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prenderer.setAnimationViewMode(ViewMode mode)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br>模式说明<br><table cellpadding="0" cellspacing="0"><br><tbody><br><tr><br><br><td><strong>模式</strong><br></td><td><strong>说明</strong><br></td><br></tr><br><tr><br><br><td>ViewMode.VIEWMODE_FISHEYE<br></td><td>鱼眼模式<br></td><br></tr><br><tr><br><br><td>ViewMode.VIEWMODE_LITTLEPLANET<br></td><td>小行星模式<br></td><br></tr><br><tr><br><br><td>ViewMode.VIEWMODE_DEF<br></td><td>默认模式<br></td><br></tr><br><tr><br><br><td>ViewMode.VIEWMODE_PLANE<br></td><td>平面模式<br></td><br></tr><br><tr><br><br><td>ViewMode.VIEWMODE_VR<br></td><p><td>VR 模式<br></td><br></p></tr><br></tbody><br></table><br>其他设置<p></p><p><strong>设置陀螺仪开关</strong></p><p>可调用renderer.setGyroEnable(boolean enable);来设置播放器是否使用陀螺仪：enable 为true 时,陀螺仪可用;为false 时,陀螺仪不可用。</p><p><strong>视频播放进度控制</strong></p><p>在视频播放过程中还可进行视频播放控制。在public void PluginVideoOnInit()函数中获取播放器插件控制器：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">PluginVideoOnInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Plugin plugin = renderer.getCurPlugin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (plugin <span class="keyword">instanceof</span> VideoPlugin) &#123;</span><br><span class="line"></span><br><span class="line">videoplugin = (VideoPlugin) plugin;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置播放器日志级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//videoplugin.setLogLevel(IjkMediaPlayer.IJK_LOG_VERBOSE);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从某一时刻开始播放:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videoplugin.seekTo(int progress)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>获取播放缓冲百分比:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int buffr</span> = videoplugin.getreadBufferingPercent();</span><br></pre></td></tr></table></figure><p>暂停播放:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videoplugin.pause()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>开始播放:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videoplugin.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>重新播放:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videoplugin.replayer()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>注意事项</p><p>为了更好的管理播放器资源引用,您需在您的onDestroy() 方法手动销毁播放器,释放播放资源。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (renderer != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">renderer.release();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>        更多内容请关注个人微信公众帐号：极客峰        </strong></p><p><img src="http://static.oschina.net/uploads/space/2016/0523/143108_nxSf_2448717.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发之触摸事件及手势</title>
      <link href="/article/17/"/>
      <url>/article/17/</url>
      
        <content type="html"><![CDATA[<p><strong>1、**</strong>iOS<strong>**中的事件</strong></p><p>在用户使用app过程中，会产生各种各样的事件，iOS中的事件可以分为3大类型：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205242_f0qx.png" alt=""></p><p><strong>2**</strong>、响应者对象**</p><p>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象”，</p><p>UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件。</p><p><strong>2**</strong>、<strong>**UIResponder</strong></p><p><strong>继承了**</strong>UIResponder<strong>**就可以处理事件。</strong>UIResponder内部提供了以下方法来处理事件：</p><p><strong>触摸事件：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>touchesBegan:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>touchesMoved:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>touchesEnded:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>touchesCancelled:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure><p><strong>加速计事件：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>motionBegan:<span class="params">(UIEventSubtype)</span>motion withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>motionEnded:<span class="params">(UIEventSubtype)</span>motion withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>motionCancelled:<span class="params">(UIEventSubtype)</span>motion withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure><p><strong>远程控制事件：</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)remoteControlReceivedWithEvent:(UIEvent *)<span class="keyword">event</span>;</span><br></pre></td></tr></table></figure><p><strong>3**</strong>、<strong><strong>UIView</strong></strong>的触摸事件处理**</p><p>UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件：</p><p>一根或者多根手指开始触摸view，系统会自动调用view的下面方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>touchesBegan:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event</span><br></pre></td></tr></table></figure><p>一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>touchesMoved:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event</span><br></pre></td></tr></table></figure><p>一根或者多根手指离开view，系统会自动调用view的下面方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>touchesEnded:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event</span><br></pre></td></tr></table></figure><p>触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>touchesCancelled:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event</span><br></pre></td></tr></table></figure><p>【备注】touches中存放的都是UITouch对象。UIView默认情况下是不支持多点触控的，设置使它支持多点触控的方法为勾选下面选项：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205242_Exff.png" alt=""></p><p>通过上面touches参数可以取得关于手指移动的各种数据，例如，使UIView随手指移动：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 当前触摸点，设置以自己为参照，坐标原点为自己（self）的左上角</span></span><br><span class="line">    <span class="built_in">CGPoint</span> current = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 上一个触摸点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> previous = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 修改当前view的位置(中点)</span></span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span>.center;</span><br><span class="line">    center.x += current.x - previous.x;</span><br><span class="line">    center.y += current.y - previous.y;</span><br><span class="line">    <span class="keyword">self</span>.center = center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4**</strong>、<strong>**UITouch</strong></p><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象，一根手指对应一个UITouch对象。</p><p>UITouch的作用</p><p>保存着跟手指相关的信息，比如触摸的位置、时间、阶段：</p><p>（1）当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</p><p>（2）当手指离开屏幕时，系统会销毁相应的UITouch对象</p><p>【备注】iPhone开发中，要避免使用双击事件！</p><p><strong>5**</strong>、<strong><strong>UITouch</strong></strong>的属性**</p><p>触摸产生时所处的窗口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) UIWindow    *window;</span><br></pre></td></tr></table></figure><p>触摸产生时所处的视图：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) UIView      *view;</span><br></pre></td></tr></table></figure><p>短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) NSUInteger          tapCount;</span><br></pre></td></tr></table></figure><p>记录了触摸事件产生或变化时的时间，单位是秒：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) NSTimeInterval      timestamp;</span><br></pre></td></tr></table></figure><p>当前触摸事件所处的状态：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) UITouchPhase        phase;</span><br></pre></td></tr></table></figure><p>【备注】UITouchPhase是一个枚举类型，包含：</p><p>UITouchPhaseBegan（触摸开始）</p><p>UITouchPhaseMoved（接触点移动）</p><p>UITouchPhaseStationary（接触点无移动）</p><p>UITouchPhaseEnded（触摸结束）</p><p>UITouchPhaseCancelled（触摸取消）</p><p><strong>6**</strong>、<strong><strong>UITouch</strong></strong>的方法**</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(CGPoint)</span>locationInView:<span class="params">(UIView *)</span>view;</span><br></pre></td></tr></table></figure><p>返回值表示触摸在view上的位置，这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)），调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(CGPoint)</span>previousLocationInView:<span class="params">(UIView *)</span>view;</span><br></pre></td></tr></table></figure><p>该方法记录了前一个触摸点的位置</p><p><strong>7**</strong>、<strong>**UIEvent</strong></p><p>每产生一个事件，就会产生一个UIEvent对象。</p><p><strong>UIEvent**</strong>：**</p><p>称为事件对象，记录事件产生的时刻和类型</p><p><strong>常见属性：</strong></p><p>事件类型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) UIEventType     type;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) UIEventSubtype  subtype;</span><br></pre></td></tr></table></figure><p>事件产生的时间：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) NSTimeInterval  timestamp;</span><br></pre></td></tr></table></figure><p>【备注】UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch）。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventType</span>) &#123;</span><br><span class="line">    <span class="type">UIEventTypeTouches</span>,</span><br><span class="line">    <span class="type">UIEventTypeMotion</span>,</span><br><span class="line">    <span class="type">UIEventTypeRemoteControl</span>,</span><br><span class="line">&#125;;</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventSubtype</span>) &#123;</span><br><span class="line">    // available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeNone</span>                              = 0,</span><br><span class="line">   </span><br><span class="line">    // for <span class="type">UIEventTypeMotion</span>, available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeMotionShake</span>                       = 1,</span><br><span class="line">   </span><br><span class="line">    // for <span class="type">UIEventTypeRemoteControl</span>, available in iOS 4.0</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPlay</span>                 = 100,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPause</span>                = 101,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlStop</span>                 = 102,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlTogglePlayPause</span>      = 103,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlNextTrack</span>            = 104,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPreviousTrack</span>        = 105,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = 106,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = 107,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = 108,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingForward</span>    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code></code><strong>8**</strong>、<strong><strong>touches</strong></strong>和<strong><strong>event</strong></strong>参数**</p><p>一次完整的触摸过程，会经历3个状态：</p><p><strong>触摸开始：</strong>- (void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p><p><strong>触摸移动：</strong>- (void)touchesMoved:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p><p><strong>触摸结束：</strong>- (void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p><p><strong>触摸取消（可能会经历）：</strong>- (void)touchesCancelled:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p><p>4个触摸事件处理方法中，都有NSSet <em>touches和UIEvent </em>event两个参数：</p><p>（1）一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数</p><p>（2）如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p><p>（3）如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象</p><p>（4）根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸</p><p>【备注】</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventType</span>) &#123;</span><br><span class="line">    <span class="type">UIEventTypeTouches</span>,</span><br><span class="line">    <span class="type">UIEventTypeMotion</span>,</span><br><span class="line">    <span class="type">UIEventTypeRemoteControl</span>,</span><br><span class="line">&#125;;</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventSubtype</span>) &#123;</span><br><span class="line">    // available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeNone</span>                              = 0,</span><br><span class="line">   </span><br><span class="line">    // for <span class="type">UIEventTypeMotion</span>, available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeMotionShake</span>                       = 1,</span><br><span class="line">   </span><br><span class="line">    // for <span class="type">UIEventTypeRemoteControl</span>, available in iOS 4.0</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPlay</span>                 = 100,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPause</span>                = 101,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlStop</span>                 = 102,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlTogglePlayPause</span>      = 103,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlNextTrack</span>            = 104,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPreviousTrack</span>        = 105,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = 106,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = 107,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = 108,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingForward</span>    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>9**</strong>、事件的产生和传递**</p><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow），主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步，找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理：</p><p>touchesBegan…</p><p>touchesMoved…</p><p>touchedEnded…</p><p>事件传递示例：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205242_tmpK.png" alt=""></p><p>触摸事件的传递是从父控件传递到子控件：</p><p>（1）点击了绿色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 绿色</p><p>（2）点击了蓝色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色</p><p>（3）点击了黄色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色 -&gt; 黄色</p><p>【备注】<strong>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件**</strong>(<strong><strong>掌握</strong></strong>)<strong>**。</strong></p><p><strong>10**</strong>、<strong><strong>UIView</strong></strong>不接收触摸事件的三种情况**</p><p>（1）不接收用户交互</p><p>userInteractionEnabled = NO</p><p>（2）隐藏</p><p>hidden = YES</p><p>（3）透明</p><p>alpha = 0.0 ~ 0.01</p><p>【备注】UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。</p><p><strong>11、    **</strong>触摸事件处理的详细过程**</p><p>用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件。找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理：</p><p>touchesBegan…</p><p>touchesMoved…</p><p>touchedEnded…</p><p>这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理。</p><p><strong>12**</strong>、响应者链条示意图**</p><p><strong><img src="http://static.oschina.net/uploads/img/201508/31205242_NXUz.png" alt=""></strong></p><p><strong>11、    **</strong>响应者链的事件传递过程**</p><p>（1）如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图。</p><p>（2）在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。</p><p>（3）如果window对象也不处理，则其将事件或消息传递给UIApplication对象。</p><p>（4）如果UIApplication也不能处理该事件或消息，则将其丢弃。</p><p><strong>13**</strong>、触摸事件完整处理过程**</p><p>1、先将事件对象由上往下传递（由父控件传递给子控件），找到最合适的控件来处理事件。</p><p>2、调用最合适控件的touches…方法。</p><p>3、如果这个控件调用了[super touches…];就会将事件顺着相应链条往下传递，传递给下一个响应者。</p><p>4、接着就会调用下一个响应者的touches…方法。</p><p>5、事件还可以继续往下传递，直到UIApplication，如果UIApplication也不处理该事件或消息，则将其丢弃。</p><p>【备注】关于上面的下一个响应者：</p><p>(1) 如果当前这个View是控制器的View，那么控制器就是下一个响应者。</p><p>(2) 如果当前这个View不是控制器的View，那么父控件就是下一个响应者。</p><p><strong>14**</strong>、<strong>**UIGestureRecognizer</strong></p><p>如果想监听一个view上面的触摸事件，<strong>之前的做法</strong>是：</p><p>（1）自定义一个view。</p><p>（2）实现view的touches方法，在方法内部实现具体处理代码。</p><p>通过touches方法监听view触摸事件，有很明显的几个缺点：</p><p>（1）必须得自定义view。</p><p>（2）由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件。</p><p>（3）不容易区分用户的具体手势行为。</p><p>iOS 3.2之后，苹果推出了手势识别功能（Gesture Recognizer），在触摸事件处理方面，大大简化了开发者的开发难度。</p><p>为了完成手势识别，必须借助于手势识别器—-<strong>UIGestureRecognizer</strong>，利用UIGestureRecognizer，能轻松识别用户在某个view上面做的一些常见手势，UIGestureRecognizer是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势：</p><p>（1）UITapGestureRecognizer(敲击)</p><p>（2）UIPinchGestureRecognizer(捏合，用于缩放)</p><p>（3）UIPanGestureRecognizer(拖拽)</p><p>（4）UISwipeGestureRecognizer(轻扫)</p><p>（5）UIRotationGestureRecognizer(旋转)</p><p>（6）UILongPressGestureRecognizer(长按)</p><p><strong>15**</strong>、<strong>**UITapGestureRecognizer</strong></p><p><strong>1**</strong>、使用方法**</p><p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下：</p><p>先勾选如下选项：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205242_0iJy.png" alt=""></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建手势识别器对象</span></span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</span><br><span class="line"><span class="comment">//第二步：设置手势识别器对象的具体属性（默认为敲击一次）</span></span><br><span class="line"><span class="comment">// 连续敲击2次</span></span><br><span class="line">tap.numberOfTapsRequired = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 需要2根手指一起敲击</span></span><br><span class="line">tap.numberOfTouchesRequired = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//第三步：添加手势识别器到对应的view上</span></span><br><span class="line">[self.iconView <span class="string">addGestureRecognizer:</span>tap];</span><br><span class="line"><span class="comment">//第四步：监听手势的触发</span></span><br><span class="line">[tap <span class="string">addTarget:</span>self <span class="string">action:</span><span class="meta">@selector</span>(<span class="string">tapIconView:</span>)];</span><br></pre></td></tr></table></figure><p>事件发生会调用自定义的tapIconView方法。</p><p>【备注】通过tap.view可以获得被点击的那个view。</p><p>2、UITapGestureRecognizer的代理</p><p>设置UITapGestureRecognizer的代理为被点击UIView所在的控制器，遵守代理协议UITapGestureRecognizerDelegate。之后就可以实现相应代理方法，比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  当点击view的时候,会先调用这个方法，返回NO则拦截了</span></span><br><span class="line"><span class="comment">*点击事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//使只有点击左边一半才起反应，点击右边没反应</span></span><br><span class="line">    <span class="built_in">CGPoint</span> pos = [touch locationInView:touch.view];</span><br><span class="line">    <span class="keyword">if</span> (pos.x &lt;= <span class="keyword">self</span>.iconView.frame.size.width * <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16**</strong>、手势识别的状态**</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIGestureRecognizerState</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有触摸事件发生，所有手势识别的默认状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStatePossible</span>,</span><br><span class="line">    <span class="comment">// 一个手势已经开始但尚未改变或者完成时</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateBegan</span>,</span><br><span class="line">    <span class="comment">// 手势状态改变</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateChanged</span>,</span><br><span class="line">    <span class="comment">// 手势完成</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateEnded</span>,</span><br><span class="line">    <span class="comment">// 手势取消，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateCancelled</span>,</span><br><span class="line">    <span class="comment">// 手势失败，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateFailed</span>,</span><br><span class="line">    <span class="comment">// 识别到手势识别</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateRecognized</span> = <span class="built_in">UIGestureRecognizerStateEnded</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>手势识别状态变化示意图：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205242_oF6h.png" alt=""></p><h2 id="更多内容与学习交流请关注个人微信公众账号：极客峰"><a href="#更多内容与学习交流请关注个人微信公众账号：极客峰" class="headerlink" title="更多内容与学习交流请关注个人微信公众账号：极客峰"></a>更多内容与学习交流请关注个人微信公众账号：极客峰</h2><p><a href="http://static.oschina.net/uploads/space/2016/0527/002254_QrEI_2448717.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/space/2016/0527/002254_QrEI_2448717.jpg" alt=""></a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手势 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发之Autolayout</title>
      <link href="/article/16/"/>
      <url>/article/16/</url>
      
        <content type="html"><![CDATA[<p><strong>1**</strong>、概述**</p><p><strong>在以前的**</strong>iOS<strong><strong>程序中，是如何设置布局</strong></strong>UI<strong>**界面的？</strong></p><p>（1）经常编写大量的坐标计算代码</p><p>（2）为了保证在3.5 inch和4.0 inch屏幕上都能有完美的UI界面效果，有时还需要分别为2种屏幕编写不同的坐标计算代码（即传说中的“屏幕适配”）</p><p><strong>什么是**</strong>Autolayout<strong>**？</strong></p><p>（1）Autolayout是一种“自动布局”技术，专门用来布局UI界面的</p><p>（2）Autolayout自iOS 6开始引入，由于Xcode 4的不给力，当时并没有得到很大推广</p><p>（3）自iOS 7（Xcode 5）开始，Autolayout的开发效率得到很大的提升</p><p>（4）苹果官方也推荐开发者尽量使用Autolayout来布局UI界面</p><p>（5）Autolayout能很轻松地解决屏幕适配的问题</p><p><strong>Autoresizing</strong></p><p>（1）在Autolayout之前，有Autoresizing可以作屏幕适配，但局限性较大，有些任务根本无法完成</p><p>（2）相比之下，Autolayout的功能比Autoresizing强大很多</p><p><strong>Autolayout**</strong>的<strong><strong>2</strong></strong>个核心概念：**</p><p>（1）参照</p><p>（2）约束</p><p><strong>2**</strong>、<strong><strong>Autolayout</strong></strong>的警告和错误**</p><p><strong>警告：</strong></p><p>控件的frame不匹配所添加的约束, 比如：</p><p>约束控件的宽度为100, 而控件现在的宽度是110</p><p><strong>错误：</strong></p><p>缺乏必要的约束, 比如：</p><p>只约束了宽度和高度, 没有约束具体的位置</p><p>两个约束冲突, 比如：</p><p>1个约束控件的宽度为100, 1个约束控件的宽度为110</p><p><strong>3**</strong>、代码实现<strong>**Autolayout</strong></p><p>代码实现Autolayout的步骤：</p><p>第一步：利用NSLayoutConstraint类创建具体的约束对象</p><p>第二步：添加约束对象到相应的view上</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addConstraint:<span class="params">(NSLayoutConstraint *)</span>constraint;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>addConstraints:<span class="params">(NSArray *)</span>constraints;</span><br></pre></td></tr></table></figure><p>代码实现Autolayout的注意点：</p><p>（1）要先禁止autoresizing功能，设置view的下面属性为NO</p><p>view.translatesAutoresizingMaskIntoConstraints = NO;</p><p>（2）添加约束之前，一定要保证相关控件都已经在各自的父控件上</p><p>（3）<strong>不用再给**</strong>view<strong><strong>设置</strong></strong>frame**</p><p><strong>4**</strong>、<strong>**NSLayoutConstraint</strong></p><p>一个NSLayoutConstraint对象就代表一个约束。</p><p>创建约束对象的常用方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">id</span>)constraintWithItem:(<span class="keyword">id</span>)view1 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1 relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation toItem:(<span class="keyword">id</span>)view2 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 multiplier:(<span class="built_in">CGFloat</span>)multiplier constant:(<span class="built_in">CGFloat</span>)c;</span><br></pre></td></tr></table></figure><p>view1 ：要约束的控件</p><p>attr1 ：约束的类型（做怎样的约束）</p><p>relation ：与参照控件之间的关系</p><p>view2 ：参照的控件</p><p>attr2 ：约束的类型（做怎样的约束）</p><p>multiplier ：乘数</p><p>c ：常量</p><p><strong>自动布局有个核心公式：</strong></p><p>obj1.property1 =（obj2.property2 * multiplier）+ constant value</p><p>例如：实现下面效果：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205309_jqMs.png" alt=""></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">(void)viewDidLoad</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="string">[super</span> <span class="string">viewDidLoad];</span></span><br><span class="line">   </span><br><span class="line">    <span class="string">//</span> <span class="number">1.</span><span class="string">添加控件</span></span><br><span class="line">    <span class="string">UIView</span> <span class="meta">*blueView</span> <span class="string">=</span> <span class="string">[[UIView</span> <span class="string">alloc]</span> <span class="string">init];</span></span><br><span class="line">    <span class="string">blueView.backgroundColor</span> <span class="string">=</span> <span class="string">[UIColor</span> <span class="string">blueColor];</span></span><br><span class="line">    <span class="string">blueView.translatesAutoresizingMaskIntoConstraints</span> <span class="string">=</span> <span class="literal">NO</span><span class="string">;</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addSubview:blueView];</span></span><br><span class="line">   </span><br><span class="line">    <span class="string">UIView</span> <span class="meta">*redView</span> <span class="string">=</span> <span class="string">[[UIView</span> <span class="string">alloc]</span> <span class="string">init];</span></span><br><span class="line">    <span class="string">redView.backgroundColor</span> <span class="string">=</span> <span class="string">[UIColor</span> <span class="string">redColor];</span></span><br><span class="line">    <span class="string">redView.translatesAutoresizingMaskIntoConstraints</span> <span class="string">=</span> <span class="literal">NO</span><span class="string">;</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addSubview:redView];</span></span><br><span class="line">   </span><br><span class="line">    <span class="string">//</span> <span class="number">2.</span><span class="string">约束蓝色</span></span><br><span class="line">    <span class="string">//</span> <span class="number">2.1</span><span class="string">.高度</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*blueHeight</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:blueView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeHeight</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">nil</span> <span class="attr">attribute:NSLayoutAttributeNotAnAttribute</span> <span class="attr">multiplier:1.0</span></span><br><span class="line"><span class="attr">constant:</span><span class="number">40</span><span class="string">];</span></span><br><span class="line">    <span class="string">[blueView</span> <span class="attr">addConstraint:blueHeight];</span></span><br><span class="line">    <span class="string">//</span> <span class="number">2.2</span><span class="string">.左边间距</span></span><br><span class="line">    <span class="string">CGFloat</span> <span class="string">margin</span> <span class="string">=</span> <span class="number">20</span><span class="string">;</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*blueLeft</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:blueView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeLeft</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">self.view</span> <span class="attr">attribute:NSLayoutAttributeLeft</span> <span class="attr">multiplier:1.0</span> <span class="attr">constant:</span></span><br><span class="line"><span class="string">margin];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:blueLeft];</span></span><br><span class="line">    <span class="string">//</span> <span class="number">2.3</span><span class="string">.顶部间距</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*blueTop</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:blueView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeTop</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">self.view</span> <span class="attr">attribute:NSLayoutAttributeTop</span> <span class="attr">multiplier:1.0</span> <span class="attr">constant:</span></span><br><span class="line"><span class="string">margin];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:blueTop];</span></span><br><span class="line">    <span class="string">//</span> <span class="number">2.4</span><span class="string">.右边间距</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*blueRight</span> <span class="string">=</span></span><br><span class="line"> <span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:blueView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeRight</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">self.view</span> <span class="attr">attribute:NSLayoutAttributeRight</span> <span class="attr">multiplier:1.0</span> <span class="attr">constant:</span></span><br><span class="line"><span class="bullet">-</span><span class="string">margin];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:blueRight];</span></span><br><span class="line">   </span><br><span class="line">    <span class="string">//</span> <span class="number">3.</span><span class="string">约束红色</span></span><br><span class="line">    <span class="string">//</span> <span class="number">3.1</span><span class="string">.让红色右边</span> <span class="string">==</span> <span class="string">蓝色右边</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*redRight</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:redView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeRight</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">blueView</span> <span class="attr">attribute:NSLayoutAttributeRight</span> <span class="attr">multiplier:1.0</span></span><br><span class="line"><span class="attr">constant:</span><span class="number">0.0</span><span class="string">];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:redRight];</span></span><br><span class="line"> </span><br><span class="line">    <span class="string">//</span> <span class="number">3.2</span><span class="string">.让红色高度</span> <span class="string">==</span> <span class="string">蓝色高度</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*redHeight</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:redView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeHeight</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">blueView</span> <span class="attr">attribute:NSLayoutAttributeHeight</span> <span class="attr">multiplier:1.0</span> <span class="attr">constant:</span></span><br><span class="line"><span class="number">0.0</span><span class="string">];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:redHeight];</span></span><br><span class="line">   </span><br><span class="line">    <span class="string">//</span> <span class="number">3.3</span><span class="string">.让红色顶部</span> <span class="string">==</span> <span class="string">蓝色底部</span> <span class="string">+</span> <span class="string">间距</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*redTop</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:redView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeTop</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">blueView</span> <span class="attr">attribute:NSLayoutAttributeBottom</span> <span class="attr">multiplier:1.0</span> <span class="attr">constant:</span></span><br><span class="line"><span class="string">margin];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:redTop];</span></span><br><span class="line">   </span><br><span class="line">    <span class="string">//</span> <span class="number">3.4</span><span class="string">.让红色宽度</span> <span class="string">==</span> <span class="string">蓝色宽度</span> <span class="string">*</span> <span class="number">0.5</span></span><br><span class="line"><span class="string">NSLayoutConstraint</span> <span class="meta">*redWidth</span> <span class="string">=</span></span><br><span class="line"><span class="string">[NSLayoutConstraint</span> <span class="attr">constraintWithItem:redView</span> <span class="attr">attribute:</span></span><br><span class="line"><span class="string">NSLayoutAttributeWidth</span> <span class="attr">relatedBy:NSLayoutRelationEqual</span> <span class="attr">toItem:</span></span><br><span class="line"><span class="string">blueView</span> <span class="attr">attribute:NSLayoutAttributeWidth</span> <span class="attr">multiplier:0.5</span> <span class="attr">constant:</span></span><br><span class="line"><span class="number">0.0</span><span class="string">];</span></span><br><span class="line">    <span class="string">[self.view</span> <span class="attr">addConstraint:redWidth];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>5**</strong>、添加约束的规则**</p><p>在创建约束之后，需要将其添加到作用的view上。</p><p>在添加时要注意目标view需要遵循以下规则：</p><p>（1）对于两个同层级view之间的约束关系，添加到它们的父view上</p><p><img src="http://static.oschina.net/uploads/img/201508/31205309_qAoN.png" alt=""></p><p>（2）对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上</p><p><img src="http://static.oschina.net/uploads/img/201508/31205309_cek6.png" alt=""></p><p>（3）对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上</p><p><img src="http://static.oschina.net/uploads/img/201508/31205309_Ghbt.png" alt=""></p><p><strong>6**</strong>、<strong><strong>VFL</strong></strong>语言**</p><p>什么是VFL语言？</p><p>VFL全称是Visual Format Language，翻译过来是“可视化格式语言”，是苹果公司为了简化Autolayout的编码而推出的抽象语言。</p><p><img src="http://static.oschina.net/uploads/img/201508/31205311_gpgd.png" alt=""></p><p><strong>7**</strong>、<strong><strong>VFL</strong></strong>示例**</p><p>H:[cancelButton(72)]-12-[acceptButton(50)]</p><p>canelButton宽72，acceptButton宽50，它们之间间距12</p><p>H:[wideView(&gt;=60@700)]</p><p>wideView宽度大于等于60point，该约束条件优先级为700（优先级最大值为1000，优先级越高的约束越先被满足）</p><p>V:[redBox]-[yellowBox(==redBox)]</p><p>竖直方向上，先有一个redBox，其下方紧接一个高度等于redBox高度的yellowBox</p><p>H:|-10-[Find]-[FindNext]-[FindField(&gt;=20)]-|</p><p>水平方向上，Find距离父view左边缘默认间隔宽度，之后是FindNext距离Find间隔默认宽度；再之后是宽度不小于20的FindField，它和FindNext以及父view右边缘的间距都是默认宽度。（竖线“|” 表示superview的边缘）</p><p><strong>8**</strong>、<strong><strong>VFL</strong></strong>的使用**</p><p>使用VFL来创建约束数组：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format options:(<span class="built_in">NSLayoutFormatOptions</span>)opts metrics:(<span class="built_in">NSDictionary</span> *)metrics views:(<span class="built_in">NSDictionary</span> *)views;</span><br></pre></td></tr></table></figure><p>format ：VFL语句</p><p>opts ：约束类型</p><p>metrics ：VFL语句中用到的具体数值</p><p>views ：VFL语句中用到的控件</p><p>创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义：</p><p>NSDictionaryOfVariableBindings(…)</p><p>例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *views =</span><br><span class="line"></span><br><span class="line">NSDictionaryOfVariableBindings(blueView, redView);</span><br><span class="line"></span><br><span class="line">NSArray *conts2 =</span><br><span class="line"></span><br><span class="line">[NSLayoutConstraint <span class="string">constraintsWithVisualFormat:</span></span><br><span class="line"></span><br><span class="line">@<span class="string">"V:[blueView(==blueHeight)]-margin-|"</span> <span class="string">options:</span><span class="number">0</span> <span class="string">metrics:</span></span><br><span class="line"></span><br><span class="line">@&#123;@<span class="string">"blueHeight"</span> : @<span class="number">40</span>, @<span class="string">"margin"</span> : @<span class="number">20</span>&#125; <span class="string">views:</span>views];</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 1.添加控件</span></span><br><span class="line">    <span class="built_in">UIView</span> *blueView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    blueView.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    blueView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:blueView];</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:redView];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2.VFL生成约束</span></span><br><span class="line"><span class="built_in">NSArray</span> *conts =</span><br><span class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:</span><br><span class="line"><span class="string">@"H:|-20-[blueView]-20-|"</span> options:<span class="number">0</span> metrics:<span class="literal">nil</span> views:</span><br><span class="line">@&#123;<span class="string">@"blueView"</span> : blueView&#125;];</span><br><span class="line">    [<span class="keyword">self</span>.view addConstraints:conts];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSArray</span> *conts2 =</span><br><span class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:</span><br><span class="line"><span class="string">@"V:|-20-[blueView(40)]-20-[redView(==blueView)]"</span> options:<span class="built_in">NSLayoutFormatAlignAllRight</span> metrics:<span class="literal">nil</span> views:@&#123;<span class="string">@"blueView"</span> : blueView, <span class="string">@"redView"</span> : redView&#125;];</span><br><span class="line">    [<span class="keyword">self</span>.view addConstraints:conts2];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *redWidth =</span><br><span class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:</span><br><span class="line"><span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:</span><br><span class="line">blueView attribute:<span class="built_in">NSLayoutAttributeWidth</span> multiplier:<span class="number">0.5</span> constant:</span><br><span class="line"><span class="number">0.0</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addConstraint:redWidth];</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p><code></code>运行效果图：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205311_JL2n.png" alt=""></p><p><strong>9**</strong>、<strong><strong>有了</strong></strong>Autolayout<strong><strong>的</strong></strong>UILabel**</p><p>在没有Autolayout之前，UILabel的文字内容总是居中显示，导致顶部和底部会有一大片空缺区域：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205311_0QtM.png" alt=""></p><p>有Autolayout之后，UILabel的bounds默认会自动包住所有的文字内容，顶部和底部不再会有空缺区域：</p><p><img src="http://static.oschina.net/uploads/img/201508/31205311_YRzi.png" alt=""></p><p><strong>10**</strong>、<strong><strong>基于</strong></strong>Autolayout<strong>**的动画</strong></p><p>在修改了约束之后，只要执行下面代码，就能做动画效果：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">UIView</span> animateWithDuration:1.0 animations:^&#123;</span><br><span class="line"></span><br><span class="line">[<span class="name">添加了约束的view</span> layoutIfNeeded]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.leftMargin.constant = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">self</span>.width.constant = <span class="number">200</span>;</span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.0</span> animations:^&#123;</span><br><span class="line">     <span class="comment">//父控件和redView都添加了约束</span></span><br><span class="line">     [<span class="keyword">self</span>.view layoutIfNeeded];</span><br><span class="line">     [<span class="keyword">self</span>.redView layoutIfNeeded];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>更多内容与学习交流请关注个人微信公众账号：极客峰</p><p><a href="http://static.oschina.net/uploads/space/2016/0527/002254_QrEI_2448717.jpg" target="_blank" rel="noopener"><img src="http://static.oschina.net/uploads/space/2016/0527/002254_QrEI_2448717.jpg" alt=""></a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Autolayout </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>教你破解隔壁妹子的wifi密码，成功率高达90%</title>
      <link href="/article/15/"/>
      <url>/article/15/</url>
      
        <content type="html"><![CDATA[<p>破解wifi密码听起来很复杂，实际上也不是非常的复杂，极客君（微信公众帐号：极客峰）今天教大家如何破解隔壁妹子的wifi密码。</p><p><strong>首先声明：本教程只用于技术交流，请勿用于非法用途。请严格遵循相关法律法规。为了保护本例中被破解密码者信息，本人不透露wifi主人所在地理位置。本人有宽带，也不会使用被破解者的wifi。</strong></p><p>目前无线网络加密形式常见的有两种，WEP和WPA/WPA2，WEP破解方法非常简单，但是现在这种加密方式由于不安全基本上见不到了。这里就没有必要讨论WEP破解方法了。</p><p>今天我们要破解的正是最难破解的WPA/WPA2加密方式的密码！WPA/WPA2破解的主流方法有Pin码破解、抓包破解。</p><p>Pin码破解最简单成功率最高，但是必须要路由器开启wps才行，而且很多最新的路由器都有防pin码破解功能，对于Pin码破解，大家可以用虚拟机安装CDLinux系统，里面集成了相关的软件，网上百度一下就能找到相关的教程。</p><p>今天我们要讲的是抓包破解，如果路由器没有开启wps，Pin码破解的方式就不能用了，对于路由器开启了wps功能创建的wifi来说，抓包破解wifi密码的成功率要低于pin码破解，但是如果有了强大有效密码字典后，抓包破解的成功率将会骤升，就是路由器没有开启wps功能，抓包破解照样能破解wifi密码。</p><p>抓包破解又称暴力破解，就是对密码字典中的密码逐个试，直到找到正确的密码，你可以做个包含所有密码的密码字典（后面会有密码字典生成教程，也会提供高成功率的密码字典包），让机器逐个试，成功率百分之百，但是这种方法不科学，因为所有密码的字典包会非常非常大，里面包含很多不可能出现的密码，浪费时间。</p><p>本教程中使用的电脑为Mac，如果使用其他电脑也不影响，都大同小异，原理都是一样的，非Mac看完此教程后可以结合网上其他教程进行破解测试。</p><p>在破解wifi密码之前，我们要有一个有效的密码字典包，里面要包含大家最常用的密码，还要根据大家的习惯设置相应的密码。我们怎么看大家最常用的密码呢？我在某个软件里看到了常见的wifi密码，上面提示，40%的人用了这些密码，所以你得密码字典中只要包含了这些密码，你就可以破解40%的wifi密码了！<strong>大家不要关心代码，只要知道我在生成密码字典就可以了（想要获取教程中使用的密码字典请关注微信公众帐号：极客峰，回复『密码字典』获取）</strong>：</p><p><img src="/images/2016/12/680166ff4c5f1e082a732970ca8bab8c.png" alt=""></p><p><img src="/images/2016/12/434439c353785570ea9fa49fac4311ac.png" alt=""></p><p>但是网上找不到包含这些密码的密码字典怎么办？极客君决定自己用JAVA写代码生成密码字典，极客君创建了一个数组，里面不仅包含上面，还包括极客君从网上找来的其他常用密码：</p><p><img src="/images/2016/12/150cc50f90051e3ed3b949b1d0e9d29b.png" alt=""></p><p>但是仅仅包含这些密码还不行，因为还有不少人不是用这些密码，但是很多人也会用数字、字母、特殊符号组合，但是这些也是有规律的，数字组合除了上面常用的组合方式外，也会有其他组合方式。但很多人不会随便用自己都记不住的数字组合，一般都是用出生的年月日或者用年月日与其他方式组合。所以极客君又创建下面这些数组：</p><p><img src="/images/2016/12/c09b817c7b8463dfe788e95bfa526e03.png" alt=""></p><p>还有的人会拿自己或者家人的名字首字母、名字全拼或姓氏全拼与上面常用数字组合、出生年月日、特殊字符任意组合。所以极客君为了缩小密码字典体积，只录入了北京地区常用姓氏和其他个人认为常见的姓氏，如下：</p><p><img src="/images/2016/12/ac2ad55cef2c73eaf63a5c030b7f8673.png" alt=""></p><p>对于名字全拼，为了保证覆盖面和有效性，极客君无奈只能把每个字母列出来，然后在所有韵母与这些字母组合，只保留可以组成密码的拼音，这可着实花了极客君一段时间，下面这些拼音是否包含你的名字拼音呢：</p><p><img src="/images/2016/12/f7aa57cff9ca7d9f00cf91d810318571.png" alt=""></p><p><img src="/images/2016/12/16e9669ea6305f1cd92e12b1554fd93e.png" alt=""></p><p><img src="/images/2016/12/1641a6b3c5bbe8dc529999a882393a89.png" alt=""></p><p>特殊字符用的也不多，这里只收录了可能用到的特殊字符。</p><p><img src="/images/2016/12/c39ea7f7c4900fbc7f866a1084d791da.png" alt=""></p><p>对于生成代码，由于代码较多，这里就不截图了，<strong>如果想要源码，请关注微信公众帐号[极客峰]留言索取。</strong></p><p>好了，接下来就是生成密码字典了，由于和名字全拼相关的密码字典较大，而且不是非常常用，极客君把它单独生成：</p><p><img src="/images/2016/12/d22a6bec31247bccadf69284344eef5a.png" alt=""></p><p>这两个密码生成之后比较大，但是对于电脑来说没什么，分别为100G和358M，所以后面我们不首先用这些密码包。</p><p><img src="/images/2016/12/9801ccdafb005ce6ba91c4e53984a671.png" alt=""></p><p>下面我们生成常用的、强大的密码字典，具体包含组合方式见下面截图：</p><p><img src="/images/2016/12/3ea35c27df34913f045da90f62d81249.png" alt=""></p><p>首先输入字典名称，按回车，输入3生成我们的超级密码，对于为什么这样输入大家不用关系，只知道我们在生成字典就行了，我将文件名命名为”jikefeng.txt”，然后按回车输入3开始生成：</p><p><img src="/images/2016/12/a16995f375cf0e3872740a01cb829fd9.png" alt=""></p><p><img src="/images/2016/12/6f790c48c6b20aaf90e9d1e1c3818c14.png" alt=""></p><p>好了，我们去看看生成的字典密码，一共1.15G，大小还可以，比网上几十G的密码包好太多了：</p><p><img src="/images/2016/12/5eb26cb5e8e06f3b153ebf5f4e140652.png" alt=""></p><p>好了字典包生成好了，接下来还是步入整体，开始破解了。首先看一下附近的wifi：</p><p><img src="/images/2016/12/e77ad0de5883c875fd872367cf0893f4.png" alt=""></p><p>我们选择破解信号最强的wifi，极客君住在一楼，上面wifi中最后一个ziroom101从名称上看也是在1楼，所以极客君就破解这个了。</p><p>首先要确保电脑安装 Xcode 和 MacPorts，Xcode 可以直接在 App Store下载，MacPorts 需要进入它的官网下载。MacPorts 是一个软件包管理系统，用来简化 Mac OS 系统上软件的安装，与Fink和BSD类ports套件的目标和功能类似。就像apt-get、yum一样，可以快速安装些软件。把这两个软件安装成功后就可以开始安装 Aircrack。打开终端输入命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> port </span>install aircrack-ng</span><br></pre></td></tr></table></figure><p>要求输入密码，输入后可能会提示 Port aircrack-ng not found ，没关系我们需要更新ports tree，在终端执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> port </span>-v selfupdate</span><br></pre></td></tr></table></figure><p>现在可以开始安装 Aircrack 了，如果还提示 not found，那么再次执行更新ports tree 命令。安装 Aircrack 会比较慢，等安装好后 ，我们需要将 Aircrack 命令建立一个链接，类似Windows下的超级链接，在终端输入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/System/</span>Library<span class="regexp">/PrivateFrameworks/</span>Apple80211.framework<span class="regexp">/Versions/</span>Current<span class="regexp">/Resources/</span>airport <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>airport</span><br></pre></td></tr></table></figure><p>然后在终端内输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">airport -s</span></span><br></pre></td></tr></table></figure><p>就能查看到附近的 Wifi 信息了，如下图：</p><p><img src="/images/2016/12/28bdedd793d70ca907b4ef55f72e8a1a.png" alt=""></p><p>SSID 是 wifi 名称，RSSI 是信号强度，绝对值越小信号越强，CHANNEL 是信道。挑一个信号强的信道进行监听抓包（比如我们要破解的ziroom101在信道13 ），在终端输入：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> air<span class="keyword">port</span> en0 sniff 13</span><br></pre></td></tr></table></figure><p>中间会提示输入管理员密码，输入密码后回车就开始抓包了，如下图：</p><p><img src="/images/2016/12/d7c84c166d0034851550677f0fc53e76.png" alt=""></p><p>过几分钟后就可以按「 control ＋ c 」退出抓包，会自动保存并提示抓得包保存路径：</p><p><img src="/images/2016/12/1b77fa34383c3fb2b1a355fa1df855f8.png" alt=""></p><p>接着进入 tmp 文件就可以查看我们抓到的数据包了，进入 tmp 文件夹我们可以使用 Finder 的前往文件夹功能 ，如图：</p><p><img src="/images/2016/12/cfabca1c3d8c46e442f2f50a9c34d246.png" alt=""></p><p><img src="/images/2016/12/49e486c8eb368bf64f9753e7e055b439.png" alt=""></p><p>我们在桌面上建立文件夹，命名为”jikefeng”，将我们之前生成的密码字典和抓的包都放进去，并且把抓的包也重命名为”jikefeng”，如下：</p><p><img src="/images/2016/12/865bfbc47e9db01b229c0f2c7d93742d.png" alt=""></p><p>接着我们输入下面命令行进入我们在桌面上创建的”jikefeng”文件夹：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Desktop<span class="regexp">/jikefeng/</span></span><br></pre></td></tr></table></figure><p>进入”jikefeng”文件夹后输入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">aircrack-ng</span> <span class="selector-tag">-w</span> <span class="selector-tag">jikefeng</span><span class="selector-class">.txt</span> <span class="selector-tag">jikefeng</span><span class="selector-class">.cap</span></span><br></pre></td></tr></table></figure><p>就可以看到cap文件内的抓包情况，Encryption 中（0 handshake）是抓包失败，（1 handshake）则是抓包成功。点击终端，按下「command ＋ f」进行搜索1 handshake，图中看到第3行抓包成功，则在「Index number of target network ?」这里输入3后敲回车：</p><p><img src="/images/2016/12/6d945617e96ac976bee9ec5b7dab36ad.png" alt=""></p><p><img src="/images/2016/12/786bd7c2cd2ca8d5b4ccb3f81e177aa9.png" alt=""></p><p>之后剩下的就是等待了，当破解密码成功（发现了密码）后会出现下图提示：</p><p><img src="/images/2016/12/1ec87cf3e1109972d1b53eee80dea686.png" alt=""></p><p>所以我们破解出了ziroom101的密码为12344321，令人兴奋的是该密码正是常用密码之一，所以几乎秒破，一点都没有挑战难度。</p><p>利用相同的方法，我破解出了附近wifi中的其他密码（其中破解wifi名为zhouyubo密码花的时间稍微长点，但我也没管它，剩下的就交给电脑了）：</p><p>zhouyubo的密码为zhouyonghu19911129</p><p>Netcore_5G的密码为xy11112222！</p><p>综合以上，怎么样才能保证密码的安全呢？没有百分百的安全，因为密码字典可以包含所有密码，只能把密码设的尽量复杂，但是输的太复杂自己又记不住、输入起来也麻烦。所以，怎么平衡就看自己喽~</p><p>还有，在生成密码字典时候，如果你知道密码主人的一些信息，你可以根据这些信息生成更准确的密码，比如知道姓名、手机号、QQ号、出生日期等，这些都可能是密码的一部分。因为很少有人会用无意义不好记的数字做密码，就算有，准备好相应的密码字典就可以了。网上也有密码字典生成工具，也可以直接下载相应的密码字典包，但是我下载了不少发现几乎就没几个靠谱的，所以需要多找找。记住，破解密码的时候先使用弱口令密码字典，所谓弱口令密码就是最常用的密码，比较大部分人都会用这些密码，当然，极客君上面用的密码字典中已经包含了几乎所有的弱口令密码，并且把弱口令密码放到密码最前面，让这些密码最先被使用，这样破解起来也省事，省的来回换字典了。</p><p>相关密码字典下载：<br>[ypbtn]<a href="https://pan.baidu.com/s/1jIdmIHK[/ypbtn]" target="_blank" rel="noopener">https://pan.baidu.com/s/1jIdmIHK[/ypbtn]</a></p><p>想要获取相关教程及开发交流请关注微信公众帐号：极客峰，回复『密码字典』获取教程中用到的所有密码字典。</p><p><img src="/images/2016/12/213978d09e44efdaf5cb697317bad844.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pin码 </tag>
            
            <tag> wifi密码 </tag>
            
            <tag> 破解 </tag>
            
            <tag> 破解WIFI </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
