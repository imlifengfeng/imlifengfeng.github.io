<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李峰峰博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imlifengfeng.github.io/"/>
  <updated>2018-11-27T08:57:05.320Z</updated>
  <id>https://imlifengfeng.github.io/</id>
  
  <author>
    <name>imlifengfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 的组件化开发</title>
    <link href="https://imlifengfeng.github.io/article/714/"/>
    <id>https://imlifengfeng.github.io/article/714/</id>
    <published>2018-10-03T09:45:40.000Z</published>
    <updated>2018-11-27T08:57:05.320Z</updated>
    
    <content type="html"><![CDATA[<p>在一个APP开发过程中，如果项目较小且团队人数较少，使用最基本的MVC、MVVM开发就已经足够了，因为维护成本比较低。</p><p>但是当一个项目开发团队人数较多时，因为每个人都会负责相应组件的开发，常规开发模式耦合会越来越严重，而且导致大量代码冲突，会使后期维护和升级过程中代码“牵一发而动全身”，额外带来很大的工作量，并且会导致一些潜在的BUG。</p><p>在这时，组件化开发就派上很大用场了，所谓的组件化开发，就是把APP根据业务拆分为各独立的组件，各个组件相互写作，组成完整的APP。</p><h3 id="一、各组件的引入"><a href="#一、各组件的引入" class="headerlink" title="一、各组件的引入"></a>一、各组件的引入</h3><p>关于组件的拆分，就根据具体项目进行拆分，假如APP被拆分了AModule、BModule、CModule，那么，应该如何引入这些组件呢？你可能会想到APP的入口AppDelegate。在平时开发中，AppDelegate中往往初始化了好多组件，比如推送、统计等组件，这样就会导致AppDelegate的臃肿。</p><p>所以，我们可以增加一个ModuleManager，专门用来初始化各组件。<br>首先增加一个 ModuleProtocol：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">@import</span> <span class="built_in">UIKit</span>;</span><br><span class="line"><span class="keyword">@import</span> UserNotifications;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ModuleProtocol</span> &lt;<span class="title">UIApplicationDelegate</span>, <span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们在ModuleManager中hook住UIApplicationDelegate和 UNUserNotificationCenterDelegate中的方法，使相应的组件中实现了对应方法，在相应时机就会调用组建里的对应方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ModuleManager.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define ALL_MODULE [[ModuleManager sharedInstance] allModules]</span></span><br><span class="line"><span class="meta">#define SWIZZLE_METHOD(m) swizzleMethod(class, @selector(m),@selector(module_##m));</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModuleManager</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *modules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ModuleManager</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *)modules &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addModule:(<span class="keyword">id</span>&lt;ModuleProtocol&gt;) module &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loadModulesWithPlistFile:(<span class="built_in">NSString</span> *)plistFile &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *)allModules &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span> (<span class="title">Module</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SWIZZLE_METHOD(application:willFinishLaunchingWithOptions:);</span><br><span class="line">        SWIZZLE_METHOD(application:didFinishLaunchingWithOptions:);</span><br><span class="line">        ......</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123; ...... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)module_application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> module_application:application willFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;ModuleProtocol&gt; module <span class="keyword">in</span> ALL_MODULE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([module respondsToSelector:_cmd]) &#123;</span><br><span class="line">            [module application:application willFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)module_application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> module_application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;ModuleProtocol&gt; module <span class="keyword">in</span> ALL_MODULE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([module respondsToSelector:_cmd]) &#123;</span><br><span class="line">            [module application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>ModuleManager.h:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ModuleProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModuleManager</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loadModulesWithPlistFile:(<span class="built_in">NSString</span> *)plistFile;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;ModuleProtocol&gt;&gt; *)allModules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后我们通过一个 ModulesRegister.plist文件管理需要引入的组件：</p><p>如上图，假如我们要引入AModule、BModule、CModule，那么这三个Module只需要实现协议ModuleProtocol，然后实现AppDelegate中对应的方法，在对应方法中初始化自身即可：<br>AModule.h:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ModuleProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AModule</span> : <span class="title">NSObject</span>&lt;<span class="title">ModuleProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AModule.m:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AModule.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AModule</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions&#123;</span><br><span class="line">    <span class="comment">//初始化AModule</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后在AppDelegate的load方法中通过ModulesRegister.plist引入各组件即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">//load modules</span></span><br><span class="line">    <span class="built_in">NSString</span>* plistPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"ModulesRegister"</span> ofType:<span class="string">@"plist"</span>];</span><br><span class="line">    [[ModuleManager sharedInstance] loadModulesWithPlistFile:plistPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样，各组件的开发者在自己的组件中初始化自己，其他人需要使用时只需要加入ModulesRegister.plist文件中即可。</p><h3 id="二、组件间协作"><a href="#二、组件间协作" class="headerlink" title="二、组件间协作"></a>二、组件间协作</h3><p>简单来看，假设APP的每个页面就是一个组件，假如我们的APP有AViewController、BViewController、CViewController、DViewController、EViewController，各ViewController必然设置各种相互跳转。那么，我们APP的跳转逻辑可能是下面这个样子：</p><p>为了解决这种复杂的耦合关系，我们可以增加一个Router中间层去管理各ViewController之间的跳转关系（也就是实际开发中组件间相互调用的关系）。</p><p>所以，根据需要，我开发并开源了一个支持URL Rewrite的iOS路由库— <a href="https://github.com/imlifengfeng/FFRouter" target="_blank" rel="noopener">FFRouter</a>，通过<a href="https://github.com/imlifengfeng/FFRouter" target="_blank" rel="noopener">FFRouter</a>去管理各ViewController之间的跳转关系：</p><p>这样，各ViewController之间的跳转关系就变的清晰了许多。</p><p>FFRouter通过提前注册对应的URL，之后就直接通过打开URL去控制各ViewController之间的跳转（或各组件间的调用）。<br>FFRouter支持组件间传递非常规对象，如UIImage等，并支持获取组件返回值。<br>基本使用如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 注册 url</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> routeURL 要注册的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> handlerBlock URL 被 Route 后的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">registerRouteURL:</span>(NSString *)routeURL <span class="string">handler:</span>(FFRouterHandler)handlerBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 注册 URL,通过该方式注册的 URL 被 Route 后可返回一个 Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> routeURL 要注册的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> handlerBlock URL 被 Route 后的回调,可在回调中返回一个 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">registerObjectRouteURL:</span>(NSString *)routeURL <span class="string">handler:</span>(FFObjectRouterHandler)handlerBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断 URL 是否可被 Route（是否已经注册）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要判断的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 是否可被 Route</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)<span class="string">canRouteURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">routeURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL，并带上额外参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> parameters 额外参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">routeURL:</span>(NSString *)URL <span class="string">withParameters:</span>(NSDictionary&lt;NSString *, id&gt; *)parameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL，可获得返回的 Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 返回的 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (id)<span class="string">routeObjectURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个 URL，并带上额外参数，可获得返回的 Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要 Router 的 URL</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> parameters 额外参数</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> 返回的 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (id)<span class="string">routeObjectURL:</span>(NSString *)URL <span class="string">withParameters:</span>(NSDictionary&lt;NSString *, id&gt; *)parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Route 一个未注册 URL 时回调</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> handler 回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">routeUnregisterURLHandler:</span>(FFRouterUnregisterURLHandler)handler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取消注册某个 URL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> URL 要被取消注册的 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">unregisterRouteURL:</span>(NSString *)URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取消注册所有 URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)unregisterAllRoutes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否显示 Log，用于调试</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> enable YES or NO，默认为 NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">setLogEnabled:</span>(BOOL)enable;</span><br></pre></td></tr></table></figure><p>而且参考天猫的方案增加了URL Rewrite功能：</p><p>可以使用正则添加一条 Rewrite 规则，例如：<br>要实现打开 URL:<a href="https://www.taobao.com/search/原子弹时，将其拦截，改用本地已注册的" target="_blank" rel="noopener">https://www.taobao.com/search/原子弹时，将其拦截，改用本地已注册的</a> URL:protocol://page/routerDetails?product=原子弹打开。<br>首先添加一条 Rewrite 规则：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FFRouterRewrite <span class="string">addRewriteMatchRule:</span>@<span class="string">"(?:https://)?www.taobao.com/search/(.*)"</span> <span class="string">targetRule:</span>@<span class="string">"protocol://page/routerDetails?product=$1"</span>];</span><br></pre></td></tr></table></figure><p>之后在打开URL:<a href="https://www.taobao.com/search/原子弹时，将会" target="_blank" rel="noopener">https://www.taobao.com/search/原子弹时，将会</a> Rewrite 到URL:protocol://page/routerDetails?product=原子弹。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">FFRouter</span> routeURL:@<span class="string">"https://www.taobao.com/search/原子弹"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>可以通过以下方法同时增加多个规则：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)addRewriteRules:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *)rules;</span><br></pre></td></tr></table></figure><p>其中 rules 格式必须为以下格式：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@[</span><span class="meta">@&#123;</span><span class="meta">@"matchRule":</span><span class="meta">@"YourMatchRule1",</span><span class="meta">@"targetRule":</span><span class="meta">@"YourTargetRule1"&#125;,</span></span><br><span class="line">  <span class="meta">@&#123;</span><span class="meta">@"matchRule":</span><span class="meta">@"YourMatchRule2",</span><span class="meta">@"targetRule":</span><span class="meta">@"YourTargetRule2"&#125;,</span></span><br><span class="line">  <span class="meta">@&#123;</span><span class="meta">@"matchRule":</span><span class="meta">@"YourMatchRule3",</span><span class="meta">@"targetRule":</span><span class="meta">@"YourTargetRule3"&#125;,]</span></span><br></pre></td></tr></table></figure><p>Rewrite 规则中的保留字：</p><ul><li>通过 <em><strong>$scheme</strong></em>、<em><strong>$host</strong></em>、<em><strong>$port</strong></em>、<em><strong>$path</strong></em>、<em><strong>$query</strong></em>、<em><strong>$fragment</strong></em> 获取标准 URL 中的相应部分。通过<em><strong>$url</strong></em>获取完整 URL</li></ul><ul><li>通过 <em><strong>$1</strong></em>、<em><strong>$2</strong></em>、<em><strong>$3</strong></em>…获取matchRule的正则中使用圆括号取出的参数</li></ul><ul><li><em><strong>$</strong></em>：原变量的值、<em><strong>$$</strong></em>：原变量URL Encode后的值、<em><strong>$#</strong></em>：原变量URL Decode后的值</li></ul><p>例如：<br><a href="https://www.taobao.com/search/原子弹对于Rewrite" target="_blank" rel="noopener">https://www.taobao.com/search/原子弹对于Rewrite</a> 规则(?:https://)?<a href="http://www.taobao.com/search/(.*)" target="_blank" rel="noopener">www.taobao.com/search/(.*)</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$1=原子弹</span><br><span class="line">$$<span class="number">1</span>=%e5%8e%9f%e5%ad%90%e5%bc%b9</span><br></pre></td></tr></table></figure><p>同样，<a href="https://www.taobao.com/search/%e5%8e%9f%e5%ad%90%e5%bc%b9对于Rewrite" target="_blank" rel="noopener">https://www.taobao.com/search/%e5%8e%9f%e5%ad%90%e5%bc%b9对于Rewrite</a> 规则(?:https://)?<a href="http://www.taobao.com/search/(.*)" target="_blank" rel="noopener">www.taobao.com/search/(.*)</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$1=%e5%8e%9f%e5%ad%90%e5%bc%b9</span><br><span class="line">$#1=原子弹</span><br></pre></td></tr></table></figure><p>考虑到经常用路由配置UIViewController之间的跳转，所以增加了额外的工具FFRouterNavigation来更方便地控制UIViewController之间的跳转。</p><h3 id="三、其他组件化方案"><a href="#三、其他组件化方案" class="headerlink" title="三、其他组件化方案"></a>三、其他组件化方案</h3><p>目前这种组件化方案参考了蘑菇街、天猫、京东的的实现方案。除这种方案外，Casa（<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">查看文章</a>）之前提出了解耦程度更高的方案，这种方案组件仍然使用中间件通信，但中间件通过 runtime 接口解耦，然后使用 target-action 简化写法，通过 category 分离组件接口代码。<br>但是，这种方案虽然解耦程度更高，但是也增加了组件化的成本，综合考虑，直接使用中间件通信的方式更好一点。具体哪种方案好，也就仁者见仁、智者见智了～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个APP开发过程中，如果项目较小且团队人数较少，使用最基本的MVC、MVVM开发就已经足够了，因为维护成本比较低。&lt;/p&gt;
&lt;p&gt;但是当一个项目开发团队人数较多时，因为每个人都会负责相应组件的开发，常规开发模式耦合会越来越严重，而且导致大量代码冲突，会使后期维护和升级过
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS逆向工程之fishhook</title>
    <link href="https://imlifengfeng.github.io/article/692/"/>
    <id>https://imlifengfeng.github.io/article/692/</id>
    <published>2017-07-05T16:06:39.000Z</published>
    <updated>2018-11-27T09:36:08.980Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>峰哥在<a href="http://www.imlifengfeng.com/blog/?p=677" target="_blank" rel="noopener">上一篇文章</a>整理了在插件开发中如何HOOK 动态语言 Objective-C 中的方法，实际上静态语言 C 语言中的函数也是有办法 HOOK 的，这也说明了绝对的静态语言是不存在的。</p><p>为了实现HOOK C 语言中的函数，我们需要用到 Facebook 的一个开源框架 fishhook，通过 fishhook 我们可以很轻松的 HOOK C 语言中的函数，从而达到修改函数功能的目的。</p><p>我在参考了 fishhook 官方 demo 和 Draveness 的文章后，发现对 C 函数的 HOOK 也是非常简单的。</p><p>在开始之前需要先简单了解两个概念：</p><p>Mach-O：对于每个操作系统中的可执行程序都是有格式的，如 ELF 是 Linux 下可执行文件的格式，PE32／PE32+ 是 windows 的可执行文件的格式，那么对于 OS X 和 iOS 来说 Mach-O 是其可执行文件的格式。 OS X 和 iOS 开发中的可执行文件、库文件、Dsym文件、动态库、动态连接器都是这种格式的。</p><p>镜像：在 Mach-O 文件系统中，所有的可执行文件、dylib 以及 Bundle 都是镜像。</p><p>二、<strong>fishhook的使用</strong></p><p>我们先通过一个简单的 demo 去了解一下 fishhook 的使用，fishhook GitHub链接：<a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">https://github.com/facebook/fishhook</a></p><p>下载下来 fishhook 后你会发现这个框架非常简单，只有两个文件“fishhook.h”和“fishhook.c”。</p><p>我们打开文件“fishhook.h”会发现只有一个结构体和两个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">void</span> *replacement;</span><br><span class="line">  <span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line"></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                         struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure><p>我们先看 rebinding 结构体，结构体中 name 是一个原始函数（要被替换的函数）名字符串，replacement 是替换后的新的函数指针，replaced 是我们自己创建的一个与原始函数签名相同（参数的个数、类型、顺序相同）的函数的指针的指针。关于 rebinding 暂且先不要纠结，后面看过代码就知道如何使用了。</p><p>rebind_symbols 函数和 rebind_symbols_image 函数是用来 HOOK 函数的两个方法，只不过参数不同而已，前者比较简单，两个参数一个是 rebinding 数组，一个是数组中 rebinding 个数。后者就稍微复杂点，根据源码中的注释说明，该函数是在仅指定镜像的时候使用。所以，我们这里直接使用 rebind_symbols 函数就可以了。</p><p>C 语言中有个 strlen 函数，用来获取字符串的长度，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  FishHookDemo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">"imlifengfeng"</span>;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结果:%ld\n"</span>,result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/2017/07/Snip20170702_1.png" alt="Snip20170702_1"></p><p>接下来我们就修改 strlen 函数的返回值，使无论字符串真实长度是什么，都返回 666。我们使用前面说到的 rebind_symbols 函数去实现。</p><p>首先我们要声明一个与 strlen 函数签名相同的函数，方法名任意，我们定义为 original_strlen，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*original_strlen)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span></span>;</span><br></pre></td></tr></table></figure><p>然后再定义一个替换后的函数，使其不管参数是什么直接返回 666，方法名也任意，我们定义为 new_strlen，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就使用 rebind_symbols 函数进行绑定：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> strlen_rebinding = </span>&#123; <span class="string">"strlen"</span>, new_strlen, (<span class="keyword">void</span> *)&amp;original_strlen &#125;;</span><br><span class="line">rebind_symbols((<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span>[1])</span>&#123;strlen_rebinding&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上面这些操作完成之后再调用 strlen 函数无论字符串真实长度是什么都会直接返回 666。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  FishHookDemo2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*original_strlen)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">strlen_rebinding</span> = &#123;</span> <span class="string">"strlen"</span>, new_strlen, (<span class="keyword">void</span> *)&amp;original_strlen &#125;;</span><br><span class="line">        rebind_symbols((struct rebinding[<span class="number">1</span>])&#123;strlen_rebinding&#125;, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">"imlifengfeng"</span>;</span><br><span class="line">        <span class="keyword">long</span> test = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结果:%ld\n"</span>,test);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/2017/07/Snip20170702_2.png" alt="Snip20170702_2"></p><p>可以看到我们已经达到了 HOOK C函数的目的，已经理解的可以自己尝试 HOOK 一些其他的函数去实现一些更复杂的功能。</p><p>三、<strong>fishhook的原理</strong></p><p>1、Mach-O</p><p>前面峰哥也说了 Mach-O 是 OS X 和 iOS 可执行文件的格式，我们这里再来简单看下 Mach-O 文件格式的结构，无需深究。</p><p>每一个 Mach-O 文件都会被分为不同的 Segments，比如 <code>__TEXT</code>, <code>__DATA</code>, <code>__LINKEDIT</code>：</p><p><img src="/images/2017/07/2016-07-26-fishhook-mach-o.png.jpeg" alt="2016-07-26-fishhook-mach-o.png"></p><p>Mach-O 中的 <code>segment_command</code>（32 位与 64 位不同）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment name */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;     <span class="comment">/* memory address of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;     <span class="comment">/* memory size of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;    <span class="comment">/* file offset of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;   <span class="comment">/* amount to map from the file */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;    <span class="comment">/* maximum VM protection */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;   <span class="comment">/* initial VM protection */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;     <span class="comment">/* number of sections in segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;      <span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个 <code>segment_command</code> 中又包含了不同的 <code>section</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* name of this section */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment this section goes in */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;       <span class="comment">/* memory address of this section */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;       <span class="comment">/* size in bytes of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;     <span class="comment">/* file offset of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;      <span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;     <span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;     <span class="comment">/* number of relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;      <span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;  <span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;  <span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;  <span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、dyld 与动态链接</p><p>dyld（the dynamic link editor）是 Apple 的动态链接器（GitHub地址：<strong><a href="https://github.com/opensource-apple/dyld" target="_blank" rel="noopener">dyld</a></strong>），系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，关于其作用顺序，可参考文章《<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="noopener">dyld: Dynamic Linking On OS X</a>》，相关部分翻译内容如下：<br>（1）从kernel留下的原始调用栈引导和启动自己<br>（2）将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制<br>（3）non-lazy符号立即link到可执行文件，lazy的存表里<br>（4）运行可执行文件的静态初始化程序<br>（5）找到可执行文件的main函数，准备参数并调用<br>（6）程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口<br>（7）程序main函数return后执行static terminator<br>（8）某些场景下main函数结束后调libSystem的_exit函数</p><p>一句话总结就是：负责将各种各样程序需要的镜像加载到程序运行的内存空间中！</p><p>其作用的时间是 OC 运行时初始化之前！</p><p>dyld 加载镜像后会执行相关回调函数，当一个镜像被动态链接时，都会执行回调 <code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的 <code>mach_header</code> 以及一个虚拟内存地址 <code>intptr_t</code>。</p><p>我们先使用 Xcode 新建一个简单的 C 项目，项目名为 test ,项目新建后默认 main.c 文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/4.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打开终端 cd 到 main.c 文件目录，使用 gcc 命令编译  main.c 源文件生成可执行文件，执行完成后会生成名为 a.out 的可执行文件。之后通过 nm 命令查看可执行文件中的符号：</p><p><img src="/images/2017/07/Snip20170705_3.png" alt="Snip20170705_3"></p><p>从上图可以看出，<code>_printf</code> 这个符号是未定义（undefined）的，换句话说，编译器还不知道这个符号对应什么东西。</p><p>那如果我们自己增加一个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/7/4.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那结果是什么样的呢？如下：</p><p><img src="/images/2017/07/Snip20170705_1.png" alt="Snip20170705_1"></p><p>可见我们手动添加的 test 函数所对应的符号 _test 并不是为定义的，它包含一个内存地址以及 <code>__TEXT</code> 段。</p><p>为了更深入理解，我们需要用到一个神器 Hopper Disassembler ，这是一个类似于 IDA 的反汇编工具，个人感觉它比 IDA 好用的多，感兴趣的可以自己从网上下载，它最新图标是下面这样的：</p><p><img src="/images/2017/07/Snip20170705_2-1.png" alt="Snip20170705_2"></p><p>我们使用该工具分析一下之前的 a.out 的可执行文件：</p><p><img src="/images/2017/07/Snip20170705_3-1.png" alt="Snip20170705_3"></p><p><code>可以发现 nm</code> 打印出的另一个符号 <code>dyld_stub_binder</code> 对应另一个同名函数。<code>dyld_stub_binder</code> 会在目标符号（例如 <code>printf</code>）被调用时，将其链接到指定的动态链接库 <code>libSystem</code>，再执行 <code>printf</code> 的实现（<code>printf</code> 符号位于 <code>__DATA</code> 端中的 lazy 符号表中）。</p><p>每一个镜像中的 <code>__DATA</code> 端都包含两个与动态链接有关的表，其中一个是 <code>__nl_symbol_ptr</code>，另一个是 <code>__la_symbol_ptr</code>：</p><ul><li><code>__nl_symbol_ptr</code> 中的 non-lazy 符号是在动态链接库绑定的时候进行加载的</li></ul><ul><li><code>__la_symbol_ptr</code> 中的符号会在该符号被第一次调用时，通过 dyld 中的 <code>dyld_stub_binder</code> 过程来进行加载</li></ul><p>在上述代码调用 printf 时，由于符号是没有被加载的，就会通过 dyld_stub_binder 动态绑定符号：</p><p><img src="/images/2017/07/Snip20170705_4.png" alt="Snip20170705_4"></p><p>3、fishhook 的原理</p><p>dyld 通过更新 Mach-O 二进制文件 <strong>DATA 段中的一些指针来绑定 lazy 和 non-lazy 的符号；而 fishhook 先确定某一个符号在 </strong>DATA 段中的位置，然后保存原符号对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定。</p><p>对于前面我们 HOOK strlen 函数的例子，过程如下图示：</p><p><img src="/images/2017/07/Snip20170705_6.png" alt="Snip20170705_6"></p><p>其中最复杂的部分就是从二进制文件中寻找某个符号的位置，在 fishhook 的 README 中，有这样一张图：</p><p><img src="/images/2017/07/2016-07-26-fishhook-imp.png" alt="2016-07-26-fishhook-imp"></p><p>这张图初看很复杂，不过它演示的是寻找符号的过程，我们根据这张图来分析一下这个过程：</p><ol><li>从 __DATA 段中的 lazy 符号指针表中查找某个符号，获得这个符号的偏移量 1061，然后在每一个 section_64 中查找 reserved1，通过这两个值找到 Indirect Symbol Table 中符号对应的条目</li></ol><ol start="2"><li>在 Indirect Symbol Table 找到符号表指针以及对应的索引 16343 之后，就需要访问符号表</li></ol><ol start="3"><li>然后通过符号表中的偏移量，获取字符串表中相关函数的符号</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;峰哥在&lt;a href=&quot;http://www.imlifengfeng.com/blog/?p=677&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;整理了在插件开发中如何HOOK
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="fishhook" scheme="https://imlifengfeng.github.io/tags/fishhook/"/>
    
      <category term="逆向工程" scheme="https://imlifengfeng.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向工程之插件开发</title>
    <link href="https://imlifengfeng.github.io/article/677/"/>
    <id>https://imlifengfeng.github.io/article/677/</id>
    <published>2017-06-25T11:32:36.000Z</published>
    <updated>2018-11-27T09:38:36.935Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>iOS逆向工程是指在软件层面上进行逆向分析的一个过程，基于iOS逆向工程技术，我们可以监控甚至改变App的运行逻辑，从而达到获取核心信息，了解软件设计原理等战术目的。通过一段时间对iOS逆向工程的研究发现很有趣，会在博客记录学习开发过程中的心得和笔记。首先从基本插件的开发开始，后面会对微信、QQ等App进行逆向开发与修改，做一些有趣的事情～</p><p>二、<strong>用到的设备或工具</strong></p><p>1、一台越狱设备：iPhone手机越狱和Android手机ROOT一样非常简单，具体的越狱方法网上很多，这里不在讨论。</p><p>2、Cydia：一般越狱过的手机都会自动被安装该软件，相当于App Store，可以搜索安装越狱app，也可以用来管理（卸载）我们开发的插件。</p><p>3、Theos：越狱开发工具包。</p><p>4、ldid：模拟给iPhone签名的流程，使我们能够在真实的设备上安装越狱的apps/hacks。</p><p>5、dkpg：一个Debian的一个命令行工具，它可以用来安装、删除、构建和管理Debian的软件包。</p><p>三、<strong>软件或工具的介绍与安装</strong></p><p>1、Theos</p><p>越狱开发中除了Thoes外还有一个叫iOSOpenDev的工具，功能和Thoes是一样的，不同点是iOSOpenDev是整合到Xcode中使用的，通过本人亲身实践发现使用Thoes开发更简单方便，感兴趣的可以去了解下iOSOpenDev，这里不再讲解，个人建议使用Thoes，本文也将以Thoes为基础进行开发。</p><p>安装Thoes方法如下：</p><p>首先设置环境变量，我们将Thoes安装在/opt/theos中，打开terminal然后输入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS</span>=/opt/theos</span><br></pre></td></tr></table></figure><p>通过在命令行执行 echo $THEOS可以看到这个变量是否正确设置。每次你打开terminal都需要重新设置一下。</p><p><img src="/images/2017/06/Snip20170623_4.png" alt="Snip20170623_4"></p><p>然后下载Theos：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/DHowett/</span>theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure><p>之后会提示输入密码，输入密码等待下载完成即可。</p><p>2、ldid</p><p>ldid是一个用来给iOS可执行程序签名的工具，使我们开发的越狱APP或者插件能够安装到越狱手机上。</p><p>我们可以从<a href="http://joedj.net/ldid" target="_blank" rel="noopener">http://joedj.net/ldid</a>上下载ldid后拷贝到“/opt/theos/bin/”目录中，然后使用下面命令行赋予可执行权限：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod <span class="number">777</span> <span class="regexp">/opt/</span>theos<span class="regexp">/bin/</span>ldid</span><br></pre></td></tr></table></figure><p>3、dkpg</p><p>Dpkg能够把你的app打包成Debian Package,可以分发的Cydia的存储目录中。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>dpkg</span><br></pre></td></tr></table></figure><p>4、配置libsubstrate.dylib</p><p>在开始开发之前，还需要下载libsubstrate.dylib，然后copy到“/opt/theos/lib”目录下即可，点击下载：<a href="http://www.mediafire.com/?2upm53uzzj0488u" target="_blank" rel="noopener">libsubstrate.dylib</a></p><p> 由于“你懂的”的原因，访问国外网站需要翻墙，上面下载链接不翻墙可能无法下载，如果你没有梯子，可以从我网盘下载：</p><p><a href="http://pan.baidu.com/s/1hsL0llM" target="_blank" rel="noopener">http://pan.baidu.com/s/1hsL0llM</a></p><p>最后我们在开发之前可以看下Theos中的模板，执行如下命令可以看到默认存在的模板：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span><span class="regexp">/bin/</span>nic.pl</span><br></pre></td></tr></table></figure><p>有的人会在使用模板创建项目的时候会有如下提示：</p><p><img src="/images/2017/06/Snip20170625_10.png" alt="Snip20170625_10"></p><p>原因是没有执行如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS</span>=/opt/theos</span><br></pre></td></tr></table></figure><p>上面已经说了，每次都要执行一次，如果不想每次都执行也可以直接使用如下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>theos<span class="regexp">/bin/</span>nic.pl</span><br></pre></td></tr></table></figure><p><img src="/images/2017/06/Snip20170625_11.png" alt="Snip20170625_11"></p><p>可以看到上面一共有17个模板。</p><p>实际上安装 后默认只有12个模板，想要添加更多模板，可以从<a href="https://github.com/DHowett/theos-nic- templates/archive/master.zip55.tar" target="_blank" rel="noopener">https://github.com/DHowett/theos-nic- templates/archive/master.zip55.tar</a>下载额外的5个模板，下载后解压得到的5个.tar文件复制到“/opt/theos/templates/iphone/”目录下即可。</p><p> 四、<strong>创建工程</strong></p><p>首先介绍一下本教程所写插件实现的功能：“修改”设备信息。实际上对于系统硬件信息是不能修改的，但是我们可以修改获取设备信息的方法的返回值，比如我们获取系统版本用如下方法：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">UIDevice</span> currentDevice] systemVersion]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>如果我们的系统是10.0.2版本，该方法会返回字符串“10.0.2”，我们要做的就是当别的App调用上面方法时，我们拦截住并返回一个我们设定的任意值，比如我们让上面方法返回“11.0.2”，这就是传说中的HOOK。</p><p>首先我们新建一个文件夹MyDemo，cd到该文件夹中，然后按照上面所说的，我们使用如下命令查看与选择模板：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span><span class="regexp">/bin/</span>nic.pl</span><br></pre></td></tr></table></figure><p><img src="/images/2017/06/Snip20170625_11.png" alt="Snip20170625_11"></p><p>我们选择模板15（iphone/tweak），之后根据提示输入Project Name（tweak工程名）、Package Name（de b包的名字，类似于bundle identifier）、Author（作者）、Bundle filter（tweak作用对象的bundle identifier）即可，具体的根据实际情况填写。</p><p><img src="/images/2017/06/Snip20170625_12.png" alt="Snip20170625_12"></p><p>最后在MyDemo目录中生成的文件如下：</p><p><img src="/images/2017/06/Snip20170625_13.png" alt="Snip20170625_13"></p><p>介绍一下上面的几个文件：<br>（1）control文件</p><p>主要记录的deb包管理系统所需要的基本信息，会被打包进deb包中，该文件中主要是我们创建工程时所填写的信息，如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Package:</span> <span class="keyword">com</span>.imlifengfeng.tweakdemo</span><br><span class="line"><span class="symbol">Name:</span> tweakdemo</span><br><span class="line"><span class="symbol">Depends:</span> mobilesubstrate</span><br><span class="line"><span class="symbol">Version:</span> <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"><span class="symbol">Architecture:</span> iphoneos-arm</span><br><span class="line"><span class="symbol">Description:</span> An awesome MobileSubstrate tweak!</span><br><span class="line"><span class="symbol">Maintainer:</span> imlifengfeng</span><br><span class="line"><span class="symbol">Author:</span> imlifengfeng</span><br><span class="line"><span class="symbol">Section:</span> Tweaks</span><br></pre></td></tr></table></figure><p>（2）Makefile文件</p><p>用于指定工程用到的文件、框架、库等信息，将整个过程自动化，文件默认内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(THEOS)</span>/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = tweakdemo</span><br><span class="line">tweakdemo_FILES = Tweak.xm</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(THEOS_MAKE_PATH)</span>/tweak.mk</span><br><span class="line"></span><br><span class="line"><span class="section">after-install::</span></span><br><span class="line">install.exec <span class="string">"killall -9 SpringBoard"</span></span><br></pre></td></tr></table></figure><p>注意一下上面第一行，如果在使用命令行做操作（如打包、安装）时，如果没有执行下面命令会报错：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS</span>=/opt/theos</span><br></pre></td></tr></table></figure><p>这个是新手容易犯的错误，还是一样，想省事也可以把上面第一行直接改成：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="regexp">/opt/</span>theos<span class="regexp">/makefiles/</span>common.mk</span><br></pre></td></tr></table></figure><p>我们需要在Makefile文件中做一些配置：</p><p>设置我们用到的框架：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tweakDemo_FRAMEWORKS</span> = UIKit CoreGraphics</span><br></pre></td></tr></table></figure><p>注意一下前缀tweakDemo，这是你的项目名，根据自己项目名填写。</p><p>指定iOS SDK版本（这里指定采用最新版SDK，插件适用最低版本9.0）：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET = <span class="string">iphone:</span><span class="string">latest:</span><span class="number">9.0</span></span><br></pre></td></tr></table></figure><p>上面的latest可以也设置成具体版本，如10.0。</p><p>已链接目标真机的IP：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOS_DEVICE_IP=<span class="number">192.168</span><span class="number">.2</span><span class="number">.61</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里使用的ssh连接的，关于连接真机，有个注意的一点是最新的越狱方法已经不再需要手机安装OpenSSH插件了，安装后反而无法连接。但是OpenSSH功能是默认禁用的，需要手动开启。开启方法也很简单，在 Cydia 中搜索 Filza 并安装，进入以下路径：/private/var/containers/Bundle/Application/yalu102/yalu102.app/，用文本编辑器打开 dropbear.plist 文件，替换 127.0.0.1:22 为 22，重启设备，重新使用越狱工具恢复越狱即可。</p><p>最终配置完后的文件内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /opt/theos/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = tweakDemo</span><br><span class="line">tweakDemo_FILES = Tweak.xm</span><br><span class="line">tweakDemo_FRAMEWORKS = UIKit CoreGraphics</span><br><span class="line">TARGET = iphone:latest:9.0</span><br><span class="line">THEOS_DEVICE_IP=192.168.2.61</span><br><span class="line"><span class="keyword">include</span> /opt/theos/makefiles/tweak.mk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">after-install::</span></span><br><span class="line">install.exec <span class="string">"killall -9 SpringBoard"</span></span><br></pre></td></tr></table></figure><p>（3）Tweak.xm文件</p><p>该文件就是我们写相关代码的文件，使用的是Logos语言，看到这里别害怕，Logos其实非常非常简单的，简单到3分钟从入门到精通，没多少内容，这个后面具体再讲。</p><p>（4）tweakdemo.plist文件</p><p>这个文件主要用来设置插件的作用范围，对哪些App有效，比如可以设置哪些App调用我们HOOK的方法时返回我们设定的值。</p><p>用Xcode打开其内容如下：<br><img src="/images/2017/06/Snip20170625_14.png" alt="Snip20170625_14"></p><p>用Sublime等编辑器打开内容如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in"> Filter </span>= &#123; Bundles = ( <span class="string">"com.apple.springboard"</span> ); &#125;; &#125;</span><br></pre></td></tr></table></figure><p>写完相关的代码记得把作用的App的bundle identifier加上。</p><p>五、<strong>插件代码编写</strong></p><p>上面介绍了生成的几个文件，可以知道我们在Tweak.xm文件中写Tweak代码。我们要实现的功能就是HOOK获取设备信息的方法，为了验证效果，我们先写一个App（bundle identifier为imlifengfeng.InfoGetter）用来获取设备信息，界面如下：<br><img src="/images/2017/06/IMG_7383.png" alt="IMG_7383"></p><p>核心代码为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  InfoGetter</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/6/20.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *infoLabel;<span class="comment">//信息显示Label</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)nameBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *deviceName = [[<span class="built_in">UIDevice</span> currentDevice] name];</span><br><span class="line">    _infoLabel.text = deviceName;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)versionBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *sysVersion = [[<span class="built_in">UIDevice</span> currentDevice] systemVersion];</span><br><span class="line">    _infoLabel.text = sysVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)modelBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *deviceModel = [[<span class="built_in">UIDevice</span> currentDevice] model];</span><br><span class="line">    _infoLabel.text = deviceModel;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说我们要HOOK住的三个方法为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[UIDevice currentDevice] name]</span><br><span class="line">[[UIDevice currentDevice] systemVersion]</span><br><span class="line">[[UIDevice currentDevice] model]</span><br></pre></td></tr></table></figure><p>开始写之前我们先学一下Logos语言，非常简单：<br>（1）%hook</p><p>指定需要hook的class，必须以%end结尾</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">_menuButtonDown:</span>(id)down</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    NSLog(@<span class="string">"你好"</span>);</span></span><br><span class="line"><span class="ruby">    %orig;<span class="regexp">//call</span> the original _menuButtonDown;</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>这段代码的意思是勾住(hook) <em>SpringBoard</em> 类里的__menuButtonDown:_ 函数，先将一句话写入 <em>syslog</em> , 再执行函数的原有操作。</p><p>（2）%log</p><p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hoot</span></span> SpringBoard</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">_menubuttonDown:</span>(id)down</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    %log((NSString *)@<span class="string">"iOSRE"</span>,(NSString *)@<span class="string">"Debug"</span>);</span></span><br><span class="line"><span class="ruby">    %orig;<span class="regexp">//call</span> the original _menuButtonDown;</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>（3）%orig</p><p>该指令在<em>%hook</em>内部使用，执行被勾住(hook)的方法的原始代码。例如：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">_menuButtonDown:</span>(id)down</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    NSLog(@<span class="string">"你好"</span>);</span></span><br><span class="line"><span class="ruby">    %orig; <span class="regexp">//</span> </span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>如果去掉 _%orig _那么原始方法不会执行：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hook SpringBoard</span><br><span class="line">- <span class="params">(void)</span>_menuButtonDown:<span class="params">(id)</span>down</span><br><span class="line">&#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"你好"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>还可以利用 <em>%orig</em> 更改原始行数的参数：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SBLockScreenDateViewController</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">setCustomSubtitleText:</span>(id)arg1 <span class="symbol">withColor:</span>(id)arg2</span></span><br><span class="line"><span class="ruby">&#123;</span></span><br><span class="line"><span class="ruby">    %orig(@<span class="string">"Re"</span>,arg2);</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>这个方法会改变锁屏界面的日期显示。</p><p>（4）%group</p><p>该指令用于将_ %hook _分组，便于代码管理及按条件初始化分组，必须以 <em>%end</em> 结尾；一个_ %group <em>可以包含多个</em> %hook <em>, 所有不属于某个自定义</em> group _的_ %hook <em>会被隐式归类到</em> %group_ungroupes _中。用法如下：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">group</span></span> iOS7Hook</span><br><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> iOS7Class </span><br><span class="line">-<span class="ruby"> (id)iOS7Method &#123;</span></span><br><span class="line"><span class="ruby">     id result = %orig; </span></span><br><span class="line"><span class="ruby">     NSLog(@<span class="string">"This class &amp; method only exist in iOS 7."</span>); </span></span><br><span class="line"><span class="ruby">     <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="ruby"> &#125; %<span class="keyword">end</span> </span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span> /<span class="regexp">/ iOS7Hook</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">%group iOS8Hook </span></span><br><span class="line"><span class="ruby">%hook iOS8Class </span></span><br><span class="line"><span class="ruby">- (id)iOS8Method &#123;</span></span><br><span class="line"><span class="ruby">   id result = %orig; </span></span><br><span class="line"><span class="ruby">   NSLog(@<span class="string">"This class &amp; method only exist in iOS 8."</span>); <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="ruby"> &#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span> /<span class="regexp">/ iOS8Hook</span></span></span><br></pre></td></tr></table></figure><p>（5）%init</p><p>该指令用于初始化某个 _%group <em>,必须在</em> %hook _或_ %ctor <em>内调用;如果带参数,则初始化指定的 group,如果不带参数,则初始化 __ungrouped</em> ,如下:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0 </span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 #endif</span><br><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard </span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">applicationDidFinishLaunching:</span>(id)application &#123;</span></span><br><span class="line"><span class="ruby">    %orig; </span></span><br><span class="line"><span class="ruby">    %init; <span class="regexp">//</span> Equals to %init(_ungrouped)</span></span><br><span class="line"><span class="ruby">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_<span class="number">0</span> &amp;&amp; kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_<span class="number">0</span>)</span></span><br><span class="line"><span class="ruby">      %init(iOS7Hook);</span></span><br><span class="line"><span class="ruby">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_<span class="number">0</span>)</span></span><br><span class="line"><span class="ruby">      %init(iOS8Hook);</span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>只有调用了 %init,对应的 %group 才能起作用。</p><p>（6）%new</p><p>在 <em>%hook</em> 内部使用,给一个现有 <em>class</em> 加新函数,功能与 _class_addMethod_ 相同。它的用法如下:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">hook</span></span> SpringBoard </span><br><span class="line"><span class="tag">%<span class="selector-tag">new</span></span> </span><br><span class="line">-<span class="ruby"> (void)namespaceNewMethod &#123;</span></span><br><span class="line"><span class="ruby">     NSLog(@<span class="string">"We've added a new method to SpringBoard."</span>); </span></span><br><span class="line"><span class="ruby">&#125;</span></span><br><span class="line"><span class="ruby">%<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure><p>（7）%c</p><p>该指令的作用等同于 _objc_getClass_ 或 <em>NSClassFromString</em>,即动态获 一个类的定义,在 <em>%hook</em> 或 <em>%ctor</em> 内使用。</p><p>由于我们只是要HOOK住三个方法，所以我们只能用到%hook。</p><p>具体怎么实现呢？非常简单，我们要HOOK的方法是UIDevice类中的name、systemVersion、model三个方法，所以我们在Tweak.xm文件中直接写代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;SpringBoard/SpringBoard.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">%hook <span class="built_in">UIDevice</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">@"我是假name"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)systemVersion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"我是假systemVersion"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)model</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"我是假model"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>然后在tweakdemo.plist文件中加上上面我们写的测试App的bundle identifier，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in"> Filter </span>= &#123; Bundles = ( <span class="string">"com.apple.springboard"</span>,<span class="string">"imlifengfeng.InfoGetter"</span>); &#125;; &#125;</span><br></pre></td></tr></table></figure><p>最后就可以安装插件到手机了，cd进入项目目录，依次执行三个命令：make、make package、make install即可将插件安装到手机。</p><p>如果在安装（make install）时出现如下错误：<br><img src="/images/2017/06/Snip20170625_15.png" alt="Snip20170625_15"></p><p>只需要配置一下设备IP环境即可，用如下命令行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">THEOS_DEVICE_IP</span>=192.168.2.61</span><br></pre></td></tr></table></figure><p>注意将上面IP改成你真机的IP。</p><p>安装后在手机桌面是看不到插件的，可以通过Cydia查看或卸载：<br><img src="/images/2017/06/Snip20170625_16.png" alt="Snip20170625_16"></p><p>之后就可以通过我们的测试App进行测试了，测试结果如下：<br><strong>安装插件前：</strong><br><img src="/images/2017/06/1.png" alt="1"></p><p><strong>安装插件后：</strong><br><img src="/images/2017/06/2.png" alt="2"></p><p>以上就是这个简单插件开发的整个过程，虽然这个插件很简单，但是对于新手来说这个入门过程是非常复杂的，其中仅仅安装软件配置环境就花了好长时间，<a href="http://www.imlifengfeng.com" target="_blank" rel="noopener">峰哥</a>自己刚研究的时候就是由于网上找不到一个完整的教程，所以比较费脑，也进了不少坑，所以我这里写了一个特别详细的笔记，希望给新生一个帮助，这个教程应该是全网最详细最完整的一个教程了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;iOS逆向工程是指在软件层面上进行逆向分析的一个过程，基于iOS逆向工程技术，我们可以监控甚至改变App的运行逻辑，从而达到获取核心信息，了解软件设计原理等战术目的。通过一段时间对iOS逆向工程的研究发现很有趣，会在
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="逆向工程" scheme="https://imlifengfeng.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="插件开发" scheme="https://imlifengfeng.github.io/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之归并排序</title>
    <link href="https://imlifengfeng.github.io/article/674/"/>
    <id>https://imlifengfeng.github.io/article/674/</id>
    <published>2017-04-03T04:29:36.000Z</published>
    <updated>2018-11-27T09:36:22.299Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。归并操作也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><p>二、<strong>实现思路及代码</strong></p><p>首先来看一下归并操作，和之前一样，仍然按照个人习惯使用递归的方法（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li></ol><ol start="2"><li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li></ol><ol start="3"><li>重复步骤2，直到所有元素排序完毕</li></ol><p>例如对于序列[6, 202, 100, 301, 38, 8, 1]，其归并步骤如下：</p><p><img src="/images/2017/04/Snip20170403_3.png" alt="Snip20170403_3"></p><p>下面是从网上找的一张归并排序gif图：</p><p><img src="/images/2017/01/20160917001326254.gif" alt="20160917001326254"></p><p>Swift实现：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">func mergeSort(_ array: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数组中的每一个元素放入一个数组中</span></span><br><span class="line">    <span class="selector-tag">var</span> tempArray: Array&lt;Array&lt;Int&gt;&gt; = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="selector-tag">var</span> subArray: Array&lt;Int&gt; = []</span><br><span class="line">        subArray.append(item)</span><br><span class="line">        tempArray.append(subArray)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对这个数组中的数组进行合并，直到合并完毕为止</span></span><br><span class="line">    while tempArray<span class="selector-class">.count</span> != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span></span><br><span class="line">        while <span class="selector-tag">i</span> &lt; tempArray<span class="selector-class">.count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            tempArray[i] = _mergeArray(tempArray[i], tempArray[<span class="selector-tag">i</span> + <span class="number">1</span>])</span><br><span class="line">            tempArray.remove(at: <span class="selector-tag">i</span> + <span class="number">1</span>)</span><br><span class="line">            <span class="selector-tag">i</span> = <span class="selector-tag">i</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return tempArray.first!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个有序数组进行合并</span></span><br><span class="line">func _mergeArray(_ firstArray: Array&lt;Int&gt;, _ secondArray: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">    <span class="selector-tag">var</span> resultArray: Array&lt;Int&gt; = []</span><br><span class="line">    <span class="selector-tag">var</span> firstIndex = <span class="number">0</span></span><br><span class="line">    <span class="selector-tag">var</span> secondIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    while firstIndex &lt; firstArray<span class="selector-class">.count</span> &amp;&amp; secondIndex &lt; secondArray<span class="selector-class">.count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> firstArray[firstIndex] &lt; secondArray[secondIndex] &#123;</span><br><span class="line">            resultArray.append(firstArray[firstIndex])</span><br><span class="line">            firstIndex += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultArray.append(secondArray[secondIndex])</span><br><span class="line">            secondIndex += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while firstIndex &lt; firstArray<span class="selector-class">.count</span> &#123;</span><br><span class="line">        resultArray.append(firstArray[firstIndex])</span><br><span class="line">        firstIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while secondIndex &lt; secondArray<span class="selector-class">.count</span> &#123;</span><br><span class="line">        resultArray.append(secondArray[secondIndex])</span><br><span class="line">        secondIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return resultArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;归并排序是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。归并操作也叫归并算法，指的是将两个
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="归并排序" scheme="https://imlifengfeng.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之快速排序</title>
    <link href="https://imlifengfeng.github.io/article/672/"/>
    <id>https://imlifengfeng.github.io/article/672/</id>
    <published>2017-04-01T08:07:30.000Z</published>
    <updated>2018-11-27T09:36:22.150Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>快速排序又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n² )次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>二、<strong>实现思路及代码</strong></p><p>假设对下面数组排序：</p><p><img src="/images/2017/03/1.png" alt="1"></p><p>我们设置两个变量 l、r，并且 l=0、r=n-1，在此数组中 r=5。</p><p>再设置个基准数字 p ，起始时 p 为数组第一个元素，在此数组中 p=6；</p><p>现在开始查找，从 r 开始往前查找比 p 小的元素，即r—，当找到第一个比 p 小的的元素后交换 p 和这个元素。</p><p>在上面数组中，r 往前查找找到的第一个比 p 小的元素为3（下标也为3），交换3和6。如下：</p><p><img src="/images/2017/03/2.png" alt="2"></p><p>此时l=0、r=3、p=6。</p><p>下一步从l往后查找比 p 大的元素，即 l++，当找到第一个比 p 大的元素后交换 p 和这个元素。</p><p>在上面数组中，l往后查找找到的第一个比 p 大的元素为7（下标为2），交换7和6。如下：</p><p><img src="/images/2017/03/3.png" alt="3"></p><p>此时 l=2、r=3、p=6。</p><p>上面两次查找为一个查找循环。</p><p>仔细思考会发现上面l和r是有规律的，即 <strong>l 之前的元素永远小于 r 之后的元素</strong>，因为l之前的元素小于 p，而 r 之后的元素大于 p。所以，<strong>查找结束的标志为 l &gt;= r</strong>。</p><p>但是一次查找结束后数组还并不是有序的，这时候可以发现 p 把数组分成了两部分，我们对 p 两边的数据，再分别进行上述的过程，直到不能再分组为止，等不能再分组的时候，数组就已经排序完成了。</p><p>我从维基百科拿了一张快速排序的GIF图，如下（下图中选取的每部分最后一个元素作为基准数字 p）：</p><p><img src="/images/2017/04/Sorting_quicksort_anim.gif" alt="Sorting_quicksort_anim"></p><p>接下来就是使用 Swift 去实现快速排序，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">right</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l &lt; r  &#123;</span><br><span class="line">        <span class="keyword">while</span> l &lt; r &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> arr[r] &gt;= arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> arr[l] &lt; arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">                _swap(&amp;arr, l, r)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        _swap(&amp;arr, <span class="keyword">left</span>, l)</span><br><span class="line">        <span class="built_in">quickSort</span>(&amp;arr,<span class="keyword">left</span>,l)</span><br><span class="line">        <span class="built_in">quickSort</span>(&amp;arr,l+<span class="number">1</span>,<span class="keyword">right</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_swap</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[<span class="keyword">left</span>]</span><br><span class="line">    arr[<span class="keyword">left</span>] = arr[<span class="keyword">right</span>]</span><br><span class="line">    arr[<span class="keyword">right</span>] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快速排序又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n² )次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="快速排序" scheme="https://imlifengfeng.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之翻转二叉树</title>
    <link href="https://imlifengfeng.github.io/article/669/"/>
    <id>https://imlifengfeng.github.io/article/669/</id>
    <published>2017-03-31T09:21:03.000Z</published>
    <updated>2018-11-27T09:36:21.980Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong><br>HomeBrew作者、天才程序员Max Howell兴致盎然地去Google面试，结果却因不会在白板上翻转二叉树被Google粗鲁地拒绝了，重要的是 Google 中90%的员工都在使用HomeBrew，Max Howell的被拒一时间舆论甚是哗然。在知乎（<a href="https://www.zhihu.com/question/31202353" target="_blank" rel="noopener">点击查看</a>）上也曾展开过激烈的讨论。虽然如此，也阻挡不了我对Max Howell的敬佩。</p><p>二、<strong>实现思路及代码</strong><br>翻转二叉树就是要实现下图：</p><p><img src="/images/2017/03/Snip20170331_2.png" alt="Snip20170331_2"></p><p>其实这和翻转字符串差不多，个人习惯使用递归，接下来就直接上代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻转二叉树</span></span><br><span class="line">    func invertBinaryTree(_ note:BinaryTreeNote) &#123;</span><br><span class="line">        </span><br><span class="line">        let tempLeftChild = note.leftChild</span><br><span class="line">        note<span class="selector-class">.leftChild</span> = note.rightChild</span><br><span class="line">        note<span class="selector-class">.rightChild</span> = tempLeftChild</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> let leftChild = note<span class="selector-class">.leftChild</span> &#123;</span><br><span class="line">            invertBinaryTree(leftChild)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> let rightChild = note<span class="selector-class">.rightChild</span> &#123;</span><br><span class="line">            invertBinaryTree(rightChild)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;br&gt;HomeBrew作者、天才程序员Max Howell兴致盎然地去Google面试，结果却因不会在白板上翻转二叉树被Google粗鲁地拒绝了，重要的是 Google 中90%的员工都在使用HomeBrew，Max Howell
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="二叉树" scheme="https://imlifengfeng.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之二叉树</title>
    <link href="https://imlifengfeng.github.io/article/661/"/>
    <id>https://imlifengfeng.github.io/article/661/</id>
    <published>2017-03-30T16:34:47.000Z</published>
    <updated>2018-11-27T09:36:21.849Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>二叉树的结构一般是以二叉链表的形式来存储的。二叉链表的结构类似于双向链表，二叉链表的节点也是有两个结点指针的，一个指向左子树，一个指向右子树。二叉树主要有四种遍历方式：先序遍历、中序遍历、后序遍历、层次遍历。关于二叉树的内容网上有很多，这里不再做过多的陈述。</p><p>本文将用Swift去实现二叉树的创建、四种遍历方式等。<em>下面的实现部分内容参考了青玉伏案和唐巧两位大神相关的文章</em>。</p><p>二、<strong>实现思路及代码</strong></p><p>以下面二叉树为例：</p><p><img src="/images/2017/03/545446-20160929150423203-118885735.png" alt="545446-20160929150423203-118885735"></p><p>先序遍历：先遍历根节点然后再遍历左子树，最后遍历右子树。</p><p><img src="/images/2017/03/Snip20170331_6.png" alt="Snip20170331_6"></p><p>故上面先序遍历的顺序为： A B D E C F</p><p>不过为了看到更详细的步骤可以把上面 C 结点的左子节点的 value 值打印为#号，类似的D、E、F也一样，他们的左右子节点的 value 值都打印为#号，则打印结果为：A B D # # E # # C # F # #</p><p>中序遍历：先遍历左子树，然后遍历根节点，最后遍历右子树。</p><p><img src="/images/2017/03/Snip20170331_7.png" alt="Snip20170331_7"></p><p>故上面先序遍历的顺序为：# D # B # E # A # C # F #</p><p>后序遍历：后序遍历是先遍历左子树，然后再遍历右子树，最后遍历根节点</p><p><img src="/images/2017/03/Snip20170331_8.png" alt="Snip20170331_8"></p><p>故上面先序遍历的顺序为：# # D # # E B # # # F C A</p><p>层次遍历：层次遍历相对上面的几个遍历实现起来要稍微复杂，层次遍历就是图中以二叉树的根节点为起始节点的广度搜索（BFS）</p><p><img src="/images/2017/03/Snip20170331_9.png" alt="Snip20170331_9"></p><p>故上面先序遍历的顺序为：A B C D E # F # # # # # #</p><p>下面为上述几种遍历的Swift实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNote</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> value:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> leftChild:<span class="type">BinaryTreeNote</span>?</span><br><span class="line">    <span class="keyword">var</span> rightChild:<span class="type">BinaryTreeNote</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeHelper</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> array:[<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">var</span> index = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> array:[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.array = array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createTree</span><span class="params">()</span></span> -&gt; <span class="type">BinaryTreeNote</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.index = <span class="keyword">self</span>.index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.array.<span class="built_in">count</span> &amp;&amp; index &gt;= <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">self</span>.array[index]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">""</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> note = <span class="type">BinaryTreeNote</span>(value)</span><br><span class="line">                note.leftChild = createTree()</span><br><span class="line">                note.rightChild = createTree()</span><br><span class="line">                <span class="keyword">return</span> note</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="number">_</span> note:BinaryTreeNote?)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> note == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(note!.value)</span><br><span class="line">        preOrderTraverse(note!.leftChild)</span><br><span class="line">        preOrderTraverse(note!.rightChild)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inOrderTraverse</span> <span class="params">(<span class="number">_</span> note: BinaryTreeNote?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> note == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraverse(note!.leftChild)</span><br><span class="line">        <span class="built_in">print</span>(note!.value)</span><br><span class="line">        inOrderTraverse(note!.rightChild)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">afterOrderTraverse</span> <span class="params">(<span class="number">_</span> note: BinaryTreeNote?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> note == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        afterOrderTraverse(note!.leftChild)</span><br><span class="line">        afterOrderTraverse(note!.rightChild)</span><br><span class="line">        <span class="built_in">print</span>(note!.value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//层次遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(<span class="number">_</span> root: BinaryTreeNote?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = [[<span class="type">BinaryTreeNote</span>]]()</span><br><span class="line">        <span class="keyword">var</span> level = [<span class="type">BinaryTreeNote</span>]()</span><br><span class="line">        </span><br><span class="line">        level.append(root!)</span><br><span class="line">        <span class="keyword">while</span> level.<span class="built_in">count</span> != <span class="number">0</span> &#123;</span><br><span class="line">            result.append(level)</span><br><span class="line">            <span class="keyword">var</span> nextLevel = [<span class="type">BinaryTreeNote</span>]()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> leftNode = node.leftChild &#123;</span><br><span class="line">                    nextLevel.append(leftNode)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> rightNode = node.rightChild &#123;</span><br><span class="line">                    nextLevel.append(rightNode)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level = nextLevel</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ans = result.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.value &#125;&#125;</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉树的结构一般是以二叉链表的形式来存储的。二叉链表的结构类似于双向链表，二叉链表的节点也是有两个结点指针的，一个指向左子树，一个指向右子树。二叉树主要有四种遍历方式：先序遍历、中序遍历、后序遍历、层次遍历。关于二叉
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="二叉树" scheme="https://imlifengfeng.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之栈和队列</title>
    <link href="https://imlifengfeng.github.io/article/658/"/>
    <id>https://imlifengfeng.github.io/article/658/</id>
    <published>2017-03-28T07:56:52.000Z</published>
    <updated>2018-11-27T09:36:21.700Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>栈和队列在数据结构中是比较重要的一个数据结构。其实对于栈和队列并不需要太深入的介绍，栈和队列的核心内容是栈是先进后出、队列是先进先出。在实际开发中有些场景也可能会用到，比如 APP 中用户可以撤销操作，比如下棋 APP 中的悔棋操作，返回上一步就是先进后出（后进先出），也就是栈的特性。比如在售票 APP 中，为先下订单的用户先出票，就需要用到队列。当然这两个只是在简单场景下的情况，实际开发中情况可能更复杂，比如售票 APP 为会员用户优先出票等。</p><p><img src="/images/2017/03/Snip20170328_5.png" alt="Snip20170328_5"></p><p>接下来就通过 Swift 去实现栈和队列。</p><p>二、<strong>实现思路及代码</strong></p><p>直接上代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> stack: [<span class="type">AnyObject</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">stack = [<span class="type">AnyObject</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">stack.append(object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">if</span> !isEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> stack.removeLast()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">return</span> stack.last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stack.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> queue: [<span class="type">AnyObject</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">queue = [<span class="type">AnyObject</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">queue.append(object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">if</span> !isEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> queue.removeFirst()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> queue.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">return</span> queue.first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> queue.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈和队列在数据结构中是比较重要的一个数据结构。其实对于栈和队列并不需要太深入的介绍，栈和队列的核心内容是栈是先进后出、队列是先进先出。在实际开发中有些场景也可能会用到，比如 APP 中用户可以撤销操作，比如下棋 AP
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="栈" scheme="https://imlifengfeng.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://imlifengfeng.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之查找第K大的元素</title>
    <link href="https://imlifengfeng.github.io/article/654/"/>
    <id>https://imlifengfeng.github.io/article/654/</id>
    <published>2017-03-26T17:11:06.000Z</published>
    <updated>2018-11-27T09:36:21.550Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>这道算法题是《编程之美》中比较经典的一题，解法也有很多，《编程之美》里面基本上介绍了五种解法:</p><p>（a）排序O(NlogN) 或者O(KN)</p><p>（b）快速排序，平均时间O(N)，最坏的可以是O(N^2)，这里书里面是不管怎么样都两边都排序, 所以书里面的平均时间复杂度是O(NlogN)，但是对于这道题没必要两边都排序，具体的后面会讲，这也是本文使用的一种解法</p><p>（c） 二分搜索第K个元素，在数据分布比较好的情况下也是O(NlogN)</p><p>（d）建立一个大小是K的堆，然后线性扫每个元素， 并且根据大小情况更新堆， 时间复杂度O(NlogK)</p><p>（e）哈希统计每个数字的频率，时间复杂度和最大的数有关</p><p>题目：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一个大小为 <span class="built_in">n</span> 的无序数组，求其中第k大的数</span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>我们使用上面提到的方法  b 去实现。首先先看下什么是快速排序，已经对快速排序很了解的可以忽略。</p><p>假设对下面数组排序：</p><p><img src="/images/2017/03/1.png" alt="1"></p><p>我们设置两个变量 l、r，并且 l=0、r=n-1，在此数组中 r=5。</p><p>再设置个基准数字 p ，起始时 p 为数组第一个元素，在此数组中 p=6；</p><p>现在开始查找，从 r 开始往前查找比 p 小的元素，即r—，当找到第一个比 p 小的的元素后交换 p 和这个元素。</p><p>在上面数组中，r 往前查找找到的第一个比 p 小的元素为3（下标也为3），交换3和6。如下：</p><p><img src="/images/2017/03/2.png" alt="2"></p><p>此时l=0、r=3、p=6。</p><p>下一步从l往后查找比 p 大的元素，即 l++，当找到第一个比 p 大的元素后交换 p 和这个元素。</p><p>在上面数组中，l往后查找找到的第一个比 p 大的元素为7（下标为2），交换7和6。如下：</p><p><img src="/images/2017/03/3.png" alt="3"></p><p>此时 l=2、r=3、p=6。</p><p>上面两次查找为一个查找循环。</p><p>仔细思考会发现上面l和r是有规律的，即 <strong>l 之前的元素永远小于 r 之后的元素</strong>，因为l之前的元素小于 p，而 r 之后的元素大于 p。所以，<strong>查找结束的标志为 l &gt;= r</strong>。</p><p>但是一次查找结束后数组还并不是有序的，这时候可以发现 p 把数组分成了两部分，我们对 p 两边的数据，再分别进行上述的过程，直到不能再分组为止，等不能再分组的时候，数组就已经排序完成了。</p><p>注意，一次查找结束后数组可能不是有序的，但是 p 已经处在了排序后的正确位置，这个是我们解决本题的关键！</p><p>我们可以先用快速排序将数组排好序，然后在取出第 k 大的数，但是这并不是最好的解决办法，因为我们压根没有必要对数组进行排序。题目要求是找出第 k 大的数，并不是要求一定先排序。</p><p>上面说了，一次查找结束 p 已经处在了正确的位置，假设一次查找结束时 k 的下标为 pos ，那么：</p><ol><li>当 pos == k，说明p就是第k大的，直接返回；</li></ol><ol start="2"><li>当 pos &gt; k, 说明第k大的一定在p左边，继续对左边 [left, pos - 1] 进行搜索；</li></ol><ol start="3"><li>当 pos &lt; k, 说明第k大的在p右边了，继续对右边 [pos + 1, right] 进行搜索。</li></ol><p>下面为上述思路的Swift实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求数组第K大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(<span class="number">_</span> arr:[Int],<span class="number">_</span> k:Int)</span></span>-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arr = arr</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = arr.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="comment">//升序排列下第k大的数下标不是k而是arr.count - k，比如6个元素的数组，第1大的数字下标为6-1=5</span></span><br><span class="line">    <span class="keyword">let</span> k = arr.<span class="built_in">count</span> - k</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = _partion(&amp;arr,<span class="keyword">left</span>,<span class="keyword">right</span>)</span><br><span class="line">        <span class="keyword">if</span> pos == k &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[pos]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> pos &gt; k&#123;</span><br><span class="line">            <span class="comment">//在左边</span></span><br><span class="line">            <span class="keyword">right</span> = pos - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> pos &lt; k&#123;</span><br><span class="line">            <span class="comment">//在右边</span></span><br><span class="line">            <span class="keyword">left</span> = pos + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_partion</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span>-&gt;<span class="type">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">right</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l &lt; r &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> arr[r] &gt;= arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> arr[l] &lt; arr[<span class="keyword">left</span>] &amp;&amp; l &lt; r&#123;</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">            _swap(&amp;arr, l, r)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    _swap(&amp;arr, <span class="keyword">left</span>, l)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_swap</span><span class="params">(<span class="number">_</span> arr:<span class="keyword">inout</span> [Int],<span class="number">_</span> <span class="keyword">left</span>:Int,<span class="number">_</span> <span class="keyword">right</span>:Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[<span class="keyword">left</span>]</span><br><span class="line">    arr[<span class="keyword">left</span>] = arr[<span class="keyword">right</span>]</span><br><span class="line">    arr[<span class="keyword">right</span>] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这道算法题是《编程之美》中比较经典的一题，解法也有很多，《编程之美》里面基本上介绍了五种解法:&lt;/p&gt;
&lt;p&gt;（a）排序O(NlogN) 或者O(KN)&lt;/p&gt;
&lt;p&gt;（b）快速排序，平均时间O(N)，最坏的可以是O
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="数组" scheme="https://imlifengfeng.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之数组中出现次数超过一半的数字</title>
    <link href="https://imlifengfeng.github.io/article/652/"/>
    <id>https://imlifengfeng.github.io/article/652/</id>
    <published>2017-03-23T14:31:15.000Z</published>
    <updated>2018-11-27T08:57:05.273Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>这也是剑指 Offer 上的一道很经典的题，对于这道题，我们得分两种情况来讨论：有序和无序。如果数组是有序的，那就非常简单了，数组中间的那个数字一定是我们要求的那个出现次数超过一半的数字。如果数组是无序的，当然可以先将数组进行排序，然后去求中间的那位数字，除此之外是不是还有更简单的方法呢？</p><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个无序数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>对于此题可能有多种解法。</p><p>解法1：</p><p>先将数组进行排序，排过序之后求数组中间的那个数字，该数字就是那个出现次数超过一半的数字。</p><p>解法2：</p><p>借助 hash 表实现，hash 表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。然后直接遍历整个 hash 表 ，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可。</p><p>解法3：</p><p>遍历数组，比较相邻的两个数字，如果这两个数字<strong>不相等则同时删除这两个数字</strong>（不管是不是我们要查找的那个出现次数超过一半的数字），如果<strong>相等则保留这两个数字，从这两个数字中的后一个数字继续往后遍历</strong>，最后剩余的数字就是那个出现次数超过一半的数字。</p><p>例如下面数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>其变化为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>] =&gt; [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>则 1 就是那个出现次数超过一半的数字。</p><p>解法4：</p><p>在遍历数组的时候保存两个值：num（用来保存数组中遍历到的某个数字）和count（用来表示当前数字的出现次数），count初始化为1。当我们遍历到数组中下一个数字的时候：</p><ul><li>如果下一个数字与之前num保存的数字相同，则count加1；</li></ul><ul><li>如果下一个数字与之前num保存的数字不同，则count减1；</li></ul><ul><li>每当出现次数count变为0后，用num保存下一个数字，并把count重新设为1。 直到遍历完数组中的所有数字为止。</li></ul><p>例如下面数组：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="string">[Int]</span> = <span class="string">[1, 1, 2, 1]</span></span><br></pre></td></tr></table></figure><p>（1）开始时num = data[0] = 1，count = 1</p><p>（2）遍历到data[1]，由于data[1] = num = 1，所以此时num = 1，count = count + 1 = 2</p><p>（3）遍历到data[2]，由于data[2] = 2 ≠ num，所以此时count = count - 1 = 1，由于count ≠ 0，故此时num不变，即num = 1</p><p>（4）遍历到data[3]，由于data[3] = num =1，所以此时count = count + 1 = 2，num = 1。遍历结束！</p><p>故出现次数超过一半的数字为num= 1</p><p>比较上面四种解法，解法1需要排序，如果使用效率较高的快速排序的话时间复杂度为O(n·logn)。解法2需要借助 Hash 表，不仅需要O(n)的空间开销还需要设计 hash 函数（当然也可以直接使用 Swift 中的字典）。可以明显发现解法3和解法4要比前两种解法更好一点。解法3和解法4差别不大，基本思想都是类似的，所以接下来使用 Swift 去实现解法4的算法。</p><p>上面已经给出了解法4的原理和思想，这里就直接上代码了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moreHalfNumber</span><span class="params">(data:[Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;data.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            num = data[i]</span><br><span class="line">            <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num == data[i] &#123;</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也是剑指 Offer 上的一道很经典的题，对于这道题，我们得分两种情况来讨论：有序和无序。如果数组是有序的，那就非常简单了，数组中间的那个数字一定是我们要求的那个出现次数超过一半的数字。如果数组是无序的，当然可以先
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="数组" scheme="https://imlifengfeng.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之链表倒数第k个结点</title>
    <link href="https://imlifengfeng.github.io/article/648/"/>
    <id>https://imlifengfeng.github.io/article/648/</id>
    <published>2017-03-22T13:33:01.000Z</published>
    <updated>2018-11-27T09:36:21.391Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>求链表倒数第k个结点是剑指 offer 上一道经典的算法题，并且还有很多类似的算法题，比如求链表的中间结点等，他们的解题思路都是一样的。解类似的题目，最笨的一个方法是先遍历一下整个链表，确定链表结点的数量后再根据数量找出倒数第k个结点或中间的那个结点。不过，本文并不去考虑这种笨办法，还有更好的实现方法。</p><p>题目描述：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第<span class="number">0</span>个节点为链表的尾指针。</span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>对于解决此类问题，最好的方法是使用两个指针实现，首先将第一个指针pNode前进 k 步，然后qNode才开始前进，后面pNode、qNode同时往前移动，当pNode指向尾结点时，pNode指向的结点就是倒数第k个结点。如下图：</p><p><img src="/images/2017/03/Snip20170322_6-1.png" alt="Snip20170322_6"></p><p>当然，链表和上篇文章一样（以后如果不特别说明则链表不变）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: LinkList?</span><br><span class="line">    <span class="keyword">init</span>(_ <span class="keyword">val</span>: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        value = <span class="keyword">val</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求链表倒数第k个结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">theKthLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> k:Int)</span></span>-&gt;<span class="type">LinkList</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pNode = linkList</span><br><span class="line">    <span class="keyword">var</span> tempK = k</span><br><span class="line">    <span class="comment">//pNode先前进k步</span></span><br><span class="line">    <span class="keyword">while</span> tempK &gt; <span class="number">0</span> &amp;&amp; pNode.next != <span class="literal">nil</span>&#123;</span><br><span class="line">        tempK -= <span class="number">1</span></span><br><span class="line">        pNode = pNode.next!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果到这里仍然tempK &gt; 0说明k大于结点总数</span></span><br><span class="line">    <span class="keyword">if</span>(tempK &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"k的值过大不合法！"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//之后qNode从头结点开始跟着pNode一起前进，直到pNode为尾结点</span></span><br><span class="line">    <span class="keyword">var</span> qNode = linkList</span><br><span class="line">    <span class="keyword">while</span> pNode.next != <span class="literal">nil</span>&#123;</span><br><span class="line">        pNode = pNode.next!</span><br><span class="line">        qNode = qNode.next!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> qNode</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是就链表倒数第k个结点的方法。</p><p>对于求链表中间的那个结点（<em>题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点</em>），实现方法还是类似的。也是使用pNode和qNode两个指针实现，方法是。用两个指针pNode和qNode从链表头节点开始，pNode每次向后移动两步，qNode每次移动一步，直到pNode移到到尾节点，那么qNode就是中间结点。</p><p>还有一题类似的是判断单链表是否存在环（<em>题目描述：输入一个单向链表，判断链表是否有环？</em>），解题思想还是一样的，通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p><p>感兴趣的可以自己敲着试下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求链表倒数第k个结点是剑指 offer 上一道经典的算法题，并且还有很多类似的算法题，比如求链表的中间结点等，他们的解题思路都是一样的。解类似的题目，最笨的一个方法是先遍历一下整个链表，确定链表结点的数量后再根据数量
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="链表" scheme="https://imlifengfeng.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之链表</title>
    <link href="https://imlifengfeng.github.io/article/645/"/>
    <id>https://imlifengfeng.github.io/article/645/</id>
    <published>2017-03-22T04:10:02.000Z</published>
    <updated>2018-11-27T09:36:21.251Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p>本文将用Swift去实现链表的增删改查：</p><p>（1）查找链表：按序号查找、按值查找定位</p><p>（2）插入结点</p><p>（3）删除结点</p><p>（4）修改结点</p><p>二、<strong>实现思路及代码</strong></p><p>首先先定义一下链表结点的数据结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: LinkList?</span><br><span class="line">    <span class="keyword">init</span>(_ <span class="keyword">val</span>: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        value = <span class="keyword">val</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于链表的查找，其实很简单，无外乎就是链表的遍历，所以不做过多描述，直接上代码。下面两个查找（按序号查找、按值查找定位）算法时间复杂度都为O(n)</p><p>1、查找链表</p><p>（1）按序号查找</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、按序号查找：查找第index位置上的结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> index:Int)</span></span>-&gt;<span class="type">LinkList</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> linkList = linkList</span><br><span class="line">    <span class="keyword">var</span> tempIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> linkList.next != <span class="literal">nil</span> &amp;&amp; tempIndex &lt; index &#123;</span><br><span class="line">        linkList = linkList.next!</span><br><span class="line">        tempIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> tempIndex == index &#123;</span><br><span class="line">        <span class="keyword">return</span> linkList</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）按值查找定位</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、按值查找定位：获取指定value值的结点在链表中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">locLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> value:Int)</span></span>-&gt;<span class="type">Int</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> linkList = linkList</span><br><span class="line">    <span class="keyword">var</span> tempIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> linkList.value != value &amp;&amp; linkList.next != <span class="literal">nil</span>&#123;</span><br><span class="line">        linkList = linkList.next!</span><br><span class="line">        tempIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> linkList.value == value &#123;</span><br><span class="line">        <span class="keyword">return</span> tempIndex</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、插入结点</p><p>想要在index位置插入结点，首先就要拿到index位置结点的前驱结点，然后通过改变结点的next值去实现结点的插入，如下图：</p><p><img src="/images/2017/03/Snip20170322_1.png" alt="Snip20170322_1"></p><p>算法实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入结点：在index位置插入指定value值的结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertLinkList</span><span class="params">(<span class="number">_</span> linkList:LinkList,<span class="number">_</span> value:Int,<span class="number">_</span> index:Int)</span></span>-&gt;<span class="type">LinkList</span>?&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pNode = getLinkList(linkList,index-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> pNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="type">LinkList</span>(value)</span><br><span class="line">        newNode.next = pNode?.next</span><br><span class="line">        pNode?.next = newNode</span><br><span class="line">        <span class="keyword">return</span> linkList</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、删除结点</p><p>删除结点的原理和插入结点类似，也是拿到index位置结点的前驱结点，然后重置该前驱结点的next值为要删除结点的后一个结点，如下图：</p><p><img src="/images/2017/03/Snip20170322_2.png" alt="Snip20170322_2"></p><p>算法实现如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//删除结点：删除<span class="built_in">index</span>位置的结点</span><br><span class="line">func delLinkList(_ linkLis<span class="variable">t:LinkList</span>,_ <span class="built_in">index</span>:Int)-&gt;LinkList?&#123;</span><br><span class="line">    </span><br><span class="line">    //如果是头结点，则直接返回头结点的下一个结点</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkList.<span class="keyword">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //先拿到要删除的结点的上一个结点</span><br><span class="line">    <span class="keyword">let</span> pNode = getLinkList(linkList, <span class="built_in">index</span>-<span class="number">1</span>)</span><br><span class="line">    //不存在<span class="built_in">index</span>位置结点直接<span class="keyword">return</span> nil</span><br><span class="line">    <span class="keyword">if</span> pNode?.<span class="keyword">next</span> == nil &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"不存在index位置结点！"</span>)</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">    pNode?.<span class="keyword">next</span> = pNode?.<span class="keyword">next</span>?.<span class="keyword">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> linkList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改结点</p><p>修改结点要比插入、删除简单一点，只要拿到该结点然后修改其value值即可。</p><p>算法实现如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改结点：修改index位置的结点</span></span><br><span class="line">func updateLinkList(<span class="literal">_</span> linkList:<span class="type">LinkList</span>,<span class="literal">_</span> index:<span class="type">Int</span>,<span class="literal">_</span> <span class="keyword">new</span><span class="type">Value</span>:<span class="keyword">Int</span>)-&gt;LinkList?&#123;</span><br><span class="line"></span><br><span class="line">    let pNode = getLinkList(linkList, index)</span><br><span class="line">    pNode?.value = <span class="keyword">new</span><span class="type">Value</span></span><br><span class="line"><span class="type"></span>    </span><br><span class="line">    <span class="keyword">return</span> linkList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是用Swift实现的链表的增删改查，大家如果感兴趣可以试着实现删除指定value值的结点和修改指定value值的结点算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="链表" scheme="https://imlifengfeng.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之逐字翻转字符串</title>
    <link href="https://imlifengfeng.github.io/article/643/"/>
    <id>https://imlifengfeng.github.io/article/643/</id>
    <published>2017-03-20T12:07:37.000Z</published>
    <updated>2018-11-27T08:57:05.266Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>翻转字符串在字符串算法中算是比较常见的，而且被很多公司用作笔试题。”逐字翻转字符串”是翻转字符串的翻版，也是之前Google的面试题，原题是这样的：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="keyword">an</span> input <span class="keyword">string</span>, reverse <span class="keyword">the</span> <span class="keyword">string</span> <span class="built_in">word</span> <span class="keyword">by</span> <span class="built_in">word</span>.</span><br><span class="line">A <span class="built_in">word</span> is defined <span class="keyword">as</span> <span class="keyword">a</span> sequence <span class="keyword">of</span> non-<span class="literal">space</span> <span class="keyword">characters</span>.</span><br><span class="line">The input <span class="keyword">string</span> does <span class="keyword">not</span> contain leading <span class="keyword">or</span> trailing spaces <span class="keyword">and</span> <span class="keyword">the</span> <span class="keyword">words</span> are always separated <span class="keyword">by</span> <span class="keyword">a</span> single <span class="literal">space</span>.</span><br><span class="line">For example,</span><br><span class="line">Given s = <span class="string">"the sky is blue"</span>,</span><br><span class="line"><span class="literal">return</span> <span class="string">"blue is sky the"</span>.</span><br><span class="line">Could you <span class="built_in">do</span> <span class="keyword">it</span> <span class="keyword">in</span>-place <span class="keyword">without</span> allocating extra <span class="literal">space</span>?</span><br></pre></td></tr></table></figure><p>简而言之就是：”the sky is blue”—&gt;”blue is sky the”</p><p>所以，对于本文，要解决的算法是：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逐字翻转字符串，例如：<span class="comment">"the sky is blue"</span>—&gt;<span class="comment">"blue is sky the"</span></span><br></pre></td></tr></table></figure><p>接下来看下实现思路和代码。</p><p>二、<strong>实现思路及代码</strong></p><p>既然是字符串翻转的翻版，我们就可以利用之前翻版字符串的思路去解决就可以了，不过这道题要有两次翻转：</p><p>第一次翻转，整体翻转：”the sky is blue” -&gt; “eulb si yks eht”</p><p>第二次翻转，单词翻转：”eulb si yks eht” -&gt; “blue is sky the”</p><p>所以，首先可以实现一个可以翻转局部和全部字符串的算法，传入字符数组、startIndex 和 endIndex ，其中 startIndex 和 endIndex 分别为要翻转的字符串的起始下标和结束下标，也就是要翻转 startIndex 和 endIndex 之间（包含）的字符，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_reverseStr</span><span class="params">( <span class="number">_</span> chars:<span class="keyword">inout</span> [Character], <span class="number">_</span> startIndex:Int, <span class="number">_</span> endIndex:Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> startIndex = startIndex</span><br><span class="line">    <span class="keyword">var</span> endIndex = endIndex</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> startIndex &lt;= endIndex &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> tempChar = chars[endIndex]</span><br><span class="line">        chars[endIndex] = chars[startIndex]</span><br><span class="line">        chars[startIndex] = tempChar</span><br><span class="line">        </span><br><span class="line">        startIndex += <span class="number">1</span></span><br><span class="line">        endIndex -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        _reverseStr(&amp;chars,startIndex,endIndex)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以利用上面的算法去完成前面说的两次翻转：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(<span class="number">_</span> str:String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chars = [<span class="type">Character</span>](str.characters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先翻转整个字符串所有字符,"the sky is blue" -&gt; "eulb si yks eht"</span></span><br><span class="line">    _reverseStr(&amp;chars,<span class="number">0</span>,chars.<span class="built_in">count</span>-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后翻转每个单词中的字符，"eulb si yks eht" -&gt; "blue is sky the"</span></span><br><span class="line">    <span class="keyword">var</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> endIndex <span class="keyword">in</span> <span class="number">0</span> ..&lt; chars.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> endIndex == chars.<span class="built_in">count</span> - <span class="number">1</span> || chars[endIndex + <span class="number">1</span>] == <span class="string">" "</span> &#123;</span><br><span class="line">            _reverseStr(&amp;chars, startIndex, endIndex)</span><br><span class="line">            startIndex = endIndex + <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(chars)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整算法代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//翻转指定范围的字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_reverseStr</span><span class="params">( <span class="number">_</span> chars:<span class="keyword">inout</span> [Character], <span class="number">_</span> startIndex:Int, <span class="number">_</span> endIndex:Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> startIndex = startIndex</span><br><span class="line">    <span class="keyword">var</span> endIndex = endIndex</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> startIndex &lt;= endIndex &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> tempChar = chars[endIndex]</span><br><span class="line">        chars[endIndex] = chars[startIndex]</span><br><span class="line">        chars[startIndex] = tempChar</span><br><span class="line">        </span><br><span class="line">        startIndex += <span class="number">1</span></span><br><span class="line">        endIndex -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        _reverseStr(&amp;chars,startIndex,endIndex)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐字翻转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(<span class="number">_</span> str:String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chars = [<span class="type">Character</span>](str.characters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先翻转整个字符串所有字符,"the sky is blue" -&gt; "eulb si yks eht"</span></span><br><span class="line">    _reverseStr(&amp;chars,<span class="number">0</span>,chars.<span class="built_in">count</span>-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后翻转每个单词中的字符，"eulb si yks eht" -&gt; "blue is sky the"</span></span><br><span class="line">    <span class="keyword">var</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> endIndex <span class="keyword">in</span> <span class="number">0</span> ..&lt; chars.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> endIndex == chars.<span class="built_in">count</span> - <span class="number">1</span> || chars[endIndex + <span class="number">1</span>] == <span class="string">" "</span> &#123;</span><br><span class="line">            _reverseStr(&amp;chars, startIndex, endIndex)</span><br><span class="line">            startIndex = endIndex + <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(chars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseWords(<span class="string">"the sky is blue"</span>) <span class="comment">//return "blue is sky the"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻转字符串在字符串算法中算是比较常见的，而且被很多公司用作笔试题。”逐字翻转字符串”是翻转字符串的翻版，也是之前Google的面试题，原题是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight live
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="字符串" scheme="https://imlifengfeng.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Swift算法实现之字符串转数字</title>
    <link href="https://imlifengfeng.github.io/article/641/"/>
    <id>https://imlifengfeng.github.io/article/641/</id>
    <published>2017-03-19T17:50:00.000Z</published>
    <updated>2018-11-27T08:57:05.263Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>学完Swift之后一直没有机会实战，由于Swift发展历史原因，目前网上大部分的算法都是使用C、Java或其他语言实现的，几乎没有使用Swift实现的，所以自己打算使用Swift去实现一些主流的算法，既是对自己Swift的回顾，也是对自己算法方面的提高。</p><p>首先是用Swift实现字符串转数字，当然，肯定是不能使用Swift自带的字符串转数字的api。</p><p>题目：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用Swift实现一个方法，输入字符串，输出该字符串转换成的数字。</span><br><span class="line">例如，输入字符串“<span class="number">125</span>”，输出数字<span class="number">125</span></span><br></pre></td></tr></table></figure><p>二、<strong>实现思路及代码</strong></p><p>首先先考虑可能输入情况，包括非法输入：</p><ul><li>情况1：所有字符均可直接转换成数字，如”125”</li></ul><ul><li>情况2：包含一个或多个正负号，如”-125”、”–+125”</li></ul><ul><li>情况3：包含非法字符，如”125lff”</li></ul><p>如果是情况1，处理起来将会非常简单：首先利用ASCII编码将字符串“125”的每个字符转换为数字，之后转换成数字后直接用乘法和加法即可：1<em>100+2</em>10+3=123。</p><p>但是实际情况并不那么简单，由于情况2和情况3的存在，上面直接用乘法和加法肯定不可行的，中间还得加上相应的判断。最佳的方式是我们直接遍历字符串中的字符，先假设没有正负号和非法字符的存在，当遍历到第一个字符”1”的时候，intStr=1，当遍历到第二个字符”2”的时候，intStr = intStr<em>10+2=12，当遍历到最后一个字符”3”的时候,intStr = intStr</em>10+3=123。</p><p>关于”+”和”-“，只有当它们在字符串的开头的时候才表示正负，在字符串中间存在就是非法字符。我们可以通过ASCII编码判断”+”和”-“（对应的值分别为43和45），设个变量s表示多个”+”和”-“累积之后的正负。最后结果为intStr = s * intStr。当遍历字符串过程中发现了非法字符，则终止后续遍历，并给出提示。</p><p>实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrToInt</span><span class="params">(str:String)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串不能为空</span></span><br><span class="line">    <span class="keyword">guard</span> str.isEmpty == <span class="literal">false</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"字符串不能为空~"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> strInt:<span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> characterInt <span class="keyword">in</span> str.unicodeScalars &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只能包含数字或正负号</span></span><br><span class="line">        <span class="keyword">let</span> tempStrInt = characterInt.hashValue  - <span class="string">"0"</span>.unicodeScalars.first!.hashValue</span><br><span class="line">        <span class="keyword">guard</span> (tempStrInt &lt;= <span class="number">9</span> &amp;&amp; tempStrInt &gt;= <span class="number">0</span>) || (characterInt.hashValue == <span class="number">43</span> || characterInt.hashValue == <span class="number">45</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"包含非法字符！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正负号只能存在于字符串开头</span></span><br><span class="line">        <span class="keyword">if</span> characterInt.hashValue == <span class="number">43</span> || characterInt.hashValue == <span class="number">45</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> strInt == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"正负号只能存在于字符串开头！"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//既然走到这一步，说明字符串合法</span></span><br><span class="line">        <span class="comment">//判断正负数</span></span><br><span class="line">        <span class="keyword">if</span> characterInt.hashValue == <span class="number">43</span> || characterInt.hashValue == <span class="number">45</span>&#123;</span><br><span class="line">            s = s * ( <span class="number">44</span> - characterInt.hashValue )</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> strInt == <span class="literal">nil</span> &#123;</span><br><span class="line">                strInt = characterInt.hashValue - <span class="string">"0"</span>.unicodeScalars.first!.hashValue</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//使用溢出运算符&amp;*和&amp;+避免数值过大导致溢出崩溃</span></span><br><span class="line">                strInt = strInt! &amp;* <span class="number">10</span> &amp;+ ( characterInt.hashValue - <span class="string">"0"</span>.unicodeScalars.first!.hashValue )  </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result:<span class="type">Int</span>? = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> strInt != <span class="literal">nil</span> &#123;</span><br><span class="line">        result = s * strInt!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现的算法中：</p><p>输入”125”，输出125</p><p>输入”+-125”，输出-125</p><p>输入”1-25”，提示”正负号只能存在于字符串开头！”</p><p>输入”1m25”，提示”包含非法字符”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学完Swift之后一直没有机会实战，由于Swift发展历史原因，目前网上大部分的算法都是使用C、Java或其他语言实现的，几乎没有使用Swift实现的，所以自己打算使用Swift去实现一些主流的算法，既是对自己Swi
      
    
    </summary>
    
      <category term="算法" scheme="https://imlifengfeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Swift" scheme="https://imlifengfeng.github.io/tags/Swift/"/>
    
      <category term="字符串" scheme="https://imlifengfeng.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>使用 LLDB 调试 APP</title>
    <link href="https://imlifengfeng.github.io/article/622/"/>
    <id>https://imlifengfeng.github.io/article/622/</id>
    <published>2017-03-13T15:03:03.000Z</published>
    <updated>2018-11-27T09:36:21.109Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>LLDB全称 [ Low Level Debugger ], 默认内置于Xcode中的动态调试工具。标准的 LLDB 提供了一组广泛的命令，旨在与熟悉的 GDB 命令兼容。 除了使用标准配置外，还可以很容易地自定义 LLDB 以满足实际需要。</p><p>二、<strong>LLDB调试命令</strong></p><p>首先先通过一个简单的例子体验下 LLDB 调试：</p><p><img src="/images/2017/03/Snip20170313_1.png" alt="Snip20170313_1"></p><p>我们在上面第25行添加了断点，运行后程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。我们使用 _print _命令打印 age 的值：</p><p><img src="/images/2017/03/Snip20170313_2.png" alt="Snip20170313_2"></p><p>如上图，输入 _print age _命令回车即可打印出 age 的值，结果前的 $0 可以用来指向这个结果。例如我们使用 _print $0 + 5 _命令测试一下：</p><p><img src="/images/2017/03/Snip20170313_3.png" alt="Snip20170313_3"></p><p>如上图可知 _print $0 + 5 _相当于 _print age + 5 _。</p><p>LLBD 语法结构：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;command&gt;</span> [<span class="symbol">&lt;subcommand&gt;</span> [<span class="symbol">&lt;subcommand&gt;</span>...]] <span class="symbol">&lt;action&gt;</span> [-<span class="keyword">options</span> [option-value]] [<span class="keyword">argument</span> [<span class="keyword">argument</span>...]]</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">command</span>&gt;</span>(命令)和<span class="tag">&lt;<span class="name">subcommand</span>&gt;</span>(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</span><br><span class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span>：执行命令的操作</span><br><span class="line"><span class="tag">&lt;<span class="name">options</span>&gt;</span>：命令选项</span><br><span class="line"><span class="tag">&lt;<span class="name">arguement</span>&gt;</span>：命令的参数</span><br><span class="line">[]：表示命令是可选的，可以有也可以没有</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint <span class="keyword">set</span> -f <span class="comment">main.m -l 16</span></span><br></pre></td></tr></table></figure><p>与上面语法结构对应的是：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">command:</span> breakpoint 添加断点命令</span><br><span class="line"><span class="symbol">action:</span> <span class="keyword">set</span> 表示设置断点</span><br><span class="line"><span class="symbol">option:</span> -f 表示在某文件添加断点</span><br><span class="line"><span class="symbol">arguement:</span> mian.m 表示要添加断点的文件名为mian.m</span><br><span class="line"><span class="symbol">option:</span> -l 表示某一行</span><br><span class="line"><span class="symbol">arguement:</span> <span class="number">16</span> 表示第<span class="number">16</span>行</span><br></pre></td></tr></table></figure><p>Commands，subcommands，options，option values和arguments都是以空格分隔的，双引号用于保护选项值和参数中的空格。 如果需要将反斜杠或双引号字符放入参数中，则在该参数前面加上反斜杠。 LLDB使用单引号和双引号是等价的。例如：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command <span class="string">[subcommand]</span> -option <span class="string">"some \"</span>quoted\<span class="string">" string"</span></span><br></pre></td></tr></table></figure><p>也可以这样写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">command</span> [subcommand] -<span class="keyword">option</span> 'some <span class="string">"quoted"</span> <span class="keyword">string</span>'</span><br></pre></td></tr></table></figure><p>上面的print命令只是LLDB调试中的一个很简单但很常用的命令，除此之外还有很多有可能用到的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">调试器命令:</span><br><span class="line"></span><br><span class="line">  apropos           <span class="comment">-- 列出与单词或主题相关的调试器命令</span></span><br><span class="line">  breakpoint        <span class="comment">-- 在断点上操作的命令 (详情使用'help b'查看)</span></span><br><span class="line">  bugreport         <span class="comment">-- 用于创建指定域的错误报告</span></span><br><span class="line">  command           <span class="comment">-- 用于管理自定义LLDB命令的命令</span></span><br><span class="line">  disassemble       <span class="comment">-- 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span></span><br><span class="line">  expression        <span class="comment">-- 求当前线程上的表达式的值。 以LLDB默认格式显示返回的值</span></span><br><span class="line">  frame             <span class="comment">-- 用于选择和检查当前线程的堆栈帧的命令</span></span><br><span class="line">  gdb-remote        <span class="comment">-- 通过远程GDB服务器连接到进程。 如果未指定主机，则假定为localhost</span></span><br><span class="line">  gui               <span class="comment">-- 切换到基于curses的GUI模式</span></span><br><span class="line">  <span class="keyword">help</span>              <span class="comment">-- 显示所有调试器命令的列表，或提供指定命令的详细信息</span></span><br><span class="line">  kdp-remote        <span class="comment">-- 通过远程KDP服务器连接到进程。 如果没有指定UDP端口，则假定端口41139</span></span><br><span class="line">  <span class="keyword">language</span>          <span class="comment">-- 指定源语言</span></span><br><span class="line">  <span class="keyword">log</span>               <span class="comment">-- 控制LLDB内部日志记录的命令</span></span><br><span class="line">  <span class="keyword">memory</span>            <span class="comment">-- 用于在当前目标进程的内存上操作的命令</span></span><br><span class="line">  platform          <span class="comment">-- 用于管理和创建平台的命令</span></span><br><span class="line">  <span class="keyword">plugin</span>            <span class="comment">-- 用于管理LLDB插件的命令</span></span><br><span class="line">  process           <span class="comment">-- 用于与当前平台上的进程交互的命令</span></span><br><span class="line">  quit              <span class="comment">-- 退出LLDB调试器</span></span><br><span class="line">  <span class="keyword">register</span>          <span class="comment">-- 命令访问当前线程和堆栈帧的寄存器</span></span><br><span class="line">  script            <span class="comment">-- 使用提供的代码调用脚本解释器并显示任何结果。 如果没有提供代码，启动交互式解释器。</span></span><br><span class="line">  <span class="keyword">settings</span>          <span class="comment">-- 用于管理LLDB设置的命令</span></span><br><span class="line">  <span class="keyword">source</span>            <span class="comment">-- 检查当前目标进程的调试信息所描述的源代码的命令</span></span><br><span class="line">  target            <span class="comment">-- 用于在调试器目标上操作的命令</span></span><br><span class="line">  <span class="keyword">thread</span>            <span class="comment">-- 用于在当前进程中的一个或多个线程上操作的命令</span></span><br><span class="line">  <span class="keyword">type</span>              <span class="comment">-- 在类型系统上操作的命令</span></span><br><span class="line">  <span class="keyword">version</span>           <span class="comment">-- 显示LLDB调试器版本</span></span><br><span class="line">  watchpoint        <span class="comment">-- 在观察点上操作的命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩写命令 (使用 <span class="string">'help command alias'</span>查看更多信息):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">add</span>-dsym  <span class="comment">-- ('target symbols add')  通过指定调试符号文件的路径，或使用选项指定下载符号的模块，将调试符号文件添加到目标的当前模块中的一个</span></span><br><span class="line">  attach    <span class="comment">-- ('_regexp-attach')  通过ID或名称附加到进程</span></span><br><span class="line">  b         <span class="comment">-- ('_regexp-break')  使用几种简写格式之一设置断点</span></span><br><span class="line">  bt        <span class="comment">-- ('_regexp-bt')  显示当前线程的调用堆栈。通过数字参数设置最多显示帧数。参数“all”显示所有线程</span></span><br><span class="line">  c         <span class="comment">-- ('process continue')  继续执行当前进程中的所有线程</span></span><br><span class="line">  <span class="keyword">call</span>      <span class="comment">-- ('expression --')  计算当前线程上的表达式,使用LLDB的默认格式显示返回的值</span></span><br><span class="line">  continue  <span class="comment">-- ('process continue')  继续执行当前进程中的所有线程</span></span><br><span class="line">  detach    <span class="comment">-- ('process detach')  脱离当前目标进程</span></span><br><span class="line">  di        <span class="comment">-- ('disassemble')  拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span></span><br><span class="line">  dis       <span class="comment">-- ('disassemble')  同上</span></span><br><span class="line">  display   <span class="comment">-- ('_regexp-display')  在每次停止时计算表达式（请参阅'help target stop-hook'）</span></span><br><span class="line">  down      <span class="comment">-- ('_regexp-down')  选择一个新的堆栈帧。默认为移动一个帧，数字参数可以指定值</span></span><br><span class="line">  env       <span class="comment">-- ('_regexp-env')  查看和设置环境变量的简写</span></span><br><span class="line">  <span class="keyword">exit</span>      <span class="comment">-- ('quit')  退出LLDB调试器</span></span><br><span class="line">  f         <span class="comment">-- ('frame select')  从当前线程中通过索引选择当前堆栈帧（参见'thread backtrace'）</span></span><br><span class="line">  <span class="keyword">file</span>      <span class="comment">-- ('target create')  使用参数作为主要可执行文件创建目标</span></span><br><span class="line">  <span class="keyword">finish</span>    <span class="comment">-- ('thread step-out')  完成当前堆栈帧的执行并返回后停止。 默认为当前线程</span></span><br><span class="line">  image     <span class="comment">-- ('target modules')  用于访问一个或多个目标模块的信息的命令</span></span><br><span class="line">  j         <span class="comment">-- ('_regexp-jump')  将程序计数器设置为新地址</span></span><br><span class="line">  jump      <span class="comment">-- ('_regexp-jump')  同上</span></span><br><span class="line">  <span class="keyword">kill</span>      <span class="comment">-- ('process kill')  终止当前目标进程</span></span><br><span class="line">  l         <span class="comment">-- ('_regexp-list')  使用几种简写格式之一列出相关的源代码</span></span><br><span class="line">  <span class="keyword">list</span>      <span class="comment">-- ('_regexp-list')  同上</span></span><br><span class="line">  n         <span class="comment">-- ('thread step-over')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  <span class="keyword">next</span>      <span class="comment">-- ('thread step-over')  同上</span></span><br><span class="line">  nexti     <span class="comment">-- ('thread step-inst-over')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  ni        <span class="comment">-- ('thread step-inst-over')  同上</span></span><br><span class="line">  p         <span class="comment">-- ('expression --')  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  parray    <span class="comment">-- ('expression -Z %1   --')  同上</span></span><br><span class="line">  po        <span class="comment">-- 计算当前线程上的表达式。显示由类型作者控制的格式的返回值。</span></span><br><span class="line">  poarray   <span class="comment">-- ('expression -O -Z %1    --')  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  print     <span class="comment">-- ('expression --')  同上</span></span><br><span class="line">  q         <span class="comment">-- ('quit')  退出LLDB调试器</span></span><br><span class="line">  r         <span class="comment">-- ('process launch -X true --')  在调试器中启动可执行文件</span></span><br><span class="line">  rbreak    <span class="comment">-- ('breakpoint set -r %1')  在可执行文件中设置断点或断点集</span></span><br><span class="line">  repl      <span class="comment">-- ('expression -r  -- ')  E计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  run       <span class="comment">-- ('process launch -X true --')  在调试器中启动可执行文件</span></span><br><span class="line">  s         <span class="comment">-- ('thread step-in')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  si        <span class="comment">-- ('thread step-inst')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  sif       <span class="comment">-- 遍历当前块，如果直接步入名称与TargetFunctionName匹配的函数，则停止</span></span><br><span class="line">  step      <span class="comment">-- ('thread step-in')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  stepi     <span class="comment">-- ('thread step-inst')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  t         <span class="comment">-- ('thread select')  更改当前选择的线程</span></span><br><span class="line">  tbreak    <span class="comment">-- ('_regexp-tbreak')  使用几种简写格式之一设置单次断点</span></span><br><span class="line">  undisplay <span class="comment">-- ('_regexp-undisplay')  每次停止时停止显示表达式（由stop-hook索引指定）</span></span><br><span class="line">  up        <span class="comment">-- ('_regexp-up')  选择较早的堆栈帧。 默认为移动一个帧，数值参数可以指定任意数字</span></span><br><span class="line">  x         <span class="comment">-- ('memory read')  从当前目标进程的内存中读取</span></span><br></pre></td></tr></table></figure><p>当然，上面大部分命令是不经常使用的，不用全部记住，需要查找想要的命令时可以直接使用”help”命令显示所有调试器命令的列表，或查询指定命令的详细信息。</p><p>三、<strong>LLDB调试示例</strong></p><p>1、打印命令</p><p>打印命令是在实际开发中是经常使用的，在前面的例子中就测试了使用<em>print</em>命令去打印 age 的值，除了 _print <em>命令外，还有多种打印命令：</em> p、po、call_。我们可以通过实际测试看下他们的区别：</p><p><img src="/images/2017/03/Snip20170313_5.png" alt="Snip20170313_5"></p><p>可以看到 _po _命令只是打印数值，而 _print、p、call _命令还打印了变量的类型。所以，在实际开发中根据需要选择合适的打印命令。</p><p>在打印变量的值的时候，我们还可以使用_ print/<fmt>_ 或者简化的 <em>p/<fmt></fmt></em>指定打印格式，例如打印十六进制:</fmt></p><p><img src="/images/2017/03/Snip20170313_7.png" alt="Snip20170313_7"></p><p>x 代表十六进制格式、t 代表二进制格式，其他格式类型请<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">点击这里</a>查看。</p><p>从前面的命令列表可以看到 _print、p、po、call _都是 _expression _命令的简写，而 _expression _的作用是“求当前线程上的表达式的值”，也就是说我们可以利用它们更改变量的值，例如我们将 age 的值修改为100：</p><p><img src="/images/2017/03/Snip20170313_6.png" alt="Snip20170313_6"></p><p>2、断点操作</p><p>要在调试器中创建断点，可以使用_ breakpoint set _命令:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">breakpoint <span class="keyword">set</span></span><br><span class="line">   -M &lt;<span class="function"><span class="keyword">method</span>&gt; <span class="params">( --<span class="keyword">method</span> &lt;<span class="keyword">method</span>&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">S</span> &lt;<span class="title">selector</span>&gt; <span class="params">( --<span class="keyword">selector</span> &lt;<span class="keyword">selector</span>&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">b</span> &lt;<span class="title">function</span>-<span class="title">name</span>&gt; <span class="params">( --basename &lt;<span class="keyword">function</span>-name&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">f</span> &lt;<span class="title">filename</span>&gt; <span class="params">( --file &lt;filename&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">l</span> &lt;<span class="title">linenum</span>&gt; <span class="params">( --line &lt;linenum&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">n</span> &lt;<span class="title">function</span>-<span class="title">name</span>&gt; <span class="params">( --name &lt;<span class="keyword">function</span>-name&gt; )</span></span></span><br><span class="line"><span class="function">…</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="builtin-name">set</span> -f ViewController.m -l 25</span><br><span class="line">Breakpoint 2: where = LLDBTest`-[ViewController lldbTest] + 50 at ViewController.m:25,<span class="built_in"> address </span>= 0x0000000102c90752</span><br></pre></td></tr></table></figure><p>上面含义为在 ViewController.m 文件的第25行添加断点。</p><p>也可以使用缩写形式  _br_。虽然 _b_ 是一个完全不同的命令 ( _regexp-break 的缩写)，但恰好也可以实现和上面同样的效果。</p><p>如果给当前的文件设置断点可以用下面的命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b 25</span><br><span class="line">Breakpoint 3: where = LLDBTest`-[ViewController lldbTest] + 50 at ViewController.m:25,<span class="built_in"> address </span>= 0x0000000102c90752</span><br></pre></td></tr></table></figure><p>也可以通过方法名设置断点：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="builtin-name">set</span> -n lldbTest</span><br><span class="line">Breakpoint 5: where = LLDBTest`-[ViewController lldbTest] + 23 at ViewController.m:23,<span class="built_in"> address </span>= 0x0000000102c90737</span><br></pre></td></tr></table></figure><p>上面 _-n _表示根据方法名设置断点。</p><p>查看所有断点：<em>breakpoint list</em> (或者 <em>br li</em>)</p><p>开启和关闭断点：<em>breakpoint enable <breakpointid></breakpointid></em> 和 <em>breakpoint disable <breakpointid>；</breakpointid></em></p><p>删除断点：<em>breakpoint delete <breakpointid></breakpointid></em></p><p>单步进入：<em>thread step-in</em>（或 <em>step</em> 或 _s_ ）</p><p>单步跳过：<em>thread step-over</em>（或 <em>next</em> 或 _n_）</p><p>继续运行：<em>thread continue</em>（或 <em>continue</em> 或 _c_）</p><p>3、设置观察点</p><p>通过上面的命令列表可以知道设置观察点使用 _watchpoint _命令，如果说 breakpoint 是对方法生效的断点，watchpoint就是对地址生效的断点，可以用他观察这个属性的地址。如果地址里面的东西改变了，就让程序中断。设置观察点可以用来观察变量或者属性值的变化。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">set</span> <span class="keyword">variable</span></span><br></pre></td></tr></table></figure><p>例如，我们要观察一个名为city的属性值：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">set</span> <span class="keyword">variable</span> <span class="comment">self-&gt;_city</span></span><br></pre></td></tr></table></figure><p>要特别注意，上面的”self-&gt;_city”不可以改为”self.city”，因为”self.city”是调用city的getter方法！</p><p>如下，我们新增一个city属性并设置观察点：</p><p><img src="/images/2017/03/Snip20170313_9.png" alt="Snip20170313_9"></p><p>由于在第27行我们修改（设置）了 city 的值，所以继续运行程序会中断并且打印提示：</p><p><img src="/images/2017/03/Snip20170313_10.png" alt="Snip20170313_10"></p><p>我们也可以使用下面命令直接观察某个地址的变化：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="builtin-name">set</span> expression</span><br></pre></td></tr></table></figure><p>比如我们要观察上面 city 属性的地址变化，应该怎么获取 city 的地址呢？可以使用上面的打印命令，通过打印命令获取到地址之后就可以观察地址的变化了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp; _city</span><br><span class="line">(NSString **) <span class="variable">$0</span> = 0x00007ffc80e100c8</span><br><span class="line">(lldb) watchpoint <span class="builtin-name">set</span> expression 0x00007ffc80e100c8</span><br><span class="line">Watchpoint created: Watchpoint 1: addr = 0x7ffc80e100c8 size = 8 state = enabled<span class="built_in"> type </span>= w</span><br><span class="line">    new value: 0</span><br></pre></td></tr></table></figure><p>_watchpoint _的查询、删除等命令与 _breakpoint _的命令使用一样，就不再一一列举用法了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">delete</span> </span><br><span class="line">watchpoint <span class="keyword">list</span></span><br><span class="line">watchpoint <span class="keyword">disable</span></span><br><span class="line">watchpoint <span class="keyword">enable</span></span><br></pre></td></tr></table></figure><p>4、打印线程堆栈信息</p><p>可以使用 thread backtrace（或_ bt_ ）命令打印线程堆栈信息：</p><p><img src="/images/2017/03/Snip20170313_11.png" alt="Snip20170313_11"></p><p>_thread backtrace _后面可以添加命令选项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c：设置打印堆栈的帧数(frame) </span></span><br><span class="line"><span class="deletion">-s：设置从哪个帧(frame)开始打印 </span></span><br><span class="line"><span class="deletion">-e：是否显示额外的回溯</span></span><br></pre></td></tr></table></figure><p>Debug 的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。可以使用 _thread return _命令：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="keyword">return</span> <span class="string">'要返回的值'</span></span><br></pre></td></tr></table></figure><p><em>thread return</em> 不让代码执行某个方法，可以在某个方法的开始位置设置一个断点，当程序运行到断点的位置时直接返回我们设置的返回值。</p><p>thread其他命令：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread</span> <span class="built_in">list</span> <span class="comment">//打印所有线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread</span> <span class="keyword">select</span> <span class="comment">//跳到某一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread</span> info <span class="comment">//输出当前线程的信息</span></span><br></pre></td></tr></table></figure><p>5、查看帧栈</p><p>打印当前帧栈所有变量：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame <span class="keyword">variable</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame <span class="keyword">variable</span></span><br><span class="line">(ViewController <span class="comment">*) self = 0x00007fc0684085f0</span></span><br><span class="line">(SEL) _cmd <span class="comment">=</span> <span class="comment">"lldbTest"</span></span><br><span class="line">(__NSCFConstantString <span class="comment">*) name = 0x0000000102a2f068 @</span><span class="comment">"lifengfeng"</span></span><br><span class="line">(NSInteger) age <span class="comment">= 25</span></span><br></pre></td></tr></table></figure><p>打印某个变量：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame <span class="keyword">variable</span> <span class="string">'变量名'</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame variable <span class="built_in">name</span></span><br><span class="line">(<span class="variable">__NSCFConstantString</span> *) <span class="built_in">name</span> = <span class="number">0</span>x0000000102a2f068 @<span class="string">"lifengfeng"</span></span><br></pre></td></tr></table></figure><p>查看当前帧栈的信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame info</span><br><span class="line">frame #0: 0x0000000102a2d63f LLDBTest`-[<span class="string">ViewController lldbTest</span>](<span class="link">self=0x00007fc0684085f0, _cmd="lldbTest"</span>) + 79 at ViewController.m:28</span><br></pre></td></tr></table></figure><p>跳转到指定帧栈：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span> <span class="literal">select</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame select 0</span><br><span class="line">frame #0: 0x0000000102a2d63f LLDBTest`-[<span class="string">ViewController lldbTest</span>](<span class="link">self=0x00007fc0684085f0, _cmd="lldbTest"</span>) + 79 at ViewController.m:28</span><br><span class="line">   25      NSString *name = @"lifengfeng";</span><br><span class="line">   26      NSInteger age = 25;</span><br><span class="line">   27      _city = @"BJ";</span><br><span class="line">-&gt; 28      NSLog(@"%@ age is %ld，city is %@",name,(long)age,_city);</span><br><span class="line">   29      </span><br><span class="line">   30  &#125;</span><br><span class="line">   31</span><br></pre></td></tr></table></figure><p>6、动态改变程序的运行轨迹</p><p>expression命令用来执行一个命令，并将表达式的结果输出。除此之外，expression还可以动态改变程序的运行轨迹。例如，我们上面例子中就是一个空白的ViewController，我们可以利用expression命令来改变UI的显示，如self.view的颜色等。</p><p>expression的完整语法如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression <span class="comment">--</span></span><br></pre></td></tr></table></figure><p>上面的”–”是命令选项结束符，表示所有的命令选项已经设置完毕，如果没有命令选项，–可以省略。</p><p>例如，我们改变self.view的颜色：</p><p><img src="/images/2017/03/Snip20170313_16.png" alt="Snip20170313_16"></p><p>其中，下面的命令用于刷新UI。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression -- (<span class="keyword">void</span>)[CATransaction <span class="built_in">flush</span>]</span><br></pre></td></tr></table></figure><p>以上就是LLDB调试常用用法，其他更多用法可以去研究下官方文档，总之LLDB调试对iOS开发者来说是一个非常重要的技能。</p><p>参考：<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html" target="_blank" rel="noopener">Getting Started with LLDB</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LLDB全称 [ Low Level Debugger ], 默认内置于Xcode中的动态调试工具。标准的 LLDB 提供了一组广泛的命令，旨在与熟悉的 GDB 命令兼容。 除了使用标准配置外，还可以很容易地自定义 
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="LLDB" scheme="https://imlifengfeng.github.io/tags/LLDB/"/>
    
      <category term="调试" scheme="https://imlifengfeng.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Notification与多线程</title>
    <link href="https://imlifengfeng.github.io/article/620/"/>
    <id>https://imlifengfeng.github.io/article/620/</id>
    <published>2017-03-11T11:17:52.000Z</published>
    <updated>2018-11-27T09:36:20.944Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在多线程中，无论在哪个线程注册了观察者，Notification接收和处理都是在发送Notification的线程中的。所以，当我们需要在接收到Notification后作出更新UI操作的话，就需要考虑线程的问题了，如果在子线程中发送Notification，想要在接收到Notification后更新UI的话就要切换回到主线程。先看一个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *NOTIFICATION_NAME = <span class="string">@"NOTIFICATION_NAME"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:NOTIFICATION_NAME object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Post notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:NOTIFICATION_NAME object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Receive notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-03-11</span> <span class="number">17</span>:<span class="number">56:33.898</span> NotificationTest[<span class="number">23457</span>:<span class="number">1615587</span>] Current thread = &lt;NSThread: <span class="number">0</span>x6<span class="number">08000078080</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">17</span>:<span class="number">56:33.899</span> NotificationTest[<span class="number">23457</span>:<span class="number">1615738</span>] Post notification，Current thread = &lt;NSThread: <span class="number">0</span>x600<span class="number">00026c500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">17</span>:<span class="number">56:33.899</span> NotificationTest[<span class="number">23457</span>:<span class="number">1615738</span>] Receive notification，Current thread = &lt;NSThread: <span class="number">0</span>x600<span class="number">00026c500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>上面我们在主线程注册观察者，在子线程发送Notification，最后Notification的接收和处理也是在子线程。</p><p>二、<strong>重定向Notification到指定线程</strong></p><p>当然，想要在子线程发送Notification、接收到Notification后在主线程中做后续操作，可以用一个很笨的方法，在 handleNotification 里面强制切换线程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Receive notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在简单情况下可以使用这种方法，但是当我们发送了多个Notification并且有多个观察者的时候，难道我们要在每个地方都手动切换线程？所以，这种方法并不是一个有效的方法。</p><p>最好的方法是在Notification所在的默认线程中捕获发送的通知，然后将其重定向到指定的线程中。关于Notification的重定向官方文档给出了一个方法：</p><p><img src="/images/2017/03/Snip20170311_1.png" alt="Snip20170311_1"></p><p>翻译成中文：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种重定向的实现思路是自定义一个通知队列(不是NSNotificationQueue对象)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像之前一样去注册一个通知的观察者，当Notification到达时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，就将这个Notification放到我们的队列中，然后发送一个信号(<span class="keyword">signal</span><span class="string">)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程收到这个信号</span>(<span class="keyword">signal</span><span class="string">)后，将Notification从队列中移除，并进行后续处理。</span></span><br></pre></td></tr></table></figure><p>我们根据官方文档中的教程测试一下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  NotificationTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/11.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>    *notifications;         <span class="comment">// 通知队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span>          *notificationThread;    <span class="comment">// 想要处理通知的线程（目标线程）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span>            *notificationLock;      <span class="comment">// 用于对通知队列加锁的锁对象，避免线程冲突</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMachPort</span>        *notificationPort;      <span class="comment">// 用于向目标线程发送信号的通信端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *NOTIFICATION_NAME = <span class="string">@"NOTIFICATION_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setUpThreadingSupport];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册观察者</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processNotification:) name:NOTIFICATION_NAME object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送Notification</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Post notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:NOTIFICATION_NAME object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在注册任何通知之前，需要先初始化属性。下面方法初始化了队列和锁定对象，保留对当前线程对象的引用，并创建一个Mach通信端口，将其添加到当前线程的运行循环中。</span></span><br><span class="line"><span class="comment">    此方法运行后，发送到notificationPort的任何消息都会在首次运行此方法的线程的run loop中接收。如果接收线程的run loop在Mach消息到达时没有运行，则内核保持该消息，直到下一次进入run loop。接收线程的run loop将传入消息发送到端口delegate的handleMachMessage：方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) setUpThreadingSupport &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.notifications) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.notifications      = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationLock   = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.notificationPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort</span><br><span class="line">                                forMode:(__bridge <span class="built_in">NSString</span>*)kCFRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 端口的代理方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span> processNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是不是目标线程，不是则转发到目标线程</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != _notificationThread) &#123;</span><br><span class="line">        <span class="comment">// 将Notification转发到目标线程</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                   components:<span class="literal">nil</span></span><br><span class="line">                                         from:<span class="literal">nil</span></span><br><span class="line">                                     reserved:<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处理通知</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Receive notification，Current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Process notification"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.788</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665269</span>] Current thread = &lt;NSThread: <span class="number">0</span>x608<span class="number">00006d4c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.789</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665396</span>] Post notification，Current thread = &lt;NSThread: <span class="number">0</span>x60800026bc40&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.795</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665269</span>] Receive notification，Current thread = &lt;NSThread: <span class="number">0</span>x608<span class="number">00006d4c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2017-03-11</span> <span class="number">18</span>:<span class="number">28:55.795</span> NotificationTest[<span class="number">24080</span>:<span class="number">1665269</span>] Process notification</span><br></pre></td></tr></table></figure><p>可以看到，运行结果结果我们想要的：在子线程中发送Notification，在主线程中接收与处理Notification。</p><p>上面的实现方法也不是绝对完美的，苹果官方指出了这种方法的限制：</p><p>（1）所有线程的Notification的处理都必须通过相同的方法（processNotification :)。</p><p>（2）每个对象必须提供自己的实现和通信端口。</p><p>更好但更复杂的方法是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。</p><p>除了上面苹果官方给我们提供的方法外，我们还可以利用基于block的NSNotification去实现，apple 从 ios4 之后提供了带有 block 的 NSNotification。使用方式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (id&lt;NSObject&gt;)<span class="selector-tag">addObserverForName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span></span><br><span class="line">                           <span class="selector-tag">object</span><span class="selector-pseudo">:(id)obj</span></span><br><span class="line">                            <span class="selector-tag">queue</span><span class="selector-pseudo">:(NSOperationQueue</span> *)<span class="selector-tag">queue</span></span><br><span class="line">                       <span class="selector-tag">usingBlock</span><span class="selector-pseudo">:(void</span> (^)(NSNotification *note))<span class="selector-tag">block</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>观察者就是当前对象</li></ul><ul><li>queue 定义了 block 执行的线程，nil 则表示 block 的执行线程和发通知在同一个线程</li></ul><ul><li>block 就是相应通知的处理函数</li></ul><p>这个 API 已经能够让我们方便的控制通知的线程切换。但是，这里有个问题需要注意。就是其 remove 操作。</p><p>原来的 NSNotification 的 remove 方式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">removeObservers</span> &#123;</span><br><span class="line">    <span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">name</span><span class="selector-pseudo">:POST_NOTIFICATION</span> <span class="selector-tag">object</span><span class="selector-pseudo">:nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是带 block 方式的 remove 便不能像上面这样处理了。其方式如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObservers &#123;</span><br><span class="line">    <span class="keyword">if</span>（_observer）&#123;</span><br><span class="line">        [<span class="meta">[NSNotificationCenter defaultCenter</span>] removeObserver:_observer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 _observer 是 addObserverForName 方式的 api 返回观察者对象。这也就意味着，你需要为每一个观察者记录一个成员对象，然后在 remove 的时候依次删除。试想一下，你如果需要 10 个观察者，则需要记录 10 个成员对象，这个想想就是很麻烦，而且它还不能够方便的指定 observer 。因此，理想的做法就是自己再做一层封装，将这些细节封装起来。</p><p>参考：<a href="http://lifengfengs-macbook-pro.local:63320/Dash/rlftdmxv/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="noopener">Delivering Notifications To Particular Threads</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多线程中，无论在哪个线程注册了观察者，Notification接收和处理都是在发送Notification的线程中的。所以，当我们需要在接收到Notification后作出更新UI操作的话，就需要考虑线程的问题了，
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="多线程" scheme="https://imlifengfeng.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Notification" scheme="https://imlifengfeng.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发大胸器之 PaintCode</title>
    <link href="https://imlifengfeng.github.io/article/602/"/>
    <id>https://imlifengfeng.github.io/article/602/</id>
    <published>2017-03-10T17:00:02.000Z</published>
    <updated>2018-11-27T09:36:20.808Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>首先原谅我为文章起了个污污的标题，今天整理下iOS开发辅助神器PaintCode的使用，虽然标题很污，但是胸的确很大，PaintCode能够让我们像使用Photoshop一样去设计界面，主要用途是可以将矢量图轻松地转换成CoreGraphics代码，减少了图片使用量，做动效也容易很多。先来看下它的界面：</p><p><img src="/images/2017/03/Snip20170310_6.png" alt="Snip20170310_6"></p><p><img src="/images/2017/03/Snip20170310_8.png" alt="Snip20170310_8"></p><p>它可以将我们在Canvas上绘制的图形直接转换成如下类型的代码：</p><p><img src="/images/2017/03/Snip20170310_9.png" alt="Snip20170310_9"></p><p>虽然不能保证其生成的代码百分百是最佳实现方式，但是毫无疑问的是它可以大大提高我们的开发效率，接下来通过一个示例简单介绍下PaintCode的使用。</p><p>二、<strong>PaintCode的使用</strong></p><p>通过PaintCode预设的一些样式（左上角绿色的那些按钮）我们可以很快的绘制出矩形、圆形、文字、五角形等，同时我们一些图形合并、调整顺序等，具体的功能见顶部一栏的功能菜单。在右侧的属性栏我们可以为图形设置圆角、大小、旋转、填充色、描边、阴影等。</p><p>我从网上找到一张炫酷进度条图片：</p><p><img src="/images/2017/03/9b36d04efc9075faf289a5a75be131d9.png" alt="9b36d04efc9075faf289a5a75be131d9"></p><p>接下来我们就用PaintCode去实现上面风格的进度条。</p><p>首先我们在Canvas上绘制进度条的进度槽（进度条背景），点一下左上角的”Rect”，在Canvas画出进度槽，在右侧设置进度槽的圆角、颜色，可以根据自己需求去设置其他更多属性：</p><p><img src="/images/2017/03/Snip20170310_10.png" alt="Snip20170310_10"></p><p>以类似的方法绘制出表示进度的彩色进度条，方法还是类似，不过要在右侧属性栏设置一下阴影等效果，最终效果如下：</p><p><img src="/images/2017/03/Snip20170310_12.png" alt="Snip20170310_12"></p><p>彩色进度条我设置了这些内容：</p><p><img src="/images/2017/03/Snip20170310_13_1.png" alt="Snip20170310_13_1"></p><p>最后在PaintCode最底部一栏可以看到生成的代码：</p><p><img src="/images/2017/03/Snip20170310_14.png" alt="Snip20170310_14"></p><p>我们新建一个iOS工程，在工程中新建一个继承自UIView的PCProgressView文件（<em>我这里PCProgressView中的PC是PaintCode的简写，别误以为是PC个人电脑的PC了</em>），将PaintCode为我们生成的代码拷贝到PCProgressView的drawRect:方法中，可以发现绘制的图形的frame都是固定值（为了理解方便就直接截图了）：</p><p><img src="/images/2017/03/Snip20170311_15.png" alt="Snip20170311_15"></p><p>所以我们需要根据实际情况修改frame，首先我们PCProgressView.h文件中公开一个属性用来动态设置进度：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PCProgressView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> progress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>重写该属性的setter方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setProgress:(<span class="built_in">CGFloat</span>)progress&#123;</span><br><span class="line">    </span><br><span class="line">    _progress = progress;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置根据实际情况修改绘制图形的frame：</p><p><img src="/images/2017/03/Snip20170311_17.png" alt="Snip20170311_17"></p><p>然后我们将其添加到ViewController的View之中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CGFloat progressX = <span class="number">20</span><span class="comment">;</span></span><br><span class="line">    CGFloat progressY = <span class="number">100</span><span class="comment">;</span></span><br><span class="line">    CGFloat progressW = [UIScreen mainScreen].<span class="keyword">bounds.size.width </span>- <span class="number">2</span> * progressX<span class="comment">;</span></span><br><span class="line">    CGFloat progressH = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    PCProgressView *pcProgress = [[PCProgressView alloc]initWithFrame:CGRectMake(progressX, progressY, progressW, progressH)]<span class="comment">;</span></span><br><span class="line">    pcProgress.<span class="keyword">backgroundColor </span>= [UIColor whiteColor]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    pcProgress.progress = <span class="number">0</span>.<span class="number">5</span>f<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    [self.view <span class="keyword">addSubview:pcProgress];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/03/Snip20170311_20.png" alt="Snip20170311_20"></p><p>接下来我们让进度条改变进度看下效果，ViewController中代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  PaintCodeTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/10.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"PCProgressView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)PCProgressView *pcProgress;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIButton</span> *btn;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将我们自定义的进度条PCProgressView添加到ViewController中</span></span><br><span class="line">    <span class="built_in">CGFloat</span> progressX = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> progressY = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> progressW = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - <span class="number">2</span> * progressX;</span><br><span class="line">    <span class="built_in">CGFloat</span> progressH = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.pcProgress = [[PCProgressView alloc]initWithFrame:<span class="built_in">CGRectMake</span>(progressX, progressY, progressW, progressH)];</span><br><span class="line">    <span class="keyword">self</span>.pcProgress.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="keyword">self</span>.pcProgress.progress = <span class="number">0</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.pcProgress];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一个Button</span></span><br><span class="line">    <span class="built_in">CGFloat</span> btnW = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> btnH = <span class="number">40</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> btnX = ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - btnW)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> btnY = progressY + <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.btn = [[<span class="built_in">UIButton</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(btnX, btnY, btnW, btnH)];</span><br><span class="line">    [<span class="keyword">self</span>.btn setTitle:<span class="string">@"Start"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [<span class="keyword">self</span>.btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.btn];</span><br><span class="line">    <span class="keyword">self</span>.btn.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//btn按钮点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)btnClick&#123;</span><br><span class="line">    <span class="keyword">self</span>.btn.enabled = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.pcProgress.progress = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">0.1</span></span><br><span class="line">                                         target:<span class="keyword">self</span></span><br><span class="line">                                       selector:<span class="keyword">@selector</span>(updateProgressView)</span><br><span class="line">                                       userInfo:<span class="literal">nil</span></span><br><span class="line">                                        repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.timer fire];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新进度</span></span><br><span class="line">-(<span class="keyword">void</span>)updateProgressView &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pcProgress.progress &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pcProgress.progress += <span class="number">0.01</span>f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">        <span class="keyword">self</span>.btn.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/2017/03/2017-03-11-00.48.52.gif" alt="2017-03-11 00.48.52"></p><p>以上就是PaintCode的简单用法，其实PaintCode使用是非常简单的，上面我也没有把每步操作都截图出来，或许看完这篇文章你再打开PaintCode就瞬间明白PaintCode的用法了。合理使用PaintCode可以大大提高我们的开发效率，可以节约更多时间去用在核心功能上。后面我还会整理其他几个iOS开发“胸器”的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先原谅我为文章起了个污污的标题，今天整理下iOS开发辅助神器PaintCode的使用，虽然标题很污，但是胸的确很大，PaintCode能够让我们像使用Photoshop一样去设计界面，主要用途是可以将矢量图轻松地转
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="PaintCode" scheme="https://imlifengfeng.github.io/tags/PaintCode/"/>
    
  </entry>
  
  <entry>
    <title>iOS 触摸事件</title>
    <link href="https://imlifengfeng.github.io/article/598/"/>
    <id>https://imlifengfeng.github.io/article/598/</id>
    <published>2017-03-09T14:04:34.000Z</published>
    <updated>2018-11-27T09:36:20.658Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在APP的开发过程中，可能需要利用手势操作去实现一些功能或者效果。UIKit框架提供了检测常见手势的预定义手势识别器。 在手势开发上，最好尽可能使用预定义的手势识别器，因为它们的简单性减少了我们的的代码量。当然，我们也可以自定义一些特殊的手势，具体的可以查看官方文档学习：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW44" target="_blank" rel="noopener">Creating a Custom Gesture Recognizer</a>。iOS中的事件可以分为3大类型：触摸事件、加速计事件、远程控制事件，如下图：</p><p><img src="/images/2017/03/events_to_app_2x.png" alt="events_to_app_2x"></p><p>二、<strong>UIResponder</strong></p><p>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“<strong>响应者对象</strong>”，UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件。</p><p>继承了UIResponder就可以处理事件。UIResponder内部提供了以下方法来处理事件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸事件：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加速计事件：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">motionBegan:</span>(UIEventSubtype)motion <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">motionEnded:</span>(UIEventSubtype)motion <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">motionCancelled:</span>(UIEventSubtype)motion <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//远程控制事件：</span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">remoteControlReceivedWithEvent:</span>(UIEvent *)event;</span><br></pre></td></tr></table></figure><p>UIView的触摸事件处理:</p><p>UIView是UIResponder的子类，可以重写下列4个方法处理不同的触摸事件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一根或者多根手指开始触摸view，系统会自动调用view的下面方法：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一根或者多根手指离开view，系统会自动调用view的下面方法：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br></pre></td></tr></table></figure><p>例如，使UIView随手指移动：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前触摸点，设置以自己为参照，坐标原点为自己（self）的左上角</span></span><br><span class="line">    <span class="built_in">CGPoint</span> current = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 上一个触摸点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> previous = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改当前view的位置(中点)</span></span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span>.center;</span><br><span class="line">    center.x += current.x - previous.x;</span><br><span class="line">    center.y += current.y - previous.y;</span><br><span class="line">    <span class="keyword">self</span>.center = center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三：<strong>UITouch</strong></p><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象，一根手指对应一个UITouch对象。</p><p>UITouch保存着跟手指相关的信息，比如触摸的位置、时间、阶段：</p><p>（1）当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置。</p><p>（2）当手指离开屏幕时，系统会销毁相应的UITouch对象。</p><p>UITouch的属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸产生时所处的窗口：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIWindow</span>    *window;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸产生时所处的视图：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span>    *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span>    tapCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录了触摸事件产生或变化时的时间，单位是秒：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>    timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前触摸事件所处的状态：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span>    phase;</span><br></pre></td></tr></table></figure><p>UITouchPhase是一个枚举类型，包含：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITouchPhaseBegan</span>（触摸开始）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseMoved</span>（接触点移动）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseStationary</span>（接触点无移动）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseEnded</span>（触摸结束）</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITouchPhaseCancelled</span>（触摸取消）</span><br></pre></td></tr></table></figure><p>UITouch的方法:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (CGPoint)<span class="selector-tag">locationInView</span><span class="selector-pseudo">:(UIView</span> *)<span class="selector-tag">view</span>;  <span class="comment">//返回值表示触摸在view上的位置，这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)），调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (CGPoint)<span class="selector-tag">previousLocationInView</span><span class="selector-pseudo">:(UIView</span> *)<span class="selector-tag">view</span>;  <span class="comment">//该方法记录了前一个触摸点的位置</span></span><br></pre></td></tr></table></figure><p>四、<strong>UIEvent</strong></p><p>每产生一个事件，就会产生一个UIEvent对象，称为事件对象，记录事件产生的时刻和类型。</p><p>常见属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件类型：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventType</span>    type;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventSubtype</span>    subtype;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件产生的时间：</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>    timestamp;</span><br></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventType</span>) &#123;</span><br><span class="line">    <span class="type">UIEventTypeTouches</span>,</span><br><span class="line">    <span class="type">UIEventTypeMotion</span>,</span><br><span class="line">    <span class="type">UIEventTypeRemoteControl</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventSubtype</span>) &#123;</span><br><span class="line">    // available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeNone</span>                              = 0,</span><br><span class="line">    </span><br><span class="line">    // for <span class="type">UIEventTypeMotion</span>, available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeMotionShake</span>                       = 1,</span><br><span class="line">    </span><br><span class="line">    // for <span class="type">UIEventTypeRemoteControl</span>, available in iOS 4.0</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPlay</span>                 = 100,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPause</span>                = 101,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlStop</span>                 = 102,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlTogglePlayPause</span>      = 103,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlNextTrack</span>            = 104,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPreviousTrack</span>        = 105,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = 106,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = 107,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = 108,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingForward</span>    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次完整的触摸过程，会经历3个状态：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸开始：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸移动：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸结束：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸取消（可能会经历）：</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br></pre></td></tr></table></figure><p>4个触摸事件处理方法中，都有NSSet <em>touches和UIEvent </em>event两个参数：</p><p>（1）一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数</p><p>（2）如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p><p>（3）如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象</p><p>（4）根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸</p><p>五、<strong>事件的产生和传递</strong></p><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理。通常，先发送事件给应用程序的主窗口（keyWindow），主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，也就是说keyWindow最先收到触摸事件。这也是整个事件处理过程的第一步，找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理：</p><p><em>touchesBegan…</em></p><p><em>touchesMoved…</em></p><p><em>touchedEnded…</em></p><p>这些touches方法的默认做法是将事件顺着响应者链条（后面会讲解）<strong>向上</strong>传递，将事件交给上一个响应者进行处理。</p><p>事件传递示例：</p><p><img src="/images/2017/03/图片-1.png" alt="图片 1"></p><p>触摸事件的传递是从父控件传递到子控件：</p><p>（1）点击了绿色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 绿色</p><p>（2）点击了蓝色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色</p><p>（3）点击了黄色的view：</p><p>UIApplication -&gt; UIWindow -&gt; 白色 -&gt; 橙色 -&gt; 蓝色 -&gt; 黄色</p><p>注意：<strong>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件</strong></p><p>UIView不接收触摸事件的三种情况：</p><p>（1）不接收用户交互</p><p>userInteractionEnabled = NO</p><p>（2）隐藏</p><p>hidden = YES</p><p>（3）透明</p><p>alpha = 0.0 ~ 0.01</p><p>UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。</p><p>六、<strong>响应者链条</strong></p><p>响应者链条示意图：</p><p><img src="/images/2017/03/iOS_responder_chain_2x.png" alt="iOS_responder_chain_2x"></p><p>响应者链的事件传递过程：</p><p>（1）如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图。</p><p>（2）在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。</p><p>（3）如果window对象也不处理，则其将事件或消息传递给UIApplication对象。</p><p>（4）如果UIApplication也不能处理该事件或消息，则将其丢弃。</p><p>触摸事件完整处理过程：</p><p>（1）先将事件对象由上往下传递（由父控件传递给子控件），找到最合适的控件来处理事件。</p><p>（2）调用最合适控件的touches…方法。</p><p>（3）如果这个控件调用了[super touches…];就会将事件顺着相应链条往下传递，传递给上一个响应者。</p><p>（4）接着就会调用上一个响应者的touches…方法。</p><p>（5）事件还可以继续往上传递，直到UIApplication，如果UIApplication也不处理该事件或消息，则将其丢弃。</p><p>上一个响应者：</p><p>如果当前这个View是控制器的View，那么控制器就是上一个响应者。</p><p>如果当前这个View不是控制器的View，那么父控件就是上一个响应者。</p><p>对上面进行总结：</p><p>发生触摸事件后，keyWindow最先拿到事件，keyWindow会在视图层次结构中找到一个最合适的视图来处理触摸事件。假设这个最合适的视图为myView，myView处理这个事件的方式为将该事件传递给自己的父View，如果父View不处理则继续往上传递，直到UIApplication。如果连UIApplication也不处理则丢弃该事件。</p><p>七、<strong>UIGestureRecognizer</strong></p><p>为了完成手势识别，必须借助于手势识别器——UIGestureRecognizer，利用UIGestureRecognizer，能轻松识别用户在某个view上面做的一些常见手势，UIGestureRecognizer是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//敲击</span></span><br><span class="line"><span class="built_in">UITapGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//捏合，可用于缩放</span></span><br><span class="line"><span class="built_in">UIPinchGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拖拽</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//轻扫</span></span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转</span></span><br><span class="line"><span class="built_in">UIRotationGestureRecognizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//长按</span></span><br><span class="line"><span class="built_in">UILongPressGestureRecognizer</span></span><br></pre></td></tr></table></figure><p>手势识别器的用法：</p><p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建手势识别器对象</span></span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置手势识别器对象的具体属性</span></span><br><span class="line"><span class="comment">// 连续敲击2次</span></span><br><span class="line">tap.numberOfTapsRequired = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 需要2根手指一起敲击</span></span><br><span class="line">tap.numberOfTouchesRequired = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加手势识别器到对应的view上</span></span><br><span class="line">[self.iconView <span class="string">addGestureRecognizer:</span>tap];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听手势的触发</span></span><br><span class="line">[tap <span class="string">addTarget:</span>self <span class="string">action:</span><span class="meta">@selector</span>(<span class="string">tapIconView:</span>)];</span><br></pre></td></tr></table></figure><p>手势识别的状态：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIGestureRecognizerState</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有触摸事件发生，所有手势识别的默认状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStatePossible</span>,</span><br><span class="line">    <span class="comment">// 一个手势已经开始但尚未改变或者完成时</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateBegan</span>,</span><br><span class="line">    <span class="comment">// 手势状态改变</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateChanged</span>,</span><br><span class="line">    <span class="comment">// 手势完成</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateEnded</span>,</span><br><span class="line">    <span class="comment">// 手势取消，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateCancelled</span>,</span><br><span class="line">    <span class="comment">// 手势失败，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateFailed</span>,</span><br><span class="line">    <span class="comment">// 识别到手势识别</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateRecognized</span> = <span class="built_in">UIGestureRecognizerStateEnded</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如：</p><p>添加长按手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILongPressGestureRecognizer</span> *longP = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longP:)];</span><br><span class="line">[<span class="keyword">self</span>.imageV addGestureRecognizer:longP];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当长按时调用这个方法会调用很多次,</span></span><br><span class="line"><span class="comment">// 当手指长按在上面不松,来回移动时,会持续调用,所以要判断它的状态.</span></span><br><span class="line">- (<span class="keyword">void</span>)longP:(<span class="built_in">UILongPressGestureRecognizer</span> *)longP&#123;</span><br><span class="line">    <span class="keyword">if</span>(longP.state == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始长按"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(longP.state == <span class="built_in">UIGestureRecognizerStateChanged</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"长按时手指移动"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(longP.state == <span class="built_in">UIGestureRecognizerStateEnded</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"手指离开屏幕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加轻扫手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加轻扫手势1</span></span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span> *swipe = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(swipe:)];</span><br><span class="line"><span class="comment">// 轻扫手势默认是向右边称轻扫,可以设置轻扫的方法.</span></span><br><span class="line"><span class="comment">// 一个轻扫手势只能设置一个方法的轻扫.想要让它有多个方向的手势,必须得要设置的</span></span><br><span class="line">  swipe.direction =  <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">  [<span class="keyword">self</span>.imageV addGestureRecognizer:swipe];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加轻扫手势2</span></span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span> *swipe2 = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(swipe:)];</span><br><span class="line">swipe2.direction =  <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>; [<span class="keyword">self</span>.imageV addGestureRecognizer:swipe2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轻扫手势的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)swipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)swipe&#123;</span><br><span class="line">    <span class="comment">// 判断的轻扫的方向</span></span><br><span class="line">    <span class="keyword">if</span> (swipe.direction == <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"向左轻扫"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(swipe.direction == <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"向上轻扫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加拖动手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加拖动手势</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br><span class="line">[<span class="keyword">self</span>.imageV addGestureRecognizer:pan];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指拖动时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan&#123;</span><br><span class="line">    <span class="comment">// 拖动手势也有状态</span></span><br><span class="line">    <span class="keyword">if</span>(pan.state == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</span><br><span class="line">        <span class="comment">//  开始拖动</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan.state == <span class="built_in">UIGestureRecognizerStateChanged</span>)&#123;</span><br><span class="line">     <span class="comment">//   获取当前手指移动的距离，是相对于最原始的点</span></span><br><span class="line">        <span class="built_in">CGPoint</span> transP = [pan translationInView:<span class="keyword">self</span>.imageV];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    清空上一次的形变</span></span><br><span class="line">        <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(transP.x,transP.y);</span><br><span class="line">        <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span>.imageV.transform, transP.x, transP.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    复位,让它相对于上一次.</span></span><br><span class="line">        [pan setTranslation:<span class="built_in">CGPointZero</span> inView:<span class="keyword">self</span>.imageV];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan.state == <span class="built_in">UIGestureRecognizerStateEnded</span>)&#123;</span><br><span class="line">     <span class="comment">//   结束拖动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加捏合手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加捏合手势</span></span><br><span class="line"><span class="built_in">UIPinchGestureRecognizer</span> *pinGes = [[<span class="built_in">UIPinchGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pinGes:)];</span><br><span class="line"><span class="comment">// 设置代理使其能够同时支持多个手势</span></span><br><span class="line">pinGes.delegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.imageV addGestureRecognizer:pinGes];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捏合时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)pinGes:(<span class="built_in">UIPinchGestureRecognizer</span> *)pin&#123;</span><br><span class="line">    <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformScale</span>(<span class="keyword">self</span>.imageV.transform, pin.scale, pin.scale);</span><br><span class="line">    <span class="comment">// 复位</span></span><br><span class="line">    [pin setScale:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加旋转手势：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加旋转手势</span></span><br><span class="line"> <span class="built_in">UIRotationGestureRecognizer</span> *rotation = [[<span class="built_in">UIRotationGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(rotation:)];</span><br><span class="line"> <span class="comment">// 设置代理使其能够同时支持多个手势</span></span><br><span class="line"> rotation.delegate = <span class="keyword">self</span>;</span><br><span class="line"> [<span class="keyword">self</span>.imageV addGestureRecognizer:rotation];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指开始旋转时调用.</span></span><br><span class="line">- (<span class="keyword">void</span>)rotation:(<span class="built_in">UIRotationGestureRecognizer</span> *)rotation&#123;</span><br><span class="line">    <span class="keyword">self</span>.imageV.transform = <span class="built_in">CGAffineTransformRotate</span>(<span class="keyword">self</span>.imageV.transform, rotation.rotation);</span><br><span class="line">    <span class="comment">// 复位.</span></span><br><span class="line">    [rotation setRotation:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW44" target="_blank" rel="noopener">Creating a Custom Gesture Recognizer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在APP的开发过程中，可能需要利用手势操作去实现一些功能或者效果。UIKit框架提供了检测常见手势的预定义手势识别器。 在手势开发上，最好尽可能使用预定义的手势识别器，因为它们的简单性减少了我们的的代码量。当然，我们
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="手势" scheme="https://imlifengfeng.github.io/tags/%E6%89%8B%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>iOS的离屏渲染</title>
    <link href="https://imlifengfeng.github.io/article/593/"/>
    <id>https://imlifengfeng.github.io/article/593/</id>
    <published>2017-03-07T16:49:41.000Z</published>
    <updated>2018-11-27T09:36:20.504Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>OpenGL ES是一套多功能开放标准的用于嵌入系统的C-based的图形库，用于2D和3D数据的可视化。OpenGL被设计用来转换一组图形调用功能到底层图形硬件（GPU），由GPU执行图形命令，用来实现复杂的图形操作和运算，从而能够高性能、高帧率利用GPU提供的2D和3D绘制能力。iOS系统默认支持OpenGl ES1.0、ES2.0以及ES3.0 3个版本，三者之间并不是简单的版本升级，设计理念甚至完全不同。GPU屏幕渲染方式中有一种方式为离屏渲染，处理不好离屏渲染往往会对APP的性能产生较大的影响。</p><p>二、<strong>当前屏幕渲染与离屏渲染</strong></p><p>OpenGL中，GPU屏幕渲染有两种方式:</p><p>（1）On-Screen Rendering (当前屏幕渲染) </p><p>指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。</p><p>（2）Off-Screen Rendering (离屏渲染)</p><p>指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。</p><p>当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。但是受当前屏幕渲染的局限因素限制(只有自身上下文、屏幕缓存有限等)，当前屏幕渲染有些情况下的渲染解决不了的，就使用到离屏渲染。</p><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p><p>（1）创建新缓冲区</p><p>要想进行离屏渲染，首先要创建一个新的缓冲区。</p><p>（2）上下文切换</p><p>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen），等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p><p>特殊的“离屏渲染”：CPU渲染</p><p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap(位图)最后再交由GPU用于显示。</p><p><a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance" target="_blank" rel="noopener">Designing for iOS: Graphics &amp; Performance</a> 这篇文章也提到了使用 Core Graphics API 会触发离屏渲染。 苹果 iOS 4.1-8 时期的 UIKit 组成员Andy Matuschak也曾对这个说法进行解释：「Core Graphics 的绘制 API 的确会触发离屏渲染，但不是那种 GPU 的离屏渲染。使用 Core Graphics 绘制 API 是在 CPU 上执行，触发的是 CPU 版本的离屏渲染。」</p><p>三、<strong>为什么要有离屏渲染</strong></p><p>大家高中物理应该学过显示器是如何显示图像的：需要显示的图像经过CRT电子枪以极快的速度一行一行的扫描，扫描出来就呈现了一帧画面，随后电子枪又会回到初始位置循环扫描，形成了我们看到的图片或视频。<br>为了让显示器的显示跟视频控制器同步，当电子枪新扫描一行的时候，准备扫描的时发送一个水平同步信号(HSync信号)，显示器的刷新频率就是HSync信号产生的频率。然后CPU计算好frame等属性，将计算好的内容交给GPU去渲染，GPU渲染好之后就会放入帧缓冲区。然后视频控制器会按照HSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器，就显示出来了。具体的大家自行查找资料或询问相关专业人士，这里只参考网上资料做一个简单的描述。<br>离屏渲染的代价很高，想要进行离屏渲染，首选要创建一个新的缓冲区，屏幕渲染会有一个上下文环境的一个概念，离屏渲染的整个过程需要切换上下文环境，先从当前屏幕切换到离屏，等结束后，又要将上下文环境切换回来。这也是为什么会消耗性能的原因了。<br>由于垂直同步的机制，如果在一个 HSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><p>既然离屏渲染这么耗性能,为什么有这套机制呢?</p><p>有些效果被认为不能直接呈现于屏幕，而需要在别的地方做额外的处理预合成。图层属性的混合体没有预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p><p>下面的情况或操作会引发离屏渲染：</p><ul><li>为图层设置遮罩（layer.mask）</li></ul><ul><li>将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</li></ul><ul><li>将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</li></ul><ul><li>为图层设置阴影（layer.shadow *）。</li></ul><ul><li>为图层设置layer.shouldRasterize=true</li></ul><ul><li>具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层</li></ul><ul><li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）。</li></ul><ul><li>使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。</li></ul><p>四、<strong>优化方案</strong></p><p>官方对离屏渲染产生性能问题也进行了优化：</p><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染。</p><p>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p><p>1、圆角优化</p><p>在APP开发中，圆角图片还是经常出现的。如果一个界面中只有少量圆角图片或许对性能没有非常大的影响，但是当圆角图片比较多的时候就会APP性能产生明显的影响。</p><p>我们设置圆角一般通过如下方式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageView.layer.cornerRadius = CGFloat(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">imageView.layer.masksToBounds = YES<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样处理的渲染机制是GPU在当前屏幕缓冲区外新开辟一个渲染缓冲区进行工作，也就是离屏渲染，这会给我们带来额外的性能损耗，如果这样的圆角操作达到一定数量，会触发缓冲区的频繁合并和上下文的的频繁切换，性能的代价会宏观地表现在用户体验上——掉帧。</p><p>优化方案1：使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)]; </span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImg"</span>]; </span><br><span class="line"><span class="comment">//开始对imageView进行画图 </span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageView.bounds.size, <span class="literal">NO</span>, <span class="number">1.0</span>); </span><br><span class="line"><span class="comment">//使用贝塞尔曲线画出一个圆形图 </span></span><br><span class="line">[[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];</span><br><span class="line">[imageView drawRect:imageView.bounds];</span><br><span class="line">imageView.image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line"><span class="comment">//结束画图 </span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br></pre></td></tr></table></figure><p>优化方案2：使用CAShapeLayer和UIBezierPath设置圆角</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)]; </span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImg"</span>]; </span><br><span class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:<span class="built_in">UIRectCornerAllCorners</span> cornerRadii:imageView.bounds.size];</span><br><span class="line"><span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc]init]; </span><br><span class="line"><span class="comment">//设置大小 </span></span><br><span class="line">maskLayer.frame = imageView.bounds; </span><br><span class="line"><span class="comment">//设置图形样子 </span></span><br><span class="line">maskLayer.path = maskPath.CGPath;</span><br><span class="line">imageView.layer.mask = maskLayer; </span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br></pre></td></tr></table></figure><p>对于方案2需要解释的是：</p><ul><li>CAShapeLayer继承于CALayer,可以使用CALayer的所有属性值；</li></ul><ul><li>CAShapeLayer需要贝塞尔曲线配合使用才有意义（也就是说才有效果）</li></ul><ul><li>使用CAShapeLayer(属于CoreAnimation)与贝塞尔曲线可以实现不在view的drawRect（继承于CoreGraphics走的是CPU,消耗的性能较大）方法中画出一些想要的图形</li></ul><ul><li>CAShapeLayer动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言，其效率极高，能大大优化内存使用情况。</li></ul><p>总的来说就是用CAShapeLayer的内存消耗少，渲染速度快，建议使用优化方案2。</p><p>2、shadow优化</p><p>对于shadow，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置shadowPath来优化性能，能大幅提高性能。示例如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imageView.layer.<span class="keyword">shadowColor </span>= [UIColor grayColor].CGColor<span class="comment">;</span></span><br><span class="line">imageView.layer.<span class="keyword">shadowOpacity </span>= <span class="number">1</span>.<span class="number">0</span><span class="comment">;</span></span><br><span class="line">imageView.layer.<span class="keyword">shadowRadius </span>= <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span></span><br><span class="line">UIBezierPath *path = [UIBezierPath <span class="keyword">bezierPathWithRect:imageView.frame];</span></span><br><span class="line"><span class="keyword">imageView.layer.shadowPath </span>= path.CGPath<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>我们还可以通过设置shouldRasterize属性值为YES来强制开启离屏渲染。其实就是光栅化（Rasterization）。既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于UITableViewCell中，cell的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是2.5个屏幕尺寸。在100ms之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。</p><p>3、其他的一些优化建议</p><ul><li>当我们需要圆角效果时，可以使用一张中间透明图片蒙上去</li></ul><ul><li>使用ShadowPath指定layer阴影效果路径</li></ul><ul><li>使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit）</li></ul><ul><li>设置layer的opaque值为YES，减少复杂图层合成</li></ul><ul><li>尽量使用不包含透明（alpha）通道的图片资源</li></ul><ul><li>尽量设置layer的大小值为整形值</li></ul><ul><li>直接让美工把图片切成圆角进行显示，这是效率最高的一种方案</li></ul><ul><li>很多情况下用户上传图片进行显示，可以让服务端处理圆角</li></ul><ul><li>使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片</li></ul><p>五、<strong>Core Animation工具检测离屏渲染</strong></p><p>对于离屏渲染的检测，苹果为我们提供了一个测试工具Core Animation。可以在Xcode-&gt;Open Develeper Tools-&gt;Instruments中找到，如下图：</p><p><img src="/images/2017/03/201703080040.png" alt="201703080040"></p><p>Core Animation工具用来监测Core Animation性能，提供可见的FPS值，并且提供几个选项来测量渲染性能。如下图：</p><p><img src="/images/2017/03/201703080041.png" alt="201703080041"></p><p>下面我们来说明每个选项的功能：<br>Color Blended Layers：这个选项如果勾选，你能看到哪个layer是透明的，GPU正在做混合计算。显示红色的就是透明的，绿色就是不透明的。</p><p>Color Hits Green and Misses Red：如果勾选这个选项，且当我们代码中有设置shouldRasterize为YES，那么红色代表没有复用离屏渲染的缓存，绿色则表示复用了缓存。我们当然希望能够复用。</p><p>Color Copied Images：按照官方的说法，当图片的颜色格式GPU不支持的时候，Core Animation会<br>拷贝一份数据让CPU进行转化。例如从网络上下载了TIFF格式的图片，则需要CPU进行转化，这个区域会显示成蓝色。还有一种情况会触发Core Animation的copy方法，就是字节不对齐的时候。如下图：</p><p><img src="/images/2017/03/201703080043.png" alt="201703080043"></p><p>Color Immediately：默认情况下Core Animation工具以每毫秒10次的频率更新图层调试颜色，如果勾选这个选项则移除10ms的延迟。对某些情况需要这样，但是有可能影响正常帧数的测试。</p><p>Color Misaligned Images：勾选此项，如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。像素对齐我们已经在上面有所介绍。</p><p>Color Offscreen-Rendered Yellow：用来检测离屏渲染的，如果显示黄色，表示有离屏渲染。当然还要结合Color Hits Green and Misses Red来看，是否复用了缓存。</p><p>Color OpenGL Fast Path Blue：这个选项对那些使用OpenGL的图层才有用，像是GLKView或者 CAEAGLLayer，如果不显示蓝色则表示使用了CPU渲染，绘制在了屏幕外，显示蓝色表示正常。</p><p>Flash Updated Regions：当对图层重绘的时候回显示黄色，如果频繁发生则会影响性能。可以用增加缓存来增强性能。</p><p>具体的使用截图就不发出来了，大家自己可以试试。</p><p>参考：<a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/WorkingwithEAGLContexts/WorkingwithEAGLContexts.html" target="_blank" rel="noopener">Drawing to Other Rendering Destinations</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OpenGL ES是一套多功能开放标准的用于嵌入系统的C-based的图形库，用于2D和3D数据的可视化。OpenGL被设计用来转换一组图形调用功能到底层图形硬件（GPU），由GPU执行图形命令，用来实现复杂的图形操
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="离屏渲染" scheme="https://imlifengfeng.github.io/tags/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS XCTest单元测试</title>
    <link href="https://imlifengfeng.github.io/article/588/"/>
    <id>https://imlifengfeng.github.io/article/588/</id>
    <published>2017-03-06T08:56:14.000Z</published>
    <updated>2018-11-27T09:36:20.375Z</updated>
    
    <content type="html"><![CDATA[<p>一、<strong>概述</strong></p><p>在Xcode中新建项目的时候会默认勾选单元测试，勾选后每个XCode新建的iOS的项目中都有一个叫做”项目名Tests”的分组，这个分组里就是XCTestCase的子类，XCTest中的测试类都是继承自XCTestCase。当我们为项目增加了新的功能时，可以使用单元测试针对该模块进行测试。</p><p>二、<strong>单元测试的使用</strong></p><p>1、常规测试</p><p>首先新建一个名为“MyDemo”的项目，我们会看到会自动生成如下的文件：</p><p><img src="/images/2017/03/Snip20170306_5.png" alt="Snip20170306_5"></p><p>MyDemoTests中代码为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">    [<span class="keyword">super</span> tearDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a functional test case.</span></span><br><span class="line">    <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">        <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面最重要的两个方法为setUp和tearDown，setUp方法在XCTestCase的测试方法调用之前调用。当测试全部结束之后调用tearDown方法。上面的另外两个方法是系统自动创建的功能测试用例的示例。我们可以自己创建测试方法，不过测试方法必须testXXX的格式，且不能有参数，不然不会识别为测试方法。</p><p>setUp方法可以在测试之前创建在test case方法中需要用到的一些对象等。tearDown方法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等。</p><p>例如，我们去除系统系统创建的两个测试用例的示例，我们自己创建一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyDemoTests.m</span></span><br><span class="line"><span class="comment">//  MyDemoTests</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/6.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setUp-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    [<span class="keyword">super</span> tearDown];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tearDown-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyFun&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMyFun-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>按快捷键Command + U进行单元测试，打印结果（去除了其他暂不关注的打印）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-06</span> 15<span class="selector-pseudo">:35</span><span class="selector-pseudo">:35.336</span> <span class="selector-tag">MyDemo</span><span class="selector-attr">[48088:5078800]</span> <span class="selector-tag">setUp-----------------</span></span><br><span class="line">2017<span class="selector-tag">-03-06</span> 15<span class="selector-pseudo">:35</span><span class="selector-pseudo">:35.336</span> <span class="selector-tag">MyDemo</span><span class="selector-attr">[48088:5078800]</span> <span class="selector-tag">testMyFun-----------------</span></span><br><span class="line">2017<span class="selector-tag">-03-06</span> 15<span class="selector-pseudo">:35</span><span class="selector-pseudo">:35.337</span> <span class="selector-tag">MyDemo</span><span class="selector-attr">[48088:5078800]</span> <span class="selector-tag">tearDown-----------------</span></span><br></pre></td></tr></table></figure><p>接下来我们新建一个类MyClass，在MyClass中声明和实现一个getNum的方法，方法实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(NSInteger)getNum&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们MyDemoTests的testMyFun写相关单元测试代码（代码中用到了断言，断言的使用后面再讲）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyDemoTests.m</span></span><br><span class="line"><span class="comment">//  MyDemoTests</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 李峰峰 on 2017/3/6.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 李峰峰. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setUp-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    [<span class="keyword">super</span> tearDown];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tearDown-----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMyFun&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testMyFun-----------------"</span>);</span><br><span class="line">    </span><br><span class="line">    MyClass *myClass = [[MyClass alloc]init];</span><br><span class="line">    <span class="built_in">NSInteger</span> num = [myClass getNum];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssert</span>(num &lt; <span class="number">10</span>,<span class="string">@"num should less than 10"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面加了断言，只有当num&lt;10的使用才能通过测试，由于此时num=5，所以可以顺利通过测试。</p><p>按快捷键Command + U进行单元测试，结果如下：</p><p><img src="/images/2017/03/Snip20170306_6.png" alt="Snip20170306_6"></p><p>如果我们将getNum的返回结果改为15，则不会通过测试：</p><p><img src="/images/2017/03/Snip20170306_7.png" alt="Snip20170306_7"></p><p>如果测试方法比较多的时候也可以直接点击方法后运行的图标单独测试某个方法，Command + U是全部测试：</p><p><img src="/images/2017/03/Snip20170306_8.png" alt="Snip20170306_8"></p><p>2、性能测试</p><p>刚开始的时候系统为我们创建的一个测试用例方法里有这么个方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    [self <span class="string">measureBlock:</span>^&#123;</span><br><span class="line">        <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释可以看到我们可以将需要测试执行时间的代码放在该方法的Block中，测试时Block中的代码会运行10次并打印出每次运行的时间。例如，我们将getNum的代码改成如下代码：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(NSInteger)getNum&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">time</span> = arc4random_uniform(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">sleep</span>(<span class="keyword">time</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">testPerformanceExample</span> &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"testPerformanceExample-----------------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="selector-attr">[self measureBlock:^&#123;</span></span><br><span class="line"><span class="selector-attr"></span></span><br><span class="line"><span class="selector-attr">        MyClass *myClass = [[MyClass alloc]</span><span class="selector-tag">init</span>];</span><br><span class="line">        <span class="selector-attr">[myClass getNum]</span>;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按快捷键Command + U进行单元测试，结果如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-03-06</span> <span class="number">16</span>:<span class="number">42:01.403</span> MyDemo[<span class="number">51107</span>:<span class="number">5178923</span>] setUp-----------------</span><br><span class="line"><span class="number">2017-03-06</span> <span class="number">16</span>:<span class="number">42:01.404</span> MyDemo[<span class="number">51107</span>:<span class="number">5178923</span>] testPerformanceExample-----------------</span><br><span class="line">/Users/lifengfeng/Desktop/Project/iOSProject/MyDemo/MyDemoTests/MyDemoTests.m:<span class="number">31</span>: Test Case '-[MyDemoTests testPerformanceExample]' measured [Time, seconds] average: <span class="number">0</span>.<span class="number">422</span>, relative standard deviation: <span class="number">164.533</span>%, values: [<span class="number">0.000053</span>, <span class="number">2.073384</span>, <span class="number">0.000010</span>, <span class="number">1.073334</span>, <span class="number">0.000013</span>, <span class="number">1.074108</span>, <span class="number">0.000016</span>, <span class="number">0.000005</span>, <span class="number">0.000004</span>, <span class="number">0.000003</span>], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: "", baselineAverage: , maxPercentRegression: <span class="number">10</span>.<span class="number">000</span>%, maxPercentRelativeStandardDeviation: <span class="number">10</span>.<span class="number">000</span>%, maxRegression: <span class="number">0</span>.<span class="number">100</span>, maxStandardDeviation: <span class="number">0</span>.<span class="number">100</span></span><br><span class="line"><span class="number">2017-03-06</span> <span class="number">16</span>:<span class="number">42:06.080</span> MyDemo[<span class="number">51107</span>:<span class="number">5178923</span>] tearDown-----------------</span><br></pre></td></tr></table></figure><p>从上面可以看到10次中每次执行所花费的时间，从上面我们可以了解到我们代码的性能。</p><p>三、<strong>常用的测试断言</strong></p><ul><li>XCTFail(format…) 生成一个失败的测试;</li></ul><ul><li>XCTFail(@”Fail”);</li></ul><ul><li>XCTAssertNil(a1, format…) 为空判断， a1 为空时通过，反之不通过;</li></ul><ul><li>XCTAssertNil(@”not nil string”, @”string must be nil”);</li></ul><ul><li>XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；</li></ul><ul><li>XCTAssertNotNil(@”not nil string”, @”string can not be nil”);</li></ul><ul><li>XCTAssert(expression, format…) 当expression求值为TRUE时通过；</li></ul><ul><li>XCTAssert((2 &gt; 2), @”expression must be true”);</li></ul><ul><li>XCTAssertTrue(expression, format…) 当expression求值为TRUE时通过；</li></ul><ul><li>XCTAssertTrue(1, @”Can not be zero”);</li></ul><ul><li>XCTAssertFalse(expression, format…) 当expression求值为False时通过；</li></ul><ul><li>XCTAssertFalse((2 &lt; 2), @”expression must be false”);</li></ul><ul><li>XCTAssertEqualObjects(a1, a2, format…) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；</li></ul><ul><li>XCTAssertEqualObjects(@”1”, @”1”, @”[a1 isEqual:a2] should return YES”);</li></ul><ul><li>XCTAssertEqualObjects(@”1”, @”2”, @”[a1 isEqual:a2] should return YES”);</li></ul><ul><li>XCTAssertNotEqualObjects(a1, a2, format…) 判断不等， [a1 isEqual:a2] 值为False时通过，</li></ul><ul><li>XCTAssertNotEqualObjects(@”1”, @”1”, @”[a1 isEqual:a2] should return NO”);</li></ul><ul><li>XCTAssertNotEqualObjects(@”1”, @”2”, @”[a1 isEqual:a2] should return NO”);</li></ul><ul><li>XCTAssertEqual(a1, a2, format…) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</li></ul><ul><li>XCTAssertNotEqual(a1, a2, format…) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）;</li></ul><ul><li>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试;</li></ul><ul><li>XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @”a1 = a2 in accuracy should return YES”);</li></ul><ul><li>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试;</li></ul><ul><li>XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @”a1 = a2 in accuracy should return NO”);</li></ul><ul><li>XCTAssertThrows(expression, format…) 异常测试，当expression发生异常时通过；反之不通过；</li></ul><ul><li>XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过;</li></ul><ul><li>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过;</li></ul><ul><li>XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；</li></ul><ul><li>XCTAssertNoThrowSpecific(expression, specificException, format…)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过;</li></ul><ul><li>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Xcode中新建项目的时候会默认勾选单元测试，勾选后每个XCode新建的iOS的项目中都有一个叫做”项目名Tests”的分组，这个分组里就是XCTestCase的子类，XCTest中的测试类都是继承自XCTestC
      
    
    </summary>
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://imlifengfeng.github.io/tags/iOS/"/>
    
      <category term="XCTest" scheme="https://imlifengfeng.github.io/tags/XCTest/"/>
    
  </entry>
  
</feed>
