<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>@property参数详解 | imlifengfeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">@property参数详解</h1><a id="logo" href="/.">imlifengfeng</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">@property参数详解</h1><div class="post-meta">Jan 5, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>一、<strong>@property参数</strong></p>
<p>1、第一组<br>内存管理特性：retain assign copy strong weak unsafe_unretained autoreleasing</p>
<p>2、第二组<br>读 /写特性：readwrite readonly</p>
<p>3、第三组<br>多线程特性：nonatomic atomic</p>
<p>4、第四组<br>方法名特性：setter getter</p>
<p>二、<strong>参数作用</strong></p>
<p>1、第一组（retain assign copy strong weak unsafe_unretained autoreleasing）用于：set方法内存管理</p>
<p>assign（默认参数）：setter方法直接赋值，不进行任何retain操作，不改变引用计数。该方法只会针对“纯量类型”(CGFloat或NSInteger等)和C数据类型（int, float, double, char, 等等）的简单赋值操作，id类型也要用assign，所以一般iOS中的代理delegate属性都会用assign来标示。</p>
<p>retain：生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量。</p>
<p>copy：生成符合内存管理的set方法（release旧值，copy新值），适用于NSString、NSArray等不可变对象。和strong类似，不过该属性会被复制一个新的副本。很多时候使用copy是为了防止Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。</p>
<p>strong：强引用，其存亡直接决定了所指向对象的存亡。使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，即引用计数+1。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。适用于一般OC对象。</p>
<p>weak：表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被置为nil。weak引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到weak。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。相比于assign，声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为 nil。这样的好处能有效的防止野指针。因为ViewController对控件强引用，如果delegate声明为strong，UI控件代理一般指向ViewController本身，那么就会造成循环引用。不过非UI控件的delegate的属性声明是weak还是strong就要视情况而定。一般iOS的ARC中的代理delegate属性都会用weak，<strong>有时候</strong>也用于UI控件(如果是懒加载则必须用strong)。<br>[successbox title=”UI控件到底用weak还是strong？”]</p>
<p>1、从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了如下的引用关系,以UIButton为例：<br>UIViewController-&gt;UIView-&gt;subView-&gt;UIButton<br>然后你为这个UIButton声明一个weak属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) IBOOutlet UIButton *btn;</span><br></pre></td></tr></table></figure>
<p>相当于xib/sb对这个Button是强引用，你声明的属性对它是弱引用。</p>
<p>2、代码创建控件<br>（a）将控件声明成strong</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) UIButton *btn;</span><br></pre></td></tr></table></figure>
<p>那么你在实现这个控件时只需这样：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_btn = <span class="comment">[<span class="comment">[UIButton alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[self.view addSubview:_btn]</span></span><br></pre></td></tr></table></figure>
<p>（b）将控件声明成weak</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) UIButton *btn;</span><br></pre></td></tr></table></figure>
<p>那么你在实现这个控件时需要这样：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">UIButton</span> *<span class="keyword">button </span>= [[UIButton alloc]init]<span class="comment">;</span></span><br><span class="line"><span class="symbol">_btn</span> = <span class="keyword">button;</span></span><br><span class="line"><span class="keyword">[self.view </span><span class="keyword">addSubview:_btn];</span></span><br></pre></td></tr></table></figure>
<p>[/successbox]</p>
<p>[successbox title=”Delegate到底用weak还是assign？”]</p>
<p>为了在 Delegate 关系中防止强引用循环。在 ARC 特性下，通常我们应该设置 Delegate 属性为 weak 的。但是这里有一个疑问，我们常用到的 UITableView 的 delegate 属性是这样定义的： @property (nonatomic, assign) id<uitableviewdelegate> delegate;，为什么用的修饰符是 assign 而不是 weak？其实这个 assign 在 ARC 中意义等同于 __unsafe_unretaied（后面会讲到），它是为了在 ARC 特性下兼容 iOS4 及更低版本来实现弱引用机制。一般情况下，你应该<strong>尽量使用 weak</strong>。</uitableviewdelegate></p>
<p>[/successbox]</p>
<p>unsafe_unretained：和weak一样，唯一的区别就是当对象被释放后，该属性不会被设置为nil，当该对象指针指向的内存地址被释放后，如果我们没有将其设置为nil，则在调用时会造成野指针，因为指向的内存释放了，所以是unsafe的，访问野指针的内存就造成crash， 所以尽量少用。</p>
<p>注意：</p>
<p>（1）weak与Strong一般在开启ARC机制下使用</p>
<p>（2）Strong决定了对象的存亡（一个对象如果没有强指针指向（引用计数器为0）时，对象将被销毁，释放内存），其指向一个对象，相当于该对象做了一次retain操作。</p>
<p>非ARC的retain，相当于ARC的strong，ARC的弱引用weak相当于非ARC的assign</p>
<p>使用copy参数与使用retain参数产生的set方法一致（将生成set方法中的retain改为copy即可）</p>
<p>strong,weak, unsafe_unretained往往都是用来声明属性的，如果想声明临时变量就得用<strong>strong, </strong>weak, <strong>unsafe_unretained, </strong>autoreleasing, 其用法与上面介绍的类似。</p>
<p>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSString</span> *yourString = <span class="string">@"Your String"</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *myString = yourString;</span><br><span class="line"></span><br><span class="line">yourString = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *theirString = myString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在所有的指针都为nil</span></span><br></pre></td></tr></table></figure>
<p>再例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSString</span> *yourString = <span class="string">@"Your String"</span>;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *myString = yourString;</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *theirString = myString;</span><br><span class="line"></span><br><span class="line">yourString = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在yourString与myString的指针都为nil,而theirString不为nil,但是是野指针。</span></span><br></pre></td></tr></table></figure>
<p><strong>autoreleasing：在c/c++，objective-c内存管理中有一条是：谁分配谁释放。 </strong>autoreleasing则可以使对像延迟释放。比如你想传一个未初始 化地对像引用到一个方法当中，在此方法中实例化此对像，那么这种情况将是__autoreleasing表演的时候。例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) generateErrorInVariable:(__autoreleasing <span class="built_in">NSError</span> **)paramError&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *objects = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"A simple error"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *keys = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="built_in">NSLocalizedDescriptionKey</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *errorDictionary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjects:objects forKeys:keys];</span><br><span class="line"></span><br><span class="line">    *paramError = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="string">@"MyApp"</span>code:<span class="number">1</span> userInfo:errorDictionary];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)test&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> generateErrorInVariable:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error = %@"</span>, error);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样即便在函数内部申请的空间，在函数外部也可以使用，同样也适合谁分配谁释放的原则。</p>
<p>同样下面的代码也是类似原因, 只不过在没有开启ARC的情况下适用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)stringTest</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *retStr = [<span class="built_in">NSString</span> stringWithString:<span class="string">@"test"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>[[retStr <span class="keyword">retain</span>] autorelease];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启ARC后，应改为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)stringTest</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    __autoreleasing <span class="built_in">NSString</span> *retStr = [<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、第二组（readwrite readonly）用于：是否要生成set方法</p>
<p>readwrite（默认参数）：同时生成set、get方法的声明与实现，可读、可写</p>
<p>readonly：只生成get方法的声明与实现（不生成set的方法的声明与实现），只读</p>
<p>3、第三组（nonatomic atomic）用于：多线程管理</p>
<p>atomic（默认参数）：原子性，性能低（一般开发OC中的APP不推荐使用，做金融等要求高安全的时候使用）</p>
<p>nonatomic：非原子性，性能高（强烈推荐使用，性能高）</p>
<p>atomic：（原子性操作），会被加锁，就是一个操作执行过程不能被中断,要不就执行完,要不就不执行（一个操作不可以在中途被cpu暂停然后调度）。如果一个操作是原子性的,那么在多线程环境下,就不会出现变量被修改等奇怪的问题（保证数据同步）。原子操作就是不可再分的操作，在多线程程序中原子操作是一个非常重要的概念，它常常用来实现一些同步机制，同时也是一些常见的多线程Bug的源头。</p>
<p>nonatomic：（非原子性操作）操作是直接从内存中取数值（不考虑其是否被占用），因为它是从内存中取得数据，它并没有一个加锁的保护来用于cpu中的寄存器计算Value，它只是单纯的从内存地址中，当前的内存存储的数据结果来进行使用。在多线程环境下可提高性能，但无法保证数据同步。</p>
<p>4、第四组（setter getter）用于：set、get方法重命名（常用于BOOL类型的成员变量的get方法,BOOL方法常以is开头（set方法很少用））</p>
<p>setter：给成员变量的set方法重命名，set方法默认命名：- （void） set成员变量名（成员变量名首字母大写）：（成员变量数据类型）成员变量名。</p>
<p>getter：给成员变量的set方法重命名，get方法默认命名：- （成员变量数据类型） 成员变量名。<br>synthesize ：合成访问器方法，实现property所声明的方法的定义。其实说直白就像是：property声明了一些成员变量的访问方法，synthesize则定义了由property声明的方法。</p>
<p>他们之前的对应关系是:property 声明方法 -&gt;头文件中申明getter和setter方法 synthesize定义方法 -&gt; m文件中实现getter和setter方法。在.m文件中同时实现getter和setter时候需要@synthesize age = _age。</p>
<p>在Xcode4.5及以后的版本中，可以省略@synthesize，编译器会自动帮你加上get 和 set 方法的实现，并且默认会去访问_age这个成员变量，如果找不到_age这个成员变量，会自动生成一个叫做 _age的私有成员变量。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2017/01/05/453/">http://www.imlifengfeng.com/2017/01/05/453/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/property/">@property</a></div><div class="post-nav"><a class="pre" href="/2017/01/08/457/">iOS Block详解</a><a class="next" href="/2016/12/27/404/">iOS Runtime之七：拾遗</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.imlifengfeng.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">imlifengfeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>