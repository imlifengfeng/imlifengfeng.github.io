<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS Block详解 | imlifengfeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS Block详解</h1><a id="logo" href="/.">imlifengfeng</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS Block详解</h1><div class="post-meta">Jan 8, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>闭包 = 一个函数「或指向函数的指针」+ 该函数执行的外部的上下文变量「也就是自由变量」；Block 是 Objective-C 对于闭包的实现。</p>
<p>其中，Block：</p>
<ul>
<li>可以嵌套定义，定义 Block 方法和定义函数方法相似</li>
</ul>
<ul>
<li>Block 可以定义在方法内部或外部</li>
</ul>
<ul>
<li>只有调用 Block 时候，才会执行其{}体内的代码</li>
</ul>
<ul>
<li>本质是对象，使代码高聚合</li>
</ul>
<p>使用 clang 将 OC 代码转换为 C++ 文件查看 block 的方法：</p>
<ul>
<li>在命令行输入代码 <em>clang -rewrite-objc 需要编译的OC文件.m</em></li>
</ul>
<ul>
<li>这时查看当前的文件夹里 多了一个相同的名称的 .cpp 文件，在命令行输入 <em>open main.cpp</em> 查看文件</li>
</ul>
<p>二、<strong>Block的定义与使用</strong></p>
<p>1、无参数无返回值</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，无参数，无返回值，声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^MyBlockOne)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"无参数，无返回值"</span>);  </span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line">MyBlockOne();<span class="comment">//block的调用</span></span><br></pre></td></tr></table></figure>
<p>2、有参数无返回值</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2，有参数，无返回值，声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^MyblockTwo)(<span class="keyword">int</span> a) = ^(<span class="keyword">int</span> a)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"@ = %d我就是block，有参数，无返回值"</span>,a);</span><br><span class="line"></span><br><span class="line">  &#125;;  </span><br><span class="line">MyblockTwo(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>3、有参数有返回值</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3，有参数，有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(^MyBlockThree)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;    </span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%d我就是block，有参数，有返回值"</span>,a + b);returna + b; </span><br><span class="line"></span><br><span class="line"> &#125;;  </span><br><span class="line">MyBlockThree(<span class="number">12</span>,<span class="number">56</span>);</span><br></pre></td></tr></table></figure>
<p>4、无参数有返回值(很少用到)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4，无参数，有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(^MyblockFour)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"无参数，有返回值"</span>);</span><br><span class="line">        return45;</span><br><span class="line">  &#125;;</span><br><span class="line">MyblockFour();</span><br></pre></td></tr></table></figure>
<p>5、实际开发中常用typedef 定义Block</p>
<p>例如，用typedef定义一个block：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(^MyBlock)</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这时，MyBlock就成为了一种Block类型<br>在定义类的属性时可以这样：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic,copy) MyBlock myBlockOne;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.myBlockOne = ^<span class="keyword">int</span> (<span class="keyword">int</span> ,<span class="keyword">int</span>)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、<strong>Block与外界变量</strong></p>
<p>1、截获自动变量（局部变量）值</p>
<p>（1）默认情况</p>
<p>对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。也就是说block的自动变量截获只针对block内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于block的结构体内部, 会导致block体积变大。特别要注意的是默认情况下block只能访问不能修改局部变量的值。</p>
<p><img src="/images/2017/01/1862021-631904c4e9aba96d.jpg" alt="1862021-631904c4e9aba96d"></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">myBlock <span class="keyword">block </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"age = %d"</span>, age)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">age = <span class="number">18</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>（2） __block 修饰的外部变量</p>
<p>对于用 <strong>block 修饰的外部变量引用，block 是复制其引用地址来实现访问的。block可以修改</strong>block 修饰的外部变量的值。</p>
<p><img src="/images/2017/01/1862021-9d41b9401608ce22.jpg" alt="1862021-9d41b9401608ce22"></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block int age = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">myBlock <span class="keyword">block </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"age = %d"</span>, age)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">age = <span class="number">18</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>为什么使用__block 修饰的外部变量的值就可以被block修改呢？</p>
<p>我们使用 clang 将 OC 代码转换为 C++ 文件：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -<span class="built_in">rewrite</span>-objc 源代码文件名</span><br></pre></td></tr></table></figure>
<p>便可揭开其真正面纱：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block int val = <span class="number">10</span>;</span><br><span class="line">转换成</span><br><span class="line">__Block_byref_val_0 val = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &amp;val,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    sizeof(__Block_byref_val_0),</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>会发现一个局部变量加上<strong>block修饰符后竟然跟block一样变成了一个</strong>Block_byref_val_0结构体类型的自动变量实例！！！！</p>
<p>此时我们在block内部访问val变量则需要通过一个叫<strong>forwarding的成员变量来间接访问val变量(下面会对</strong>forwarding进行详解)</p>
<p>四、<strong>Block的copy操作</strong></p>
<p>1、Block的存储域及copy操作</p>
<p>在开始研究Block的copy操作之前，先来思考一下：Block是存储在栈上还是堆上呢？</p>
<p>我们先来看看一个由C/C++/OBJC编译的程序占用内存分布的结构：</p>
<p><img src="/images/2017/01/memory_structure.jpg" alt="memory_structure"></p>
<p>其实，block有三种类型：</p>
<ul>
<li>全局块(_NSConcreteGlobalBlock)</li>
</ul>
<ul>
<li>栈块(_NSConcreteStackBlock)</li>
</ul>
<ul>
<li>堆块(_NSConcreteMallocBlock)</li>
</ul>
<p>这三种block各自的存储域如下图：</p>
<p><img src="/images/2017/01/2107810-db72f760c3eaa8ab.jpg" alt="2107810-db72f760c3eaa8ab"></p>
<ul>
<li>全局块存在于全局内存中, 相当于单例.</li>
</ul>
<ul>
<li>栈块存在于栈内存中, 超出其作用域则马上被销毁</li>
</ul>
<ul>
<li>堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存</li>
</ul>
<p>简而言之，存储在栈中的Block就是栈块、存储在堆中的就是堆块、既不在栈中也不在堆中的块就是全局块。</p>
<p>遇到一个Block，我们怎么这个Block的存储位置呢？</p>
<p>（1）Block不访问外界变量（包括栈中和堆中的变量）</p>
<p>Block 既不在栈又不在堆中，在代码段中，ARC和MRC下都是如此。此时为全局块。</p>
<p>（2）Block访问外界变量</p>
<p>MRC 环境下：访问外界变量的 Block 默认存储<strong>栈</strong>中。<br>ARC 环境下：访问外界变量的 Block 默认存储在<strong>堆</strong>中（<strong>实际是放在栈区，然后ARC情况下自动又拷贝到堆区</strong>），自动释放。</p>
<p>ARC下，访问外界变量的 Block为什么要自动从栈区拷贝到堆区呢？</p>
<p>栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，如同一般的自动变量。当然，Block中的__block变量也同时被废弃。如下图：</p>
<p><img src="/images/2017/01/3629436-49cdbfca00a85bb6.png" alt="3629436-49cdbfca00a85bb6"></p>
<p>为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们需要把Block复制到堆中，延长其生命周期。开启ARC时，大多数情况下编译器会恰当地进行判断是否有需要将Block从栈复制到堆，如果有，自动生成将Block从栈上复制到堆上的代码。<strong>Block的复制操作执行的是copy实例方法</strong>。Block只要调用了copy方法，栈块就会变成堆块。</p>
<p>如下图：</p>
<p><img src="/images/2017/01/3629436-bb42e22148f1c747.png" alt="3629436-bb42e22148f1c747"></p>
<p>例如下面一个返回值为Block类型的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(^<span class="keyword">blk_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate) &#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> count) &#123; <span class="keyword">return</span> rate * count; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析可知：上面的函数返回的Block是配置在栈上的，所以返回函数调用方时，Block变量作用域就结束了，Block会被废弃。但在ARC有效，这种情况编译器会自动完成复制。</p>
<p>在非ARC情况下则需要开发者调用copy方法手动复制，由于开发中几乎都是ARC模式，所以手动复制内容不再过多研究。</p>
<p>将Block从栈上复制到堆上相当消耗CPU，所以当Block设置在栈上也能够使用时，就不要复制了，因为此时的复制只是在浪费CPU资源。</p>
<p>Block的复制操作执行的是copy实例方法。不同类型的Block使用copy方法的效果如下表：</p>
<p><img src="/images/2017/01/Snip20170108_2.png" alt="snip20170108_2"></p>
<p>根据表得知，Block在堆中copy会造成引用计数增加，这与其他Objective-C对象是一样的。虽然Block在栈中也是以对象的身份存在，但是栈块没有引用计数，因为不需要，我们都知道栈区的内存由编译器自动分配释放。关于堆区和栈区详细内容可以参考下峰哥之前的文章：《<a href="http://www.imlifengfeng.com/blog/?p=147">总结：堆、栈、队列</a>》</p>
<p>不管Block存储域在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。</p>
<p>在ARC有效时，多次调用copy方法完全没有问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blk = [[[[blk <span class="built_in">copy</span>] <span class="built_in">copy</span>] <span class="built_in">copy</span>] <span class="built_in">copy</span>];</span><br><span class="line"><span class="comment">// 经过多次复制，变量blk仍然持有Block的强引用，该Block不会被废弃。</span></span><br></pre></td></tr></table></figure>
<p>2、<strong>block变量与</strong>forwarding</p>
<p>在copy操作之后，既然<strong>block变量也被copy到堆上去了, 那么访问该变量是访问栈上的还是堆上的呢?**</strong>forwarding** 终于要闪亮登场了，如下图：</p>
<p><img src="/images/2017/01/1862021-100fdd59e5b0c03a.png" alt="1862021-100fdd59e5b0c03a"></p>
<p>通过<strong>forwarding, 无论是在block中还是 block外访问</strong>block变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个__block变量。</p>
<p>五、<strong>防止 Block 循环引用</strong></p>
<p>Block 循环引用的情况：<br>某个类将 block 作为自己的属性变量，然后该类在 block 的方法体里面又使用了该类本身，如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.someBlock = ^(<span class="keyword">Type</span> <span class="built_in">var</span>)&#123;</span><br><span class="line">    <span class="meta">[</span><span class="built_in">self</span> dosomething<span class="meta">]</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>（1）ARC 下：使用 __weak</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(<span class="built_in">self</span>) weakSelf = <span class="built_in">self</span>;</span><br><span class="line"><span class="built_in">self</span>.someBlock = ^(<span class="keyword">Type</span> <span class="built_in">var</span>)&#123;</span><br><span class="line">   <span class="meta">[</span>weakSelf dosomething<span class="meta">]</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（2）MRC 下：使用 __block</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__block</span> typeof(<span class="keyword">self) </span><span class="keyword">blockSelf </span>= <span class="keyword">self;</span></span><br><span class="line"><span class="keyword">self.someBlock </span>= ^(Type var)&#123;</span><br><span class="line">   [<span class="keyword">blockSelf </span>dosomething]<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在ARC下，使用 __block 也有可能带来的循环引用，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用 self -&gt; _attributBlock -&gt; tmp -&gt; self</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)();</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObj</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Block _attributBlock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObj</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    __block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.attributBlock = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Self = %@"</span>,tmp);</span><br><span class="line">        tmp = <span class="literal">nil</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">    <span class="keyword">self</span>.attributBlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类</span></span><br><span class="line"><span class="keyword">id</span> obj = [[TestObj alloc] init];</span><br><span class="line">[obj execBlock]; <span class="comment">// 如果不调用此方法，tmp 永远不会置 nil，内存泄露会一直在</span></span><br></pre></td></tr></table></figure>
<p>六、<strong>Block的使用示例</strong></p>
<p>1、Block作为变量（Xcode快捷键：inlineBlock）</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^<span class="keyword">sum</span>) (<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 定义一个 Block 变量 sum</span></span><br><span class="line"><span class="comment">// 给 Block 变量赋值</span></span><br><span class="line"><span class="comment">// 一般 返回值省略：sum = ^(int a,int b)…</span></span><br><span class="line"><span class="keyword">sum</span> = ^<span class="keyword">int</span> (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;  </span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;; <span class="comment">// 赋值语句最后有 分号</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">sum</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 调用 Block 变量</span></span><br></pre></td></tr></table></figure>
<p>2、Block作为属性（Xcode 快捷键：typedefBlock）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 给  Calculate 类型 sum变量 赋值「下定义」</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^Calculate)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// calculate就是类型名</span></span><br><span class="line">Calculate sum = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123; </span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a = sum(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 调用 sum变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 作为对象的属性声明，copy 后 block 会转移到堆中和对象一起</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) Calculate sum;    <span class="comment">// 使用   typedef</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">int</span> (^sum)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// 不使用 typedef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明，类外</span></span><br><span class="line"><span class="keyword">self</span>.sum = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用，类内</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">self</span>.sum(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>3、作为 OC 中的方法参数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---- 无参数传递的 Block ---------------------------</span></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)testTimeConsume:(<span class="keyword">void</span>(^)())middleBlock &#123;</span><br><span class="line">    <span class="comment">// 执行前记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> startTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    middleBlock();</span><br><span class="line">    <span class="comment">// 执行后记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> endTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">return</span> endTime - startTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">[<span class="keyword">self</span> testTimeConsume:^&#123;</span><br><span class="line">       <span class="comment">// 放入 block 中的代码 </span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 有参数传递的 Block ---------------------------</span></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)testTimeConsume:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> * name))middleBlock &#123;</span><br><span class="line">    <span class="comment">// 执行前记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> startTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSString</span> *name = <span class="string">@"有参数"</span>;</span><br><span class="line">    middleBlock(name);</span><br><span class="line">    <span class="comment">// 执行后记录下当前的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> endTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">[<span class="keyword">self</span> testTimeConsume:^(<span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">   <span class="comment">// 放入 block 中的代码，可以使用参数 name</span></span><br><span class="line">   <span class="comment">// 参数 name 是实现代码中传入的，在调用时只能使用，不能传值    </span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>4、<strong>Block回调</strong></p>
<p>Block回调是关于Block最常用的内容，比如网络下载，我们可以用Block实现下载成功与失败的反馈。开发者在block没发布前，实现回调基本都是通过代理的方式进行的，比如负责网络请求的原生类NSURLConnection类，通过多个协议方法实现请求中的事件处理。而在最新的环境下，使用的NSURLSession已经采用block的方式处理任务请求了。各种第三方网络请求框架也都在使用block进行回调处理。这种转变很大一部分原因在于block使用简单，逻辑清晰，灵活等原因。</p>
<p>如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DownloadManager.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadManager</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// block 重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^DownloadHandler)(<span class="built_in">NSData</span> * receiveData, <span class="built_in">NSError</span> * error);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadWithURL:(<span class="built_in">NSString</span> *)URL parameters:(<span class="built_in">NSDictionary</span> *)parameters handler:(DownloadHandler)handler ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DownloadManager.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DownloadManager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DownloadManager</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadWithURL:(<span class="built_in">NSString</span> *)URL parameters:(<span class="built_in">NSDictionary</span> *)parameters handler:(DownloadHandler)handler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> * request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:URL]];</span><br><span class="line">    <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行请求任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> * task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                handler(data,error);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面通过封装NSURLSession的请求，传入一个处理请求结果的block对象，就会自动将请求任务放到工作线程中执行实现，我们在网络请求逻辑的代码中调用如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)buttonClicked:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="meta">#define DOWNLOADURL @<span class="meta-string">"https://codeload.github.com/AFNetworking/AFNetworking/zip/master"</span></span></span><br><span class="line">    <span class="comment">//下载类</span></span><br><span class="line">    DownloadManager * downloadManager = [[DownloadManager alloc] init];</span><br><span class="line">    [downloadManager downloadWithURL: DOWNLOADURL parameters:<span class="literal">nil</span> handler:^(<span class="built_in">NSData</span> *receiveData, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"下载失败：%@"</span>,error);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"下载成功，%@"</span>,receiveData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了加深理解，再来一个简单的小例子：</p>
<p>A，B两个界面，A界面中有一个label，一个buttonA。点击buttonA进入B界面，B界面中有一个UITextfield和一个buttonB，点击buttonB退出B界面并将B界面中UITextfield的值传到A界面中的label。</p>
<p>A界面中，也就是ViewController类中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键demo：</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttonAction &#123;  </span><br><span class="line">    MyFirstViewController *myVC = [[MyFirstViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:myVC animated:<span class="literal">YES</span> completion:^&#123;    </span><br><span class="line">    &#125;];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;<span class="comment">//防止循环引用</span></span><br><span class="line"><span class="comment">//用属性定义的注意：这里属性是不会自动补全的，方法就会自动补全</span></span><br><span class="line">    [myVC setBlock:^(<span class="built_in">NSString</span> *string)&#123;</span><br><span class="line">        weakSelf.labelA.text = string;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B界面中，也就是MyFirstViewController类中.m文件:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)<span class="keyword">buttonBAction </span>&#123;</span><br><span class="line">    [self <span class="keyword">dismissViewControllerAnimated:YES </span>completion:^&#123;</span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">      self.<span class="keyword">block(_myTextfielf.text);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>.h文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef定义一下block，为了更好用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^MyBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyFirstViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MyBlock block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>看了以上两个Block回调示例，是不是感觉比delegate清爽了不少？</p>
<p><em>PS：Block是个值得深入学习的东西，这篇文章整整花了峰哥两天时间整理，但是觉得很值得~</em></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2017/01/08/457/">http://www.imlifengfeng.com/2017/01/08/457/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/Block/">Block</a></div><div class="post-nav"><a class="pre" href="/2017/01/09/469/">iOS Protocol详解</a><a class="next" href="/2017/01/05/453/">@property参数详解</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.imlifengfeng.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">imlifengfeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>