<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>李峰峰博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">李峰峰博客</h1><a id="logo" href="/.">李峰峰博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2018/10/03/714/">iOS 的组件化开发</a></h1><div class="post-meta">2018-10-03</div><div class="post-content"><p>在一个APP开发过程中，如果项目较小且团队人数较少，使用最基本的MVC、MVVM开发就已经足够了，因为维护成本比较低。</p>
<p>但是当一个项目开发团队人数较多时，因为每个人都会负责相应组件的开发，常规开发模式耦合会越来越严重，而且导致大量代码冲突，会使后期维护和升级过程中代码“牵一发而动全身”，额外带来很大的工作量，并且会导致一些潜在的BUG。</p></div><p class="readmore"><a href="/2018/10/03/714/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/07/06/692/">iOS逆向工程之fishhook</a></h1><div class="post-meta">2017-07-06</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>峰哥在<a href="http://www.imlifengfeng.com/blog/?p=677">上一篇文章</a>整理了在插件开发中如何HOOK 动态语言 Objective-C 中的方法，实际上静态语言 C 语言中的函数也是有办法 HOOK 的，这也说明了绝对的静态语言是不存在的。</p></div><p class="readmore"><a href="/2017/07/06/692/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/06/25/677/">iOS逆向工程之插件开发</a></h1><div class="post-meta">2017-06-25</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>iOS逆向工程是指在软件层面上进行逆向分析的一个过程，基于iOS逆向工程技术，我们可以监控甚至改变App的运行逻辑，从而达到获取核心信息，了解软件设计原理等战术目的。通过一段时间对iOS逆向工程的研究发现很有趣，会在博客记录学习开发过程中的心得和笔记。首先从基本插件的开发开始，后面会对微信、QQ等App进行逆向开发与修改，做一些有趣的事情～</p></div><p class="readmore"><a href="/2017/06/25/677/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/03/674/">Swift算法实现之归并排序</a></h1><div class="post-meta">2017-04-03</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。归并操作也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p></div><p class="readmore"><a href="/2017/04/03/674/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/04/01/672/">Swift算法实现之快速排序</a></h1><div class="post-meta">2017-04-01</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>快速排序又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n² )次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p></div><p class="readmore"><a href="/2017/04/01/672/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/03/31/669/">Swift算法实现之翻转二叉树</a></h1><div class="post-meta">2017-03-31</div><div class="post-content"><p>一、<strong>概述</strong><br>HomeBrew作者、天才程序员Max Howell兴致盎然地去Google面试，结果却因不会在白板上翻转二叉树被Google粗鲁地拒绝了，重要的是 Google 中90%的员工都在使用HomeBrew，Max Howell的被拒一时间舆论甚是哗然。在知乎（<a href="https://www.zhihu.com/question/31202353" target="_blank" rel="noopener">点击查看</a>）上也曾展开过激烈的讨论。虽然如此，也阻挡不了我对Max Howell的敬佩。</p></div><p class="readmore"><a href="/2017/03/31/669/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/03/31/661/">Swift算法实现之二叉树</a></h1><div class="post-meta">2017-03-31</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>二叉树的结构一般是以二叉链表的形式来存储的。二叉链表的结构类似于双向链表，二叉链表的节点也是有两个结点指针的，一个指向左子树，一个指向右子树。二叉树主要有四种遍历方式：先序遍历、中序遍历、后序遍历、层次遍历。关于二叉树的内容网上有很多，这里不再做过多的陈述。</p></div><p class="readmore"><a href="/2017/03/31/661/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/03/28/658/">Swift算法实现之栈和队列</a></h1><div class="post-meta">2017-03-28</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>栈和队列在数据结构中是比较重要的一个数据结构。其实对于栈和队列并不需要太深入的介绍，栈和队列的核心内容是栈是先进后出、队列是先进先出。在实际开发中有些场景也可能会用到，比如 APP 中用户可以撤销操作，比如下棋 APP 中的悔棋操作，返回上一步就是先进后出（后进先出），也就是栈的特性。比如在售票 APP 中，为先下订单的用户先出票，就需要用到队列。当然这两个只是在简单场景下的情况，实际开发中情况可能更复杂，比如售票 APP 为会员用户优先出票等。</p></div><p class="readmore"><a href="/2017/03/28/658/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/03/27/654/">Swift算法实现之查找第K大的元素</a></h1><div class="post-meta">2017-03-27</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>这道算法题是《编程之美》中比较经典的一题，解法也有很多，《编程之美》里面基本上介绍了五种解法:</p>
<p>（a）排序O(NlogN) 或者O(KN)</p>
<p>（b）快速排序，平均时间O(N)，最坏的可以是O(N^2)，这里书里面是不管怎么样都两边都排序, 所以书里面的平均时间复杂度是O(NlogN)，但是对于这道题没必要两边都排序，具体的后面会讲，这也是本文使用的一种解法</p></div><p class="readmore"><a href="/2017/03/27/654/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2017/03/23/652/">Swift算法实现之数组中出现次数超过一半的数字</a></h1><div class="post-meta">2017-03-23</div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>这也是剑指 Offer 上的一道很经典的题，对于这道题，我们得分两种情况来讨论：有序和无序。如果数组是有序的，那就非常简单了，数组中间的那个数字一定是我们要求的那个出现次数超过一半的数字。如果数组是无序的，当然可以先将数组进行排序，然后去求中间的那位数字，除此之外是不是还有更简单的方法呢？</p></div><p class="readmore"><a href="/2017/03/23/652/">阅读全文</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.imlifengfeng.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">李峰峰博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>