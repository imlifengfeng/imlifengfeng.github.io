<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>使用 LLDB 调试 APP | 李峰峰博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-130566667-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bc022e1db553f2f9ac8145120b657824';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">使用 LLDB 调试 APP</h1><a id="logo" href="/.">李峰峰博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">使用 LLDB 调试 APP</h1><div class="post-meta">Mar 13, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>LLDB全称 [ Low Level Debugger ], 默认内置于Xcode中的动态调试工具。标准的 LLDB 提供了一组广泛的命令，旨在与熟悉的 GDB 命令兼容。 除了使用标准配置外，还可以很容易地自定义 LLDB 以满足实际需要。</p>
<p>二、<strong>LLDB调试命令</strong></p>
<p>首先先通过一个简单的例子体验下 LLDB 调试：</p>
<p><img src="/images/2017/03/Snip20170313_1.png" alt="Snip20170313_1"></p>
<p>我们在上面第25行添加了断点，运行后程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。我们使用 _print _命令打印 age 的值：</p>
<p><img src="/images/2017/03/Snip20170313_2.png" alt="Snip20170313_2"></p>
<p>如上图，输入 _print age _命令回车即可打印出 age 的值，结果前的 $0 可以用来指向这个结果。例如我们使用 _print $0 + 5 _命令测试一下：</p>
<p><img src="/images/2017/03/Snip20170313_3.png" alt="Snip20170313_3"></p>
<p>如上图可知 _print $0 + 5 _相当于 _print age + 5 _。</p>
<p>LLBD 语法结构：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;command&gt;</span> [<span class="symbol">&lt;subcommand&gt;</span> [<span class="symbol">&lt;subcommand&gt;</span>...]] <span class="symbol">&lt;action&gt;</span> [-<span class="keyword">options</span> [option-value]] [<span class="keyword">argument</span> [<span class="keyword">argument</span>...]]</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">command</span>&gt;</span>(命令)和<span class="tag">&lt;<span class="name">subcommand</span>&gt;</span>(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</span><br><span class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span>：执行命令的操作</span><br><span class="line"><span class="tag">&lt;<span class="name">options</span>&gt;</span>：命令选项</span><br><span class="line"><span class="tag">&lt;<span class="name">arguement</span>&gt;</span>：命令的参数</span><br><span class="line">[]：表示命令是可选的，可以有也可以没有</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint <span class="keyword">set</span> -f <span class="comment">main.m -l 16</span></span><br></pre></td></tr></table></figure>
<p>与上面语法结构对应的是：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">command:</span> breakpoint 添加断点命令</span><br><span class="line"><span class="symbol">action:</span> <span class="keyword">set</span> 表示设置断点</span><br><span class="line"><span class="symbol">option:</span> -f 表示在某文件添加断点</span><br><span class="line"><span class="symbol">arguement:</span> mian.m 表示要添加断点的文件名为mian.m</span><br><span class="line"><span class="symbol">option:</span> -l 表示某一行</span><br><span class="line"><span class="symbol">arguement:</span> <span class="number">16</span> 表示第<span class="number">16</span>行</span><br></pre></td></tr></table></figure>
<p>Commands，subcommands，options，option values和arguments都是以空格分隔的，双引号用于保护选项值和参数中的空格。 如果需要将反斜杠或双引号字符放入参数中，则在该参数前面加上反斜杠。 LLDB使用单引号和双引号是等价的。例如：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command <span class="string">[subcommand]</span> -option <span class="string">"some \"</span>quoted\<span class="string">" string"</span></span><br></pre></td></tr></table></figure>
<p>也可以这样写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">command</span> [subcommand] -<span class="keyword">option</span> 'some <span class="string">"quoted"</span> <span class="keyword">string</span>'</span><br></pre></td></tr></table></figure>
<p>上面的print命令只是LLDB调试中的一个很简单但很常用的命令，除此之外还有很多有可能用到的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">调试器命令:</span><br><span class="line"></span><br><span class="line">  apropos           <span class="comment">-- 列出与单词或主题相关的调试器命令</span></span><br><span class="line">  breakpoint        <span class="comment">-- 在断点上操作的命令 (详情使用'help b'查看)</span></span><br><span class="line">  bugreport         <span class="comment">-- 用于创建指定域的错误报告</span></span><br><span class="line">  command           <span class="comment">-- 用于管理自定义LLDB命令的命令</span></span><br><span class="line">  disassemble       <span class="comment">-- 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span></span><br><span class="line">  expression        <span class="comment">-- 求当前线程上的表达式的值。 以LLDB默认格式显示返回的值</span></span><br><span class="line">  frame             <span class="comment">-- 用于选择和检查当前线程的堆栈帧的命令</span></span><br><span class="line">  gdb-remote        <span class="comment">-- 通过远程GDB服务器连接到进程。 如果未指定主机，则假定为localhost</span></span><br><span class="line">  gui               <span class="comment">-- 切换到基于curses的GUI模式</span></span><br><span class="line">  <span class="keyword">help</span>              <span class="comment">-- 显示所有调试器命令的列表，或提供指定命令的详细信息</span></span><br><span class="line">  kdp-remote        <span class="comment">-- 通过远程KDP服务器连接到进程。 如果没有指定UDP端口，则假定端口41139</span></span><br><span class="line">  <span class="keyword">language</span>          <span class="comment">-- 指定源语言</span></span><br><span class="line">  <span class="keyword">log</span>               <span class="comment">-- 控制LLDB内部日志记录的命令</span></span><br><span class="line">  <span class="keyword">memory</span>            <span class="comment">-- 用于在当前目标进程的内存上操作的命令</span></span><br><span class="line">  platform          <span class="comment">-- 用于管理和创建平台的命令</span></span><br><span class="line">  <span class="keyword">plugin</span>            <span class="comment">-- 用于管理LLDB插件的命令</span></span><br><span class="line">  process           <span class="comment">-- 用于与当前平台上的进程交互的命令</span></span><br><span class="line">  quit              <span class="comment">-- 退出LLDB调试器</span></span><br><span class="line">  <span class="keyword">register</span>          <span class="comment">-- 命令访问当前线程和堆栈帧的寄存器</span></span><br><span class="line">  script            <span class="comment">-- 使用提供的代码调用脚本解释器并显示任何结果。 如果没有提供代码，启动交互式解释器。</span></span><br><span class="line">  <span class="keyword">settings</span>          <span class="comment">-- 用于管理LLDB设置的命令</span></span><br><span class="line">  <span class="keyword">source</span>            <span class="comment">-- 检查当前目标进程的调试信息所描述的源代码的命令</span></span><br><span class="line">  target            <span class="comment">-- 用于在调试器目标上操作的命令</span></span><br><span class="line">  <span class="keyword">thread</span>            <span class="comment">-- 用于在当前进程中的一个或多个线程上操作的命令</span></span><br><span class="line">  <span class="keyword">type</span>              <span class="comment">-- 在类型系统上操作的命令</span></span><br><span class="line">  <span class="keyword">version</span>           <span class="comment">-- 显示LLDB调试器版本</span></span><br><span class="line">  watchpoint        <span class="comment">-- 在观察点上操作的命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩写命令 (使用 <span class="string">'help command alias'</span>查看更多信息):</span><br><span class="line"></span><br><span class="line">  <span class="keyword">add</span>-dsym  <span class="comment">-- ('target symbols add')  通过指定调试符号文件的路径，或使用选项指定下载符号的模块，将调试符号文件添加到目标的当前模块中的一个</span></span><br><span class="line">  attach    <span class="comment">-- ('_regexp-attach')  通过ID或名称附加到进程</span></span><br><span class="line">  b         <span class="comment">-- ('_regexp-break')  使用几种简写格式之一设置断点</span></span><br><span class="line">  bt        <span class="comment">-- ('_regexp-bt')  显示当前线程的调用堆栈。通过数字参数设置最多显示帧数。参数“all”显示所有线程</span></span><br><span class="line">  c         <span class="comment">-- ('process continue')  继续执行当前进程中的所有线程</span></span><br><span class="line">  <span class="keyword">call</span>      <span class="comment">-- ('expression --')  计算当前线程上的表达式,使用LLDB的默认格式显示返回的值</span></span><br><span class="line">  continue  <span class="comment">-- ('process continue')  继续执行当前进程中的所有线程</span></span><br><span class="line">  detach    <span class="comment">-- ('process detach')  脱离当前目标进程</span></span><br><span class="line">  di        <span class="comment">-- ('disassemble')  拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span></span><br><span class="line">  dis       <span class="comment">-- ('disassemble')  同上</span></span><br><span class="line">  display   <span class="comment">-- ('_regexp-display')  在每次停止时计算表达式（请参阅'help target stop-hook'）</span></span><br><span class="line">  down      <span class="comment">-- ('_regexp-down')  选择一个新的堆栈帧。默认为移动一个帧，数字参数可以指定值</span></span><br><span class="line">  env       <span class="comment">-- ('_regexp-env')  查看和设置环境变量的简写</span></span><br><span class="line">  <span class="keyword">exit</span>      <span class="comment">-- ('quit')  退出LLDB调试器</span></span><br><span class="line">  f         <span class="comment">-- ('frame select')  从当前线程中通过索引选择当前堆栈帧（参见'thread backtrace'）</span></span><br><span class="line">  <span class="keyword">file</span>      <span class="comment">-- ('target create')  使用参数作为主要可执行文件创建目标</span></span><br><span class="line">  <span class="keyword">finish</span>    <span class="comment">-- ('thread step-out')  完成当前堆栈帧的执行并返回后停止。 默认为当前线程</span></span><br><span class="line">  image     <span class="comment">-- ('target modules')  用于访问一个或多个目标模块的信息的命令</span></span><br><span class="line">  j         <span class="comment">-- ('_regexp-jump')  将程序计数器设置为新地址</span></span><br><span class="line">  jump      <span class="comment">-- ('_regexp-jump')  同上</span></span><br><span class="line">  <span class="keyword">kill</span>      <span class="comment">-- ('process kill')  终止当前目标进程</span></span><br><span class="line">  l         <span class="comment">-- ('_regexp-list')  使用几种简写格式之一列出相关的源代码</span></span><br><span class="line">  <span class="keyword">list</span>      <span class="comment">-- ('_regexp-list')  同上</span></span><br><span class="line">  n         <span class="comment">-- ('thread step-over')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  <span class="keyword">next</span>      <span class="comment">-- ('thread step-over')  同上</span></span><br><span class="line">  nexti     <span class="comment">-- ('thread step-inst-over')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  ni        <span class="comment">-- ('thread step-inst-over')  同上</span></span><br><span class="line">  p         <span class="comment">-- ('expression --')  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  parray    <span class="comment">-- ('expression -Z %1   --')  同上</span></span><br><span class="line">  po        <span class="comment">-- 计算当前线程上的表达式。显示由类型作者控制的格式的返回值。</span></span><br><span class="line">  poarray   <span class="comment">-- ('expression -O -Z %1    --')  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  print     <span class="comment">-- ('expression --')  同上</span></span><br><span class="line">  q         <span class="comment">-- ('quit')  退出LLDB调试器</span></span><br><span class="line">  r         <span class="comment">-- ('process launch -X true --')  在调试器中启动可执行文件</span></span><br><span class="line">  rbreak    <span class="comment">-- ('breakpoint set -r %1')  在可执行文件中设置断点或断点集</span></span><br><span class="line">  repl      <span class="comment">-- ('expression -r  -- ')  E计算当前线程上表达式的值，以LLDB默认格式显示返回值</span></span><br><span class="line">  run       <span class="comment">-- ('process launch -X true --')  在调试器中启动可执行文件</span></span><br><span class="line">  s         <span class="comment">-- ('thread step-in')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  si        <span class="comment">-- ('thread step-inst')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  sif       <span class="comment">-- 遍历当前块，如果直接步入名称与TargetFunctionName匹配的函数，则停止</span></span><br><span class="line">  step      <span class="comment">-- ('thread step-in')  源级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  stepi     <span class="comment">-- ('thread step-inst')  指令级单步执行、步进调用，默认当前线程</span></span><br><span class="line">  t         <span class="comment">-- ('thread select')  更改当前选择的线程</span></span><br><span class="line">  tbreak    <span class="comment">-- ('_regexp-tbreak')  使用几种简写格式之一设置单次断点</span></span><br><span class="line">  undisplay <span class="comment">-- ('_regexp-undisplay')  每次停止时停止显示表达式（由stop-hook索引指定）</span></span><br><span class="line">  up        <span class="comment">-- ('_regexp-up')  选择较早的堆栈帧。 默认为移动一个帧，数值参数可以指定任意数字</span></span><br><span class="line">  x         <span class="comment">-- ('memory read')  从当前目标进程的内存中读取</span></span><br></pre></td></tr></table></figure>
<p>当然，上面大部分命令是不经常使用的，不用全部记住，需要查找想要的命令时可以直接使用”help”命令显示所有调试器命令的列表，或查询指定命令的详细信息。</p>
<p>三、<strong>LLDB调试示例</strong></p>
<p>1、打印命令</p>
<p>打印命令是在实际开发中是经常使用的，在前面的例子中就测试了使用<em>print</em>命令去打印 age 的值，除了 _print <em>命令外，还有多种打印命令：</em> p、po、call_。我们可以通过实际测试看下他们的区别：</p>
<p><img src="/images/2017/03/Snip20170313_5.png" alt="Snip20170313_5"></p>
<p>可以看到 _po _命令只是打印数值，而 _print、p、call _命令还打印了变量的类型。所以，在实际开发中根据需要选择合适的打印命令。</p>
<p>在打印变量的值的时候，我们还可以使用_ print/<fmt>_ 或者简化的 <em>p/<fmt></fmt></em>指定打印格式，例如打印十六进制:</fmt></p>
<p><img src="/images/2017/03/Snip20170313_7.png" alt="Snip20170313_7"></p>
<p>x 代表十六进制格式、t 代表二进制格式，其他格式类型请<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">点击这里</a>查看。</p>
<p>从前面的命令列表可以看到 _print、p、po、call _都是 _expression _命令的简写，而 _expression _的作用是“求当前线程上的表达式的值”，也就是说我们可以利用它们更改变量的值，例如我们将 age 的值修改为100：</p>
<p><img src="/images/2017/03/Snip20170313_6.png" alt="Snip20170313_6"></p>
<p>2、断点操作</p>
<p>要在调试器中创建断点，可以使用_ breakpoint set _命令:</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">breakpoint <span class="keyword">set</span></span><br><span class="line">   -M &lt;<span class="function"><span class="keyword">method</span>&gt; <span class="params">( --<span class="keyword">method</span> &lt;<span class="keyword">method</span>&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">S</span> &lt;<span class="title">selector</span>&gt; <span class="params">( --<span class="keyword">selector</span> &lt;<span class="keyword">selector</span>&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">b</span> &lt;<span class="title">function</span>-<span class="title">name</span>&gt; <span class="params">( --basename &lt;<span class="keyword">function</span>-name&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">f</span> &lt;<span class="title">filename</span>&gt; <span class="params">( --file &lt;filename&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">l</span> &lt;<span class="title">linenum</span>&gt; <span class="params">( --line &lt;linenum&gt; )</span></span></span><br><span class="line"><span class="function">   -<span class="title">n</span> &lt;<span class="title">function</span>-<span class="title">name</span>&gt; <span class="params">( --name &lt;<span class="keyword">function</span>-name&gt; )</span></span></span><br><span class="line"><span class="function">…</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="builtin-name">set</span> -f ViewController.m -l 25</span><br><span class="line">Breakpoint 2: where = LLDBTest`-[ViewController lldbTest] + 50 at ViewController.m:25,<span class="built_in"> address </span>= 0x0000000102c90752</span><br></pre></td></tr></table></figure>
<p>上面含义为在 ViewController.m 文件的第25行添加断点。</p>
<p>也可以使用缩写形式  _br_。虽然 _b_ 是一个完全不同的命令 ( _regexp-break 的缩写)，但恰好也可以实现和上面同样的效果。</p>
<p>如果给当前的文件设置断点可以用下面的命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b 25</span><br><span class="line">Breakpoint 3: where = LLDBTest`-[ViewController lldbTest] + 50 at ViewController.m:25,<span class="built_in"> address </span>= 0x0000000102c90752</span><br></pre></td></tr></table></figure>
<p>也可以通过方法名设置断点：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint <span class="builtin-name">set</span> -n lldbTest</span><br><span class="line">Breakpoint 5: where = LLDBTest`-[ViewController lldbTest] + 23 at ViewController.m:23,<span class="built_in"> address </span>= 0x0000000102c90737</span><br></pre></td></tr></table></figure>
<p>上面 _-n _表示根据方法名设置断点。</p>
<p>查看所有断点：<em>breakpoint list</em> (或者 <em>br li</em>)</p>
<p>开启和关闭断点：<em>breakpoint enable <breakpointid></breakpointid></em> 和 <em>breakpoint disable <breakpointid>；</breakpointid></em></p>
<p>删除断点：<em>breakpoint delete <breakpointid></breakpointid></em></p>
<p>单步进入：<em>thread step-in</em>（或 <em>step</em> 或 _s_ ）</p>
<p>单步跳过：<em>thread step-over</em>（或 <em>next</em> 或 _n_）</p>
<p>继续运行：<em>thread continue</em>（或 <em>continue</em> 或 _c_）</p>
<p>3、设置观察点</p>
<p>通过上面的命令列表可以知道设置观察点使用 _watchpoint _命令，如果说 breakpoint 是对方法生效的断点，watchpoint就是对地址生效的断点，可以用他观察这个属性的地址。如果地址里面的东西改变了，就让程序中断。设置观察点可以用来观察变量或者属性值的变化。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">set</span> <span class="keyword">variable</span></span><br></pre></td></tr></table></figure>
<p>例如，我们要观察一个名为city的属性值：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">set</span> <span class="keyword">variable</span> <span class="comment">self-&gt;_city</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，上面的”self-&gt;_city”不可以改为”self.city”，因为”self.city”是调用city的getter方法！</p>
<p>如下，我们新增一个city属性并设置观察点：</p>
<p><img src="/images/2017/03/Snip20170313_9.png" alt="Snip20170313_9"></p>
<p>由于在第27行我们修改（设置）了 city 的值，所以继续运行程序会中断并且打印提示：</p>
<p><img src="/images/2017/03/Snip20170313_10.png" alt="Snip20170313_10"></p>
<p>我们也可以使用下面命令直接观察某个地址的变化：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="builtin-name">set</span> expression</span><br></pre></td></tr></table></figure>
<p>比如我们要观察上面 city 属性的地址变化，应该怎么获取 city 的地址呢？可以使用上面的打印命令，通过打印命令获取到地址之后就可以观察地址的变化了：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp; _city</span><br><span class="line">(NSString **) <span class="variable">$0</span> = 0x00007ffc80e100c8</span><br><span class="line">(lldb) watchpoint <span class="builtin-name">set</span> expression 0x00007ffc80e100c8</span><br><span class="line">Watchpoint created: Watchpoint 1: addr = 0x7ffc80e100c8 size = 8 state = enabled<span class="built_in"> type </span>= w</span><br><span class="line">    new value: 0</span><br></pre></td></tr></table></figure>
<p>_watchpoint _的查询、删除等命令与 _breakpoint _的命令使用一样，就不再一一列举用法了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="keyword">delete</span> </span><br><span class="line">watchpoint <span class="keyword">list</span></span><br><span class="line">watchpoint <span class="keyword">disable</span></span><br><span class="line">watchpoint <span class="keyword">enable</span></span><br></pre></td></tr></table></figure>
<p>4、打印线程堆栈信息</p>
<p>可以使用 thread backtrace（或_ bt_ ）命令打印线程堆栈信息：</p>
<p><img src="/images/2017/03/Snip20170313_11.png" alt="Snip20170313_11"></p>
<p>_thread backtrace _后面可以添加命令选项：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c：设置打印堆栈的帧数(frame) </span></span><br><span class="line"><span class="deletion">-s：设置从哪个帧(frame)开始打印 </span></span><br><span class="line"><span class="deletion">-e：是否显示额外的回溯</span></span><br></pre></td></tr></table></figure>
<p>Debug 的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。可以使用 _thread return _命令：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="keyword">return</span> <span class="string">'要返回的值'</span></span><br></pre></td></tr></table></figure>
<p><em>thread return</em> 不让代码执行某个方法，可以在某个方法的开始位置设置一个断点，当程序运行到断点的位置时直接返回我们设置的返回值。</p>
<p>thread其他命令：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread</span> <span class="built_in">list</span> <span class="comment">//打印所有线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread</span> <span class="keyword">select</span> <span class="comment">//跳到某一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread</span> info <span class="comment">//输出当前线程的信息</span></span><br></pre></td></tr></table></figure>
<p>5、查看帧栈</p>
<p>打印当前帧栈所有变量：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame <span class="keyword">variable</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame <span class="keyword">variable</span></span><br><span class="line">(ViewController <span class="comment">*) self = 0x00007fc0684085f0</span></span><br><span class="line">(SEL) _cmd <span class="comment">=</span> <span class="comment">"lldbTest"</span></span><br><span class="line">(__NSCFConstantString <span class="comment">*) name = 0x0000000102a2f068 @</span><span class="comment">"lifengfeng"</span></span><br><span class="line">(NSInteger) age <span class="comment">= 25</span></span><br></pre></td></tr></table></figure>
<p>打印某个变量：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame <span class="keyword">variable</span> <span class="string">'变量名'</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame variable <span class="built_in">name</span></span><br><span class="line">(<span class="variable">__NSCFConstantString</span> *) <span class="built_in">name</span> = <span class="number">0</span>x0000000102a2f068 @<span class="string">"lifengfeng"</span></span><br></pre></td></tr></table></figure>
<p>查看当前帧栈的信息：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame info</span><br><span class="line">frame #0: 0x0000000102a2d63f LLDBTest`-[<span class="string">ViewController lldbTest</span>](<span class="link">self=0x00007fc0684085f0, _cmd="lldbTest"</span>) + 79 at ViewController.m:28</span><br></pre></td></tr></table></figure>
<p>跳转到指定帧栈：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span> <span class="literal">select</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame select 0</span><br><span class="line">frame #0: 0x0000000102a2d63f LLDBTest`-[<span class="string">ViewController lldbTest</span>](<span class="link">self=0x00007fc0684085f0, _cmd="lldbTest"</span>) + 79 at ViewController.m:28</span><br><span class="line">   25  	    NSString *name = @"lifengfeng";</span><br><span class="line">   26  	    NSInteger age = 25;</span><br><span class="line">   27  	    _city = @"BJ";</span><br><span class="line">-&gt; 28  	    NSLog(@"%@ age is %ld，city is %@",name,(long)age,_city);</span><br><span class="line">   29  	    </span><br><span class="line">   30  	&#125;</span><br><span class="line">   31</span><br></pre></td></tr></table></figure>
<p>6、动态改变程序的运行轨迹</p>
<p>expression命令用来执行一个命令，并将表达式的结果输出。除此之外，expression还可以动态改变程序的运行轨迹。例如，我们上面例子中就是一个空白的ViewController，我们可以利用expression命令来改变UI的显示，如self.view的颜色等。</p>
<p>expression的完整语法如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>上面的”–”是命令选项结束符，表示所有的命令选项已经设置完毕，如果没有命令选项，–可以省略。</p>
<p>例如，我们改变self.view的颜色：</p>
<p><img src="/images/2017/03/Snip20170313_16.png" alt="Snip20170313_16"></p>
<p>其中，下面的命令用于刷新UI。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression -- (<span class="keyword">void</span>)[CATransaction <span class="built_in">flush</span>]</span><br></pre></td></tr></table></figure>
<p>以上就是LLDB调试常用用法，其他更多用法可以去研究下官方文档，总之LLDB调试对iOS开发者来说是一个非常重要的技能。</p>
<p>参考：<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html" target="_blank" rel="noopener">Getting Started with LLDB</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/622/">https://imlifengfeng.github.io/article/622/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://imlifengfeng.github.io/article/622/" data-id="cjpc8qsc100884ts6gww1oad0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3aS26EQAwFQO5/6ck2UhJ4tiES3cVqxCSMi4XV/hxHfH1a1/f/PX/yz185nrgwMDBey8hDOQ/uryCS5/z15CQ2DAyMfRhJKkxy3fkLynNmHhsGBgZGTsqTYzXhYmBgYPQYeTJN/rJaAGNgYOzJmLTMqoe8XgPutlocAwPjhYw8rP///Mh8AwMD41WM+Ugy/1xttxWiwsDAWJqRJ7jz0WN+P4H14sHAwFiVMW/x99JrvtIRwTAwMLZhVIOutu97KThZRMPAwNiBUS1Tq8j5aPPiPgYGxgaM/NHVA2IebvVXLopYDAyM5RjJGKAaRJ4J86K3OU/AwMBYjjFZsEju9IrYiwgxMDA2YCRBTMC91Y2ch4GBsTajutzQG4VWBw+9HhoGBsaqjLxwrS513buo0SxiMTAwlmD0mvLVI2OyclEthi94GBgYCzGSw9lkzFk9CObjBwwMjH0Y9zb0e8m0t9JRqMgxMDCWYFRL2V7Q1WRaTt8YGBgbMHr9q7sadtUFjl/uY2BgbMCYLEkkLbajeJUTNAYGxgaMSWJNnpN/22zJYWBgLMr4FK9qy6wXVvWVYWBgrM2YH9SeODLOi1sMDIz1GNWStVfczo+hN8wQMDAwXs6YJ75JWKNVMAwMDIzBWPG5o2Rh2QIDA2NLRrSkNU7cyYEy2hnBwMBYiDFZTu2tcUxeEAYGxm6Mu3pZ+VGvt8B6w8IZBgbG+xhfalLbGSOFnEAAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/LLDB/">LLDB</a><a href="/tags/调试/">调试</a></div><div class="post-nav"><a class="pre" href="/article/641/">Swift算法实现之字符串转数字</a><a class="next" href="/article/620/">Notification与多线程</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/article/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/article/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/article/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">李峰峰博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>