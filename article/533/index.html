<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS多线程详解 | 李峰峰博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-130566667-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bc022e1db553f2f9ac8145120b657824';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS多线程详解</h1><a id="logo" href="/.">李峰峰博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS多线程详解</h1><div class="post-meta">Feb 9, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>在iOS中每个进程启动后都会建立一个主线程（UI线程），这个线程是其他线程的父线程。由于在iOS中除了主线程，其他子线程是独立于Cocoa Touch的，所以只有主线程可以更新UI界面。iOS中多线程使用并不复杂，关键是如何控制好各个线程的执行顺序、处理好资源竞争问题。</p>
<p>多线程的实现有以下几种方式：</p>
<p><img src="/images/2017/02/1593252-1ae56de0c12d5936.png" alt="1593252-1ae56de0c12d5936"></p>
<p>NSThread：</p>
<p>（1）使用NSThread对象建立一个线程非常方便</p>
<p>（2）但是！要使用NSThread管理多个线程非常困难，不推荐使用</p>
<p>（3）技巧！使用[NSThread currentThread]获得任务所在线程，适用于这三种技术</p>
<p>（4）使线程休眠3秒：[NSThread sleepForTimeInterval:0.3f];</p>
<p>GCD —— Grand Central Dispatch：</p>
<p>（1）是基于C语言的底层API</p>
<p>（2）用Block定义任务，使用起来非常灵活便捷</p>
<p>（3）提供了更多的控制能力以及操作队列中所不能使用的底层函数</p>
<p>NSOperation/NSOperationQueue：</p>
<p>（1）是使用GCD实现的一套Objective-C的API</p>
<p>（2）是面向对象的线程技术</p>
<p>（3）提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系</p>
<p>二、<strong>线程与进程</strong></p>
<p>1、进程</p>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，每一个进程都有自己独立的虚拟内存空间。</p>
<p>简单来说，进程是指在系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>
<p>2、线程</p>
<p>线程，是程序执行流的最小单元线程是程序中一个单一的顺序控制流程。是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。</p>
<p>简单来说，1个进程要想执行任务，必须得有线程。</p>
<p>线程中任务的执行是串行的，要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务，也就是说，在同一时间内，1个线程只能执行1个任务，由此可以理解线程是进程中的1条执行路径。</p>
<p>一个进程中至少包含一条线程，即主线程，创建线程的目的就是为了开启一条新的执行路径，运行指定的代码，与主线程中的代码实现同时运行。</p>
<p>3、多线程</p>
<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p>
<p>原理：</p>
<ul>
<li>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）</li>
</ul>
<ul>
<li>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）</li>
</ul>
<ul>
<li>如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象<br>注意：多线程并发，并不是cpu在同一时刻同时执行多个任务，只是CPU调度足够快，造成的假象。</li>
</ul>
<p>优点：</p>
<ul>
<li>能适当提高程序的执行效率</li>
</ul>
<ul>
<li>能适当提高资源利用率（CPU、内存利用率）</li>
</ul>
<p>缺点：</p>
<ul>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
</ul>
<ul>
<li>线程越多，CPU在调度线程上的开销就越大</li>
</ul>
<p><img src="/images/2017/02/图片-1-1.png" alt="图片 1"></p>
<p>主线程栈区的1M，非常非常宝贵。一个进程，至少有一个线程(主线程)，不能杀掉一个线程！但是可以暂停、休眠。</p>
<p>三、<strong>NSThread的使用</strong></p>
<p>1、线程的创建</p>
<p>NSThread创建线程有如下三种方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：要执行的方法，参数2：提供selector的对象，通常是self，参数3传递给selector的参数</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:(<span class="keyword">nonnull</span> SEL)&gt; toTarget:(<span class="keyword">nonnull</span> <span class="keyword">id</span>) withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数一：提供selector的对象，通常是self,参数2：要执行的方法，参数3：传递给selector的参数（如果selector方法不带参数，就使用nil）</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式创建并启动线程，第一个参数为调用的方法，第二个参数为传给selector方法的参数</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelectorInBackground:</span>(SEL)aSelector <span class="string">withObject:</span>(id)arg</span><br></pre></td></tr></table></figure>
<p>NSThread对象的常见属性：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只读属性，线程是否在执行</span></span><br><span class="line"><span class="keyword">thread</span>.isExecuting;</span><br><span class="line"><span class="comment">//只读属性，线程是否被取消</span></span><br><span class="line"><span class="keyword">thread</span>.isCancelled;</span><br><span class="line"><span class="comment">//只读属性，线程是否完成</span></span><br><span class="line"><span class="keyword">thread</span>.isFinished;</span><br><span class="line"><span class="comment">//是否是主线程</span></span><br><span class="line"><span class="keyword">thread</span>.isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的优先级，取值范围0.0到1.0，默认优先级0.5，1.0表示最高优     //先级，优先级高，CPU调度的频率高</span></span><br><span class="line"><span class="keyword">thread</span>.threadPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的堆栈大小，线程执行前堆栈大小为512K，线程完成后堆栈大小       为0K</span></span><br><span class="line"><span class="comment">//注意:线程执行完毕后，由于内存空间被释放，不能再次启动</span></span><br><span class="line"><span class="keyword">thread</span>.stackSize;</span><br></pre></td></tr></table></figure>
<p>NSThread对象的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程开始，线程加入线程池等待CPU调度（并非真正开始执行，只是通常等待时间都非常短，看不出效果）</span></span><br><span class="line">[<span class="meta">thread start</span>];</span><br><span class="line"><span class="keyword">if</span>(!thread.isCancelled)&#123;<span class="comment">//在执行之前需要先确认线程状态，如果已经取消就直接返回</span></span><br><span class="line">    [<span class="meta">thread cancel</span>]; <span class="comment">//通知线程取消，可以在外不终止线程执行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>### </p>
<p>NSThread的类方法：</p>
<p>类方法都用在线程内部，也就是说类方法作用于相关类方法的线程。</p>
<p>（1）当前线程，在开发中常用于调试，适用于所有多线程计数，返回一个线程号码</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="built_in">number</span> == <span class="number">1</span> 表示主线程，<span class="built_in">number</span> ！= <span class="number">1</span>表示后台线程</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">number</span> = [NSThread currentThread]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>（2）阻塞方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠到指定时间</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line"><span class="comment">//休眠指定时长</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4.5</span>];</span><br></pre></td></tr></table></figure>
<p>（3）其他类方法</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>退出线程</span><br><span class="line">[NSThread <span class="keyword">exit</span>];</span><br><span class="line"><span class="regexp">//</span>当前线程是否为主线程</span><br><span class="line">[NSThread isMainThread];</span><br><span class="line"><span class="regexp">//</span>是否多线程</span><br><span class="line">[NSThread isMultiThreaded];</span><br><span class="line"><span class="regexp">//</span>返回主线程的对象</span><br><span class="line">NSThread *mainThread = [NSThread mainThread];</span><br></pre></td></tr></table></figure>
<p>2、线程的状态</p>
<p>线程的状态如下图：</p>
<p><img src="/images/2017/02/Snip20170209_1.png" alt="Snip20170209_1"></p>
<p>（1）新建：实例化对象</p>
<p>（2）就绪：向线程对象发送 start 消息，线程对象被加入“可调度线程池”等待 CPU 调度；detach 方法和 performSelectorInBackground 方法会直接实例化一个线程对象并加入“可调度线程池”</p>
<p>（3）运行:CPU 负责调度“可调度线程池”中线程的执行,线程执行完成之前，状态可能会在“就绪”和“运行”之间来回切换,“就绪”和“运行”之间的状态变化由 CPU 负责，程序员不能干预</p>
<p>（4）阻塞:当满足某个预定条件时，可以使用休眠或锁阻塞线程执行,影响的方法有：sleepForTimeInterval，sleepUntilDate，@synchronized(self)x线程锁；<br>线程对象进入阻塞状态后，会被从“可调度线程池”中移出，CPU 不再调度</p>
<p>（5）死亡<br>死亡方式：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正常死亡：线程执行完毕</span><br><span class="line">非正常死亡：线程内死亡---&gt;[NSThread <span class="keyword">exit</span>]:强行中止后，后续代码都不会在执行</span><br><span class="line">线程外死亡：[threadObj cancel]---&gt;通知线程对象取消,在线程执行方法中需要增加 isCancelled 判断,如果 isCancelled == YES，直接返回</span><br></pre></td></tr></table></figure>
<p>死亡后线程对象的 isFinished 属性为 YES；如果是发送 calcel 消息，线程对象的 isCancelled 属性为YES；死亡后 stackSize == 0，内存空间被释放。</p>
<p>3、多线程的安全问题</p>
<p>多个线程访问同一块资源进行读写，如果不加控制随意访问容易产生数据错乱从而引发数据安全问题。为了解决这一问题，就有了加锁的概念。加锁的原理就是当有一个线程正在访问资源进行写的时候，不允许其他线程再访问该资源，只有当该线程访问结束后，其他线程才能按顺序进行访问。对于读取数据，有些程序设计是允许多线程同时读的，有些不允许。UIKit中几乎所有控件都不是线程安全的，因此需要在主线程上更新UI。</p>
<p>解决多线程安全问题：</p>
<p>（1）互斥锁</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：锁定1份代码只用1把锁，用多把锁是无效的</span></span><br><span class="line"><span class="meta">@synchronized(锁对象)</span> &#123; <span class="comment">// 需要锁定的代码  &#125;</span></span><br></pre></td></tr></table></figure>
<p>使用互斥锁，在同一个时间，只允许一条线程执行锁中的代码。因为互斥锁的代价非常昂贵，所以锁定的代码范围应该尽可能小，只要锁住资源读写部分的代码即可。使用互斥锁也会影响并发的目的。</p>
<p>（2）使用NSLock对象</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_lock</span> = [[NSLock alloc] init];</span><br><span class="line"> - (void)synchronizedMethod &#123;</span><br><span class="line">    [<span class="variable">_lock</span> <span class="built_in">lock</span>];</span><br><span class="line">    <span class="comment">//safe</span></span><br><span class="line">    [<span class="variable">_lock</span> unlock];</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>（3）atomic加锁</p>
<p>OC在定义属性时有nonatomic和atomic两种选择。</p>
<p>atomic：原子属性，为setter方法加锁（默认就是atomic）。</p>
<p>nonatomic：非原子属性，不会为setter方法加锁。</p>
<p>atomic加锁原理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, atomic) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </span><br><span class="line">       _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>atomic：线程安全，需要消耗大量的资源</p>
<p>nonatomic：非线程安全，适合内存小的移动设备</p>
<p>iOS开发的建议:</p>
<p>（1）所有属性都声明为nonatomic</p>
<p>（2）尽量避免多线程抢夺同一块资源</p>
<p>（3）尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</p>
<p>4、线程间通信</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主线程上执行操作，例如给UIImageVIew设置图片</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelectorOnMainThread:</span>(SEL)aSelector <span class="string">withObject:</span>(id)arg <span class="string">waitUntilDone:</span>(BOOL)wait</span><br><span class="line"><span class="comment">//在指定线程上执行操作</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">performSelector:</span>(SEL)aSelector <span class="string">onThread:</span>(NSThread *)thread <span class="string">withObject:</span>(id)arg <span class="string">waitUntilDone:</span>(BOOL)wai</span><br></pre></td></tr></table></figure>
<p>四、GCD的使用</p>
<p>GCD（Grand Central Dispatch） 伟大的中央调度系统，是苹果为多核并行运算提出的C语言并发技术框架。</p>
<p>GCD会自动利用更多的CPU内核；<br>会自动管理线程的生命周期（创建线程，调度任务，销毁线程等）；<br>程序员只需要告诉 GCD 想要如何执行什么任务，不需要编写任何线程管理代码。</p>
<p>一些专业术语：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch </span>:派遣/调度</span><br><span class="line"></span><br><span class="line"><span class="attribute">queue</span>:队列</span><br><span class="line">    用来存放任务的先进先出（FIFO）的容器</span><br><span class="line"><span class="attribute">sync</span>:同步</span><br><span class="line">    只是在当前线程中执行任务，不具备开启新线程的能力</span><br><span class="line"><span class="attribute">async</span>:异步</span><br><span class="line">    可以在新的线程中执行任务，具备开启新线程的能力</span><br><span class="line"><span class="attribute">concurrent</span>:并发</span><br><span class="line">    多个任务并发（同时）执行</span><br><span class="line">串行：</span><br><span class="line">    一个任务执行完毕后，再执行下一个任务</span><br></pre></td></tr></table></figure>
<p>1、GCD中的核心概念</p>
<p>（1）任务</p>
<p>任务就是要在线程中执行的操作。我们需要将要执行的代码用block封装好，然后将任务添加到队列并指定任务的执行方式，等待CPU从队列中取出任务放到对应的线程中执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - <span class="built_in">queue</span>：队列</span><br><span class="line"> - block：任务</span><br><span class="line"><span class="comment">// 1.用同步的方式执行任务</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.用异步的方式执行任务</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.GCD中还有个用来执行任务的函数</span></span><br><span class="line"><span class="comment">// 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p>（2）队列</p>
<p>串行队列：串行队列一次只调度一个任务，一个任务完成后再调度下一个任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建串行队列</span></span><br><span class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用dispatch_get_main_queue()获得主队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br><span class="line">注意：主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行。</span><br></pre></td></tr></table></figure>
<p>并发队列：并发队列可以同时调度多个任务，调度任务的方式，取决于执行任务的函数；并发功能只有在异步的（dispatch_async）函数下才有效；异步状态下，开启的线程上线由GCD底层决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="number">1.</span>使用dispatch_queue_create函数创建队列</span><br><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="comment">// 队列名称,该名称可以协助开发调试以及崩溃分析报告 </span></span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr); <span class="comment">// 队列的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>以上自定义队列在MRC开发时需要使用dispatch_release释放队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__has_feature(objc_arc)</span></span><br><span class="line">    dispatch_release(<span class="built_in">queue</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>主队列：主队列负责在主线程上调度任务，如果在主线程上有任务执行，会等待主线程空闲后再调度任务执行。主队列用于UI以及触摸事件等的操作，我们在进行线程间通信，通常是返回主线程更新UI的时候使用到。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 耗时操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">//放回主线程的函数</span></span><br><span class="line">    <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 在主线程更新 UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>全局并发队列：全局并发队列是由苹果API提供的，方便程序员使用多线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dispatch_get_global_queue函数获得全局的并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">dispatch_queue_priority_t</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="comment">// dispatch_queue_priority_t priority(队列的优先级 )</span></span><br><span class="line"><span class="comment">// unsigned long flags( 此参数暂时无用，用0即可 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>全局并发队列有优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局并发队列的优先级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH 2 <span class="comment">// 高优先级</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT 0 <span class="comment">// 默认（中）优先级</span></span></span><br><span class="line"><span class="comment">//注意，自定义队列的优先级都是默认优先级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-2) <span class="comment">// 低优先级</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN <span class="comment">// 后台优先级</span></span></span><br></pre></td></tr></table></figure>
<p>然而，iOS8 开始使用 QOS(服务质量) 替代了原有的优先级。获取全局并发队列时，直接传递 0，可以实现 iOS 7 &amp; iOS 8 later 的适配。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像这样</span></span><br><span class="line">dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>全局并发队列与并发队列的区别：</p>
<p>（1）全局并发队列与并发队列的调度方法相同<br>（2）全局并发队列没有队列名称<br>（3）在MRC开发中，全局并发队列不需要手动释放</p>
<p>2、执行任务的函数</p>
<p>（1）同步（dispatch_sync）</p>
<p>任务被添加到队列后，会当前线程被调度；队列中的任务同步执行完成后，才会调度后续任务。</p>
<p>在主线程中，向主队列添加同步任务，会造成死锁。<br>在其他线程中，向主队列向主队列添加同步任务，则会在主线程中同步执行。</p>
<p>我们可以利用同步的机制，建立任务之间的依赖关系。如用户登录后，才能够并发下载多部小说等情况。<br>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.imlifengfeng.ios"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// [NSThread currentThread]获得当前线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务顺序执行，但是如果用在串行队列中，仍然会依次顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@%d "</span>, [<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>（2）异步（dispatch_async）</p>
<p>异步是多线程的代名词,当任务被添加到主队列后，会等待主线程空闲时才会调度该任务；添加到其他线程时，会开启新的线程调度任务。</p>
<p>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.imlifengfeng.ios"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>（3）以函数指针的方式调度任务</p>
<p>函数指针的调用方式有两种,同样是同步和异步；函数指针的传递类似于 pthread。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_sync_f</span></span><br><span class="line"><span class="keyword">dispatch_async_f</span></span><br></pre></td></tr></table></figure>
<p>函数指针调用在实际开发中几乎不用，只是有些面试中会问到，dispatch + block 才是 gcd 的主流！</p>
<p>3、开发中如何选择队列</p>
<p>选择队列当然是要先了解队列的特点：<br>串行队列：对执行效率要求不高，对执行顺序要求高，性能消耗小<br>并发队列：对执行效率要求高，对执行顺序要求不高，性能消耗大<br>如果不想兼顾 MRC 中队列的释放，建议选择使用全局队列 + 异步任务。</p>
<p>4、GCD的其他用法</p>
<p>（1）延时执行</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：从现在开始经过多少纳秒，参数2：调度任务的队列，参数3：异步执行的任务</span></span><br><span class="line"><span class="function"><span class="title">dispatch_after</span><span class="params">(when, queue, block)</span></span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(<span class="name">dispatch_time</span>(<span class="name">DISPATCH_TIME_NOW</span>, (<span class="name">int64_t</span>)(<span class="number">2.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 2秒后异步执行这里的代码...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>（2）一次性执行</p>
<p>应用场景：保证某段代码在程序运行过程中只被执行一次，在单例设计模式中被广泛使用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>（3）调度组（队列组）</p>
<p>应用场景：需要在多个耗时操作执行完毕之后，再统一做后续处理。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建调度组</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line"><span class="comment">//将调度组添加到队列，执行 block 任务</span></span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, queue, <span class="keyword">block</span>);</span><br><span class="line"><span class="comment">//当调度组中的所有任务执行结束后，获得通知，统一做后续操作</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), <span class="keyword">block</span>);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>5、应用案例：单例模式</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在.m中保留一个全局的static的实例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供1个类方法让外界访问唯一的实例</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.实现copyWithZone:方法</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、<strong>NSOperation</strong></p>
<p>NSOperation是苹果推荐使用的并发技术，它提供了一些用GCD不是很好实现的功能。NSOperation是基于GCD的面向对象的使用OC语言的封装。相比GCD，NSOperation的使用更加简单。NSOperation是一个抽象类，也就是说它并不能直接使用，而是应该使用它的子类。使用它的子类的方法有三种，使用苹果为我们提供的两个子类 <strong>NSInvocationOperation</strong>，<strong>NSBlockOperation</strong>和自定义继承自NSOperation的子类。</p>
<p>NSOperation的使用常常是配合NSOperationQueue来进行的。只要是使用NSOperation的子类创建的实例就能添加到NSOperationQueue操作队列之中，一旦添加到队列，操作就会自动异步执行（注意是异步）。<strong>如果没有添加到队列，而是使用start方法，则会在当前线程执行</strong>。</p>
<p>我们知道，线程间的通信主要是主线程与分线程之间进行的。主线程到分线程，NSOperation子类也有相应带参数的方法；而分线程到主线程，比如更新UI，它也有很方便的获取主队列（被添加到主队列的操作默认会在主线程执行）的方法：[NSOperationQueue mainQueue]。</p>
<p>1、NSInvocationOperation</p>
<p>（1）单个NSInvocationOperation</p>
<p>直接创建一个NSInvocationOperation的对象，然后调用start方法会直接在主线程执行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">  <span class="built_in">NSOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> </span><br><span class="line">selector:<span class="keyword">@selector</span>(downloadImage:) object:<span class="string">@"Invocation"</span>];</span><br><span class="line"> <span class="comment">//2.start方法，直接在当前线程执行</span></span><br><span class="line">    [op start];</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 调用的耗时操作,后面调用的耗时操作都是这个</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImage:(<span class="keyword">id</span>)obj&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@-----%@"</span>,[<span class="built_in">NSThread</span> currentThread],obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1151</span>:<span class="number">50868</span>] &lt;NSThread: <span class="number">0x7fae624047b0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">-----Invocation</span></span><br></pre></td></tr></table></figure>
<p>添加到NSOperationQueue：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">  NSOperation *op = [[NSInvocationOperation alloc]<span class="string">initWithTarget:</span>self </span><br><span class="line"><span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">downloadImage:</span>) <span class="string">object:</span>@<span class="string">"Invocation"</span>];</span><br><span class="line"> <span class="comment">//2.放到队列里面去</span></span><br><span class="line">    NSOperationQueue *q = [[NSOperationQueue alloc]init];</span><br><span class="line"><span class="comment">//只要把操作放到队列，会自动异步执行调度方法</span></span><br><span class="line">    [q <span class="string">addOperation:</span>op];</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1192</span>:<span class="number">55469</span>] &lt;NSThread: <span class="number">0x7fbe59e45c30</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">3</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation</span></span><br></pre></td></tr></table></figure>
<p>在number为3，name为空的子线程执行。</p>
<p>（2）多个NSInvocationOperation</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列，GCD里面的并发队列使用最多，所以NSOperation技术直接把GCD里面的并发队列封装起来</span></span><br><span class="line"><span class="comment">//NSOperationQueue本质就是GCD里面的并发队列</span></span><br><span class="line"><span class="comment">//操作就是GCD里面异步执行的任务</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *q = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//把多个操作放到队列里面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">NSOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> </span><br><span class="line">       selector:<span class="keyword">@selector</span>(downloadImage:) object:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invocation%d"</span>,i]];</span><br><span class="line">  [q addOperation:op];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**[<span class="number">1222</span>:<span class="number">58476</span>] &lt;NSThread: <span class="number">0x7fdc14b0cd20</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">7</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation5</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58478</span>] &lt;NSThread: <span class="number">0x7fdc1357e5f0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">9</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation7</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58307</span>] &lt;NSThread: <span class="number">0x7fdc14a06ad0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">3</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation1</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58477</span>] &lt;NSThread: <span class="number">0x7fdc134916e0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">8</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation6</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58481</span>] &lt;NSThread: <span class="number">0x7fdc1357e120</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">12</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation10</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58475</span>] &lt;NSThread: <span class="number">0x7fdc14801710</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">6</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation4</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58480</span>] &lt;NSThread: <span class="number">0x7fdc13415630</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">11</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation9</span></span><br><span class="line">**[<span class="number">1222</span>:<span class="number">58306</span>] &lt;NSThread: <span class="number">0x7fdc13512e20</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">4</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">-----Invocation3</span></span><br><span class="line">··· ···</span><br></pre></td></tr></table></figure>
<p>线程名与输出均没有规律，很明显就是并发队列。</p>
<p>2、NSBlockOperation</p>
<p>NSBlockOperation的用法与NSInvocationOperation相同，只是创建的方式不同，它不需要去调用方法，而是直接使用代码块,显得更方便。这也使得NSBlockOperation比NSInvocationOperation更加流行。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟GCD中的并发队列一样</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *q = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"><span class="comment">//跟GCD中的主队列一样</span></span><br><span class="line"><span class="comment">// NSOperationQueue *q = [NSOperationQueue mainQueue];</span></span><br><span class="line"><span class="comment">//把多个操作放到队列里面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@------%d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line"></span><br><span class="line"> &#125;];</span><br><span class="line">  <span class="comment">//把Block操作放到队列</span></span><br><span class="line">  [q addOperation:op];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"完成"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列输出结果：</span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72440</span>] &lt;NSThread: <span class="number">0x7f9cb2603460</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">6</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------5**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72442</span>] &lt;NSThread: <span class="number">0x7f9cb48106a0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">5</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------7**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72441</span>] &lt;NSThread: <span class="number">0x7f9cb242b3e0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">7</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------6**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72325</span>] &lt;NSThread: <span class="number">0x7f9cb4851550</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">9</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------2**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72320</span>] &lt;NSThread: <span class="number">0x7f9cb492be70</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">4</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------3**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72313</span>] &lt;NSThread: <span class="number">0x7f9cb24077b0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">2</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------1**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72276</span>] 完成</span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72444</span>] &lt;NSThread: <span class="number">0x7f9cb481cc40</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">11</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------9**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72326</span>] &lt;NSThread: <span class="number">0x7f9cb4923fe0</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">3</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------0**</span></span><br><span class="line">**[<span class="number">1378</span>:<span class="number">72440</span>] &lt;NSThread: <span class="number">0x7f9cb2603460</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">6</span>, <span class="built_in">name</span> = (null)&#125;<span class="comment">------12**</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主队列输出结果：</span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] 完成</span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------0**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------1**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------2**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------3**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------4**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------5**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------6**</span></span><br><span class="line">**[<span class="number">1417</span>:<span class="number">76086</span>] &lt;NSThread: <span class="number">0x7fa452e04360</span>&gt;&#123;<span class="built_in">number</span> = <span class="number">1</span>, <span class="built_in">name</span> = main&#125;<span class="comment">------7**</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>事实上NSBlockOperation有更简单的使用方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *q = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    [q addOperationWithBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@------%d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>3、线程间通信</p>
<p>主线程到子线程传对象，前面的例子里面已经有了，不再缀述。下面的例子就是回到主线程更新UI。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.p1 &#123;margin: <span class="number">0</span>.<span class="number">0</span>px <span class="number">0</span>.<span class="number">0</span>px <span class="number">0</span>.<span class="number">0</span>px <span class="number">0</span>.<span class="number">0</span>px<span class="comment">; font: 14.0px Menlo; c</span></span><br><span class="line"></span><br><span class="line">NSOperationQueue *q = [[NSOperationQueue alloc]init]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  [q <span class="keyword">addOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="keyword"> </span>   NSLog(@<span class="string">"耗时操作--%@"</span>,[NSThread currentThread])<span class="comment">;</span></span><br><span class="line">    [[NSOperationQueue mainQueue] <span class="keyword">addOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="keyword"> </span>     NSLog(@<span class="string">"更新UI-----%@"</span>,[NSThread currentThread])<span class="comment">;</span></span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">  &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>4、NSOperationQueue的一些高级操作</p>
<p>NSOperationQueue支持的高级操作有：队列的挂起，队列的取消，添加操作的依赖关系和设置最大并发数。</p>
<p>（1）最大并发数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSOperationQueue</span> *opQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写getter方法实现懒加载</span></span><br><span class="line">- (<span class="built_in">NSOperationQueue</span>*)opQueue&#123;</span><br><span class="line">  <span class="keyword">if</span> (_opQueue == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _opQueue = [[<span class="built_in">NSOperationQueue</span> alloc]init]; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _opQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 高级操作:最大并发数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置最大的并发数量（并非线程的数量）</span></span><br><span class="line">  <span class="keyword">self</span>.opQueue.maxConcurrentOperationCount = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//把多个操作放到队列里面</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@------%d"</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//把Block操作放到队列</span></span><br><span class="line">    [<span class="keyword">self</span>.opQueue addOperation:op];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>（2）线程的挂起</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 高级操作：线程的挂起</span></span><br><span class="line"><span class="comment">//暂停继续(对队列的暂停和继续)，挂起的是队列，不会影响已经在执行的操作</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">  <span class="comment">//判断操作的数量，当前队列里面是不是有操作？</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.opQueue.operationCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前队列没有操作"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.opQueue.suspended = !<span class="keyword">self</span>.opQueue.isSuspended;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.opQueue.suspended) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"暂停"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"继续"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）取消队列里的所有操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 高级操作：取消队列里的所有操作</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)cancelAll:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">  <span class="comment">//只能取消所有队列的里面的操作，正在执行的无法取消</span></span><br><span class="line">  <span class="comment">//取消操作并不会影响队列的挂起状态</span></span><br><span class="line">  [<span class="keyword">self</span>.opQueue cancelAllOperations];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"取消队列里所有的操作"</span>);</span><br><span class="line">  <span class="comment">//取消队列的挂起状态</span></span><br><span class="line">  <span class="comment">//（只要是取消了队列的操作，我们就把队列处于不挂起状态,以便于后续的开始）</span></span><br><span class="line">  <span class="keyword">self</span>.opQueue.suspended = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）依赖关系</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 例子</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 1.下载一个小说压缩包</span></span><br><span class="line"><span class="comment">  *  2.解压缩，删除压缩包</span></span><br><span class="line"><span class="comment">  * 3.更新UI</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1.下载一个小说压缩包,%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2.解压缩，删除压缩包,%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3.更新UI,%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定任务之间的依赖关系 --依赖关系可以跨队列(可以再子线程下载，在主线程更新UI)</span></span><br><span class="line"></span><br><span class="line">  [op2 addDependency:op1];</span><br><span class="line">  [op3 addDependency:op2];</span><br><span class="line"><span class="comment">//  [op1 addDependency:op3];  一定不能出现循环依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//waitUntilFinished  类似GCD中的调度组的通知</span></span><br><span class="line">  <span class="comment">//NO不等待，直接执行输出come here</span></span><br><span class="line">  <span class="comment">//YES等待任务执行完再执行输出come here</span></span><br><span class="line">  [<span class="keyword">self</span>.opQueue addOperations:@[op1,op2] waitUntilFinished:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在主线程更新UI</span></span><br><span class="line">  [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op3];</span><br><span class="line">  [op3 addDependency:op2];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"come here"</span>);</span><br></pre></td></tr></table></figure>
<p>还有一个NSOperationQueuePriority，队列优先级的概念，因为用的极少，所以这里不做介绍。</p>
<p>六、<strong>三种多线程技术比较</strong></p>
<p>1、NSThread</p>
<ul>
<li>优点：NSThread 比其他两个轻量级，使用简单</li>
</ul>
<ul>
<li>缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。线程同步对数据的加锁会有一定的系统开销</li>
</ul>
<ul>
<li><p>2、GCD<br>GCD 是iOS 4.0以后才出现的并发技术</p>
</li>
</ul>
<ul>
<li>使用方式：将任务添加到队列（串行/并行（全局）），指定执行任务的方法，（同步（阻塞）/异步 ）</li>
</ul>
<ul>
<li>拿到主队列：dispatch_get_main_queu()</li>
</ul>
<ul>
<li>NSOperation无法做到的：1.一次性执行，2.延迟执行，3.调度组（op实现要复杂的多 ）</li>
</ul>
<p>3、NSOperation<br>NSOperation iOS2.0的时候就出现了（当时不好用，后来苹果对其进行改造）</p>
<ul>
<li>使用方式：将操作（异步执行）添加到队列（并发/全局）</li>
</ul>
<ul>
<li>拿到主队列：[NSOperationQueue mainQueue] 主队列，任务添加到主队列就会在主线程执行</li>
</ul>
<ul>
<li>提供了GCD不好实现的：1.最大并发数，2.暂停和继续，3.取消所有任务，4.依赖关系</li>
</ul>
<p>GCD是比较底层的封装，我们知道较低层的代码一般性能都是比较高的，相对于NSOperationQueue。所以追求性能，而功能够用的话就可以考虑使用GCD。如果异步操作的过程需要更多的用户交互和被UI显示出来，NSOperationQueue会是一个好选择。如果任务之间没有什么依赖关系，而是需要更高的并发能力，GCD则更有优势。<br>高德纳的教诲：“在大概97%的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。”只有Instruments显示有真正的性能提升时才有必要用低级的GCD。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/533/">https://imlifengfeng.github.io/article/533/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://imlifengfeng.github.io/article/533/" data-id="cjpc8qscd008t4ts662gm1jet" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3awU7EMAxF0fn/ny4SKyTacJ/dGVTnZoUGpsnpwtixXy+8ju/Ff3v8WOnn671aS4YMGY9lHMv1+6Bks6vvkqNf7fUHVYYMGRsw0qOQg5Jgun5B5GwyZMiQUQuyndckQ4YMGf2AywNoWqZ+9P+GDBkyHsggRSwpO/nh/q0WlyFDxgMZaWPgkz+/sb8hQ4aMhzCO0kqbnfxpxfPIkCFjNINfpXUmHGpJXpqAypAhYzaDB7sbLsVKZwhaETJkyBjH4Nf6JO1LL8vSwYs4G5UhQ8YIRu2afr1N6yhha0GGDBk7MGrJH/nL/usIBjVkyJCxGSO9OOOf3DWKcfItGTJkbMDgIbh/MZe2ClCYliFDxmaMtFhNS9l1Pc0blidFrAwZMoYy+MXZvY2B9NDo9cmQIWMoo1ay1toA/aB8SZUhQ8ZoBrp2B48jT0gblvFQiAwZMkYzeDuTp3qdizkSZGXIkLEPg19+1cbCOoNivD0gQ4aM2Yx0zKtTlPJhjjR8y5AhYzcGyiLDo9faDHGYliFDxgaMdGziroGJ2r4yZMjYjVErHddhml+lpY2EoDcrQ4aMEYxOqVkbiSCYOLmUIUPGaEZnAIIHX1Ky3hv0ZciQMY9RG6SopX3kLfIhMxkyZOzGeEe4rB0uTStlyJAho5Zdku92Ggwnu8uQIUMGHuSqJZQchnoaMmTIGMogD11vVhtR5U2FIHOUIUPGOEatMUACYgquhWkZMmSMZnwBBfQi4EriQUEAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a class="pre" href="/article/538/">iOS NSURLSession详解</a><a class="next" href="/article/528/">iOS UIWebView与WKWebView</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/article/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/article/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/article/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">李峰峰博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>