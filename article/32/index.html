<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS单元测试详解 | 李峰峰博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-130566667-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bc022e1db553f2f9ac8145120b657824';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS单元测试详解</h1><a id="logo" href="/.">李峰峰博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS单元测试详解</h1><div class="post-meta">Dec 4, 2016<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>其实单元测试用的好，开发起来也会快很多。单元测试对于我目前来说，就是为了方便测试一些功能是否正常运行，还有调试接口是否能正常使用。有时候你可能是为了测试某一个网络接口，然后每次都重新启动并且经过很多操作之后才测试到了那个网络接口。如果使用了单元测试，就可以直接测试那个方法，相对方便很多。 比如由于修改较多，我们想测试一下分享功能是否正常，这时候就有用了。（而不是重新启动程序，进入到分享界面，点击分享，填写分享内容。）其实单元测试并没有降低我们打代码的效率，我们可以在单元测试通过了，直接用到相应的地方。<br>当然也有一些高级的作用，比如自动发布、自动测试（特别在一些大的项目，以防止程序被误改或引起新的问题）。<br>现在，让我们先理清一下单元测试到底有些什么东西？<br><strong><a href="http://blog.csdn.net/jymn_chen/article/details/21552941" target="_blank" rel="noopener">    OCUnit</a></strong>（<code>即用XCTest进行测试</code>）其实就是苹果自带的测试框架，我们主要讲的就是这个。<strong><a href="http://blog.csdn.net/jymn_chen/article/details/21562869" target="_blank" rel="noopener">GHUnit</a></strong>是一个可视化的测试框架。（有了它，你可以点击APP来决定测试哪个方法，并且可以点击查看测试结果等。）<strong><a href="http://blog.csdn.net/jymn_chen/article/details/21562869" target="_blank" rel="noopener">OCMock</a></strong>就是模拟某个方法或者属性的返回值，你可能会疑惑为什么要这样做?使用用模型生成的模型对象，再传进去不就可以了？答案是可以的，但是有特殊的情况。比如你测试的是方法A，方法A里面调用到了方法B，而且方法B是有参数传入，但又不是方法A所提供。这时候，你可以使用OCMock来模拟方法B返回的值。（在不影响测试的情况下，就可以这样去模拟。）除了这些，在没有网络的情况下，也可以通过OCMock模拟返回的数据。<a href="http://www.cocoachina.com/ios/20150702/12253.html" target="_blank" rel="noopener">UITests</a>就是通过代码化来实现自动点击界面，输入文字等功能。靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UITests就可以帮助解决这个问题了。</p>
<p>最简单的单元测试</p>
<p>1.新建项目：</p>
<p><img src="/images/2016/12/18101525_hWA9.png.jpeg" alt="18101525_hwa9-png"></p>
<p>18CA997F-4911-4B99-9A83-2AB44A77E8E8.png<br>2.最简单的测试，注意截图路径的问题<br>进入到这个类，setUp是每个测试方法调用<strong>前</strong>执行，tearDown是每个测试方法调用<strong>后</strong>执行。testExample是测试方法，和我们新建的没有差别。不过测试方法必须testXXX的格式，且不能有参数，不然不会识别为测试方法。测试方法的执行顺序是字典序排序。<br>按快捷键Command + U进行单元测试，这个快捷键是全部测试。<br>testExample方法中输入</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"自定义测试testExample"</span>)<span class="comment">;</span></span><br><span class="line">    int  a= <span class="number">3</span><span class="comment">;</span></span><br><span class="line">    XCTAssertTrue(<span class="name">a</span> == <span class="number">0</span>,<span class="string">"a 不能等于 0"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>点击播放按钮，开始单个方法的测试：</p>
<p><img src="/images/2016/12/18101525_riNN.png.jpeg" alt="18101525_rinn-png"></p>
<p>8F503AA4-C630-419A-9F66-C779C81A5581.png<br>出现如下结果，由于我们断言a是不能等于0的，所以测试没有通过。当然有其它的，用到再看，demo里都有。</p>
<p><img src="/images/2016/12/18101525_VKel.png.jpeg" alt="18101525_vkel-png"></p>
<p>8BAD5CD6-7FB7-4626-A1F8-CBC2B6B35E89.png</p>
<p>进行网络请求的测试</p>
<p>使用CocoaPods安装AFNetworking和STAlertView（<a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="noopener">CocoaPods安装和使用教程</a> ）<br>Pofile:</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.5.0'</span></span><br><span class="line">pod <span class="string">'STAlertView'</span>, <span class="string">'~&gt; 1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>这时会发现AFNetworking根本没法在单元测试里使用，因为没有找到库，所以我们需要配置一下：</p>
<p><img src="/images/2016/12/18101525_je0v.gif" alt="18101525_je0v"></p>
<p>UITestDemo设置</p>
<p><img src="/images/2016/12/18101525_xp3G.gif" alt="18101525_xp3g"></p>
<p>UITestDemo设置2<br>在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES。设置位置如下：</p>
<p><img src="/images/2016/12/18101525_KRFK.png.jpeg" alt="18101525_krfk-png"></p>
<p>A0F7275A-D79D-4DA4-955B-8BFE862D10E4.png</p>
<p>iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。（<a href="http://blog.csdn.net/diyagoanyhacker/article/details/8540239" target="_blank" rel="noopener">另一种异步函数的单元测试</a>）定义宏如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。</span></span><br><span class="line"><span class="meta">#define WAIT do &#123;\</span></span><br><span class="line">[<span class="keyword">self</span> expectationForNotification:<span class="string">@"RSBaseTest"</span> object:<span class="literal">nil</span> handler:<span class="literal">nil</span>];\</span><br><span class="line">[<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">30</span> handler:<span class="literal">nil</span>];\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#define NOTIFY \</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]postNotificationName:<span class="string">@"RSBaseTest"</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>增加测试方法testRequest：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)testRequest&#123;</span><br><span class="line">    <span class="comment">// 1.获得请求管理者</span></span><br><span class="line">    AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];</span><br><span class="line">    mgr.responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"text/html"</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送GET请求</span></span><br><span class="line">    [mgr GET:<span class="string">@"http://www.weather.com.cn/adat/sk/101110101.html"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"responseObject:%@"</span>,responseObject);</span><br><span class="line">        <span class="built_in">XCTAssertNotNil</span>(responseObject, <span class="string">@"返回出错"</span>);</span><br><span class="line">        NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">    &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error:%@"</span>,error);</span><br><span class="line">        <span class="built_in">XCTAssertNil</span>(error, <span class="string">@"请求出错"</span>);</span><br><span class="line">        NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">    &#125;];</span><br><span class="line">    WAIT  <span class="comment">//暂停</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候我们想测试一下整个流程是否可以跑通，比如获取验证码、登录、上传头像，查询个人资料。其实只要输入验证码就可以完成整个测试。这时候就需要用到输入框了，以便程序继续执行。使用了一个第三方的弹出输入框STAlertView，前面已经设置。<br>STAlertView的使用方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.stAlertView = [[STAlertView alloc]<span class="string">initWithTitle:</span>@<span class="string">"验证码"</span> <span class="string">message:</span>nil <span class="string">textFieldHint:</span>@<span class="string">"请输入手机验证码"</span> <span class="string">textFieldValue:</span>nil <span class="string">cancelButtonTitle:</span>@<span class="string">"取消"</span> <span class="string">otherButtonTitle:</span>@<span class="string">"确定"</span> <span class="string">cancelButtonBlock:</span>^&#123;</span><br><span class="line">    <span class="comment">//点击取消返回后执行</span></span><br><span class="line">    [self testAlertViewCancel];</span><br><span class="line">    NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">&#125; <span class="string">otherButtonBlock:</span>^(NSString *b) &#123;</span><br><span class="line">    <span class="comment">//点击确定后执行</span></span><br><span class="line">    [self <span class="string">alertViewComfirm:</span>b];</span><br><span class="line">     NOTIFY <span class="comment">//继续执行</span></span><br><span class="line">&#125;];</span><br><span class="line">[self.stAlertView show];</span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/32/">https://imlifengfeng.github.io/article/32/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://imlifengfeng.github.io/article/32/" data-id="cjpc8qrb100024ts6gsn8ywd9" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABuklEQVR42u3ay27CUAwFQP7/p1Op25ZwbAcTpLkrRMntwMLy6/GIz/F7/r5+9snzzyT3jA4uLu6Ye5yenPvs2fP/khtwcXH3uUnwSq47f6f3E+Di4t6ZW01Nki+Mi4v77dwkNanWL7i4uHfmToqTpNRJuBfXari4uAPupGF61eul/i4uLu54KpE3T9/x1D/34OLirnCTFmeSuORJSXLDizCHi4u7wp20TZPCprp4EX15XFzcde5kraoa7HqDW1xc3Pdxry175k3YFzfj4uKucJPHqsVSHuCqIxlcXNwdbkKs/jVPj8qNFVxc3BVutezprVwktRcuLu6dufOUpdrsyMshXFzcfW41Wck7sr2xCi4u7qe41TWIpLDpBbuIjouLu8LttTauClt5CMPFxd3kTgqYfASb34aLi3sfbjXoTBYyHsWDi4v7Ke5kMaKaJDUHq9UNDlxc3AG3GlDyhYxekdMrqHBxcd/BTYJXdZ2iN4iNRjW4uLiL3F46MmmjVMeuuLi49+QWRqGtEHmeKuHi4n4L97joFAonXFzcRW5v4Jq3U6tJzwVtEVxc3AF33jDtjVWiwSouLu429wcRJPwz27g1RwAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/单元测试/">单元测试</a></div><div class="post-nav"><a class="pre" href="/article/50/">Android实现微信自动抢红包</a><a class="next" href="/article/21/">iOS开发之深复制和浅复制</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/article/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/article/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/article/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">李峰峰博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>