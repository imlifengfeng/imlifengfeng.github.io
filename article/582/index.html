<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS多线程安全详解 | 李峰峰博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-130566667-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bc022e1db553f2f9ac8145120b657824';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS多线程安全详解</h1><a id="logo" href="/.">李峰峰博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS多线程安全详解</h1><div class="post-meta">Mar 4, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>在多线程操作过程中，往往一个数据同时被多个线程读写，在这种情况下，如果没有相应的机制对数据进行保护，就很可能会发生数据污染的的问题，给程序造成各种难以重现的潜在bug。</p>
<p>多线程安全中相关术语及概念（假设操作的是数据库）：</p>
<p>（1）脏读</p>
<p>指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中。这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<p>（2）不可重复读</p>
<p>指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p>（3）幻觉读</p>
<p>指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如：<br>目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这时，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p>
<p>二、<strong>多线程的安全问题</strong></p>
<p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。</p>
<p><img src="/images/2017/03/Snip20170304_1.png" alt="Snip20170304_1"></p>
<p>线程安全：简单来说就是多个线程同时对共享资源进行访问时，采用了加锁机制，当一个线程访问共享资源，对该资源进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。</p>
<p><img src="/images/2017/03/Snip20170304_2.png" alt="Snip20170304_2"></p>
<p>三、<strong>iOS多线程中的“锁”</strong></p>
<p>1、互斥锁：@synchronized(id anObject)</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">myMethod</span><span class="selector-pseudo">:(id)anObj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@synchronized</span>(anObj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、atomic</p>
<p>OC在定义属性时有nonatomic和atomic两种选择。</p>
<p>atomic：原子属性，为setter方法加锁（默认就是atomic）。</p>
<p>nonatomic：非原子属性，不会为setter方法加锁。</p>
<p>atomic加锁原理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, atomic) <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line"> &#123; </span><br><span class="line">     <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </span><br><span class="line">        _age = age;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3、NSLock</p>
<p>NSLock对象实现了NSLocking protocol，包含几个方法：<br>lock——加锁<br>unlock——解锁<br>tryLock——尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO<br>lockBeforeDate:——在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO。<br>比如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLock *theLock = [[NSLock alloc] init]; </span><br><span class="line"><span class="keyword">if</span> ([theLock <span class="keyword">lock</span>]) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//do something here</span></span><br><span class="line">   [<span class="meta">theLock unlock</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、递归锁：NSRecursiveLock</p>
<p>多次调用不会阻塞已获取该锁的线程。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRecursiveLock *rcsLock = [[NSRecursiveLock alloc] init]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveLockTest</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  [<span class="meta">rcsLock lock</span>]; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="number">0</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    --<span class="keyword">value</span>; </span><br><span class="line">    recursiveLockTest(<span class="keyword">value</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">rcsLock unlock</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">recursiveLockTest(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>上面如果直接使用NSLock就会造成死锁。NSRecursiveLock类定义的锁可以在同一线程多次lock，而不会造成死锁。递归锁会跟踪它被多少次lock。每次成功的lock都必须平衡调用unlock操作。只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线程获得。</p>
<p>5、条件锁：NSConditionLock</p>
<p>有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程中</span></span><br><span class="line"><span class="built_in">NSConditionLock</span> *theLock = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        [theLock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"thread1:%d"</span>,i);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        [theLock unlockWithCondition:i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [theLock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"thread2"</span>);</span><br><span class="line">    [theLock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在线程1中的加锁使用了lock，是不需要条件的，所以顺利的就锁住了。但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock、lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>
<p>上述代码运行结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:29.031</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031878]</span> <span class="selector-tag">thread1</span><span class="selector-pseudo">:0</span></span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:31.105</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031878]</span> <span class="selector-tag">thread1</span><span class="selector-pseudo">:1</span></span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:33.175</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031878]</span> <span class="selector-tag">thread1</span><span class="selector-pseudo">:2</span></span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:21</span><span class="selector-pseudo">:35.249</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[87455:3031879]</span> <span class="selector-tag">thread2</span></span><br></pre></td></tr></table></figure>
<p>如果上面线程2的代码中将[theLock lockWhenCondition:2];改为[theLock lockWhenCondition:3];，则运行时就不会再打印出thread2了。</p>
<p>6、分布锁：NSDistributedLock</p>
<p>以上所有的锁都是在解决多线程之间的冲突，但如果遇上多个进程或多个程序之间需要构建互斥的情景该怎么办呢？这个时候我们就需要使用到NSDistributedLock了，从它的类名就知道这是一个分布式的Lock，NSDistributedLock的实现是通过文件系统的，所以使用它才可以有效的实现不同进程之间的互斥，但NSDistributedLock并非继承于NSLock，它没有lock方法，它只实现了tryLock，unlock，breakLock，所以如果需要lock的话，你就必须自己实现一个tryLock的轮询。</p>
<p>例如：</p>
<p>程序A：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, </span><span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    lock = [[NSDistributedLock alloc] initWithPath:@<span class="string">"/Users/lifengfeng/Desktop/locktest.txt"</span>]<span class="comment">;</span></span><br><span class="line">    [lock <span class="keyword">breakLock];</span></span><br><span class="line"><span class="keyword"> </span>   [lock tryLock]<span class="comment">;</span></span><br><span class="line">    sleep(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">    [lock unlock]<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"appA: OK"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>程序B:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    lock = [[NSDistributedLock alloc] initWithPath:@<span class="string">"/Users/lifengfeng/Desktop/locktest.txt"</span>]<span class="comment">;</span></span><br><span class="line">        while (![lock tryLock]) &#123;</span><br><span class="line">            NSLog(@<span class="string">"appB: waiting"</span>)<span class="comment">;</span></span><br><span class="line">            sleep(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock]<span class="comment">;</span></span><br><span class="line">        NSLog(@<span class="string">"appB: OK"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>先运行程序A，然后立即运行程序B。根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中。当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两上不同程序之间的互斥。/Users/lifengfeng/Desktop/locktest.txt是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。</p>
<p>7、GCD中信号量：dispatch_semaphore</p>
<p>假设现在系统有两个空闲资源可以被利用，但同一时间却有三个线程要进行访问，这种情况下，该如何处理呢？这里，我们就可以方便的利用信号量来解决这个问题。同样我们也可以用它来构建一把”锁”（从本质上讲，信号量与锁是有区别的，具体的请自行查阅资料）。</p>
<p>信号量：就是一种可用来控制访问资源的数量的标识。设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。</p>
<p>在GCD中有三个函数是semaphore的操作：<br><strong>_dispatch_semaphore_create_</strong>        创建一个semaphore<br>_<strong>dispatch_semaphore_signal</strong>_        发送一个信号<br><strong>_dispatch_semaphore_wait_</strong>        等待信号</p>
<p>dispatch_semaphore_create函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量+1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>
<p>具体使用如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//crate的value表示，最多几个资源可访问</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run task 1"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete task 1"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run task 2"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete task 2"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run task 3"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete task 3"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:52.915</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095043]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:52.915</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095041]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:53.983</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095043]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:53.984</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095040]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 3</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:53.992</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095041]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 22<span class="selector-pseudo">:59</span><span class="selector-pseudo">:55.029</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89228:3095040]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 3</span><br></pre></td></tr></table></figure>
<p>由于设定的信号值为2，先执行两个线程，等执行完一个，才会继续执行下一个，保证同一时间执行的线程数不超过2。</p>
<p>如果我们把信号值设为1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>则运行结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:56.468</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100137]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:57.530</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100137]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 1</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:57.531</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100135]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:58.531</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100135]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 2</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:58.532</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100134]</span> <span class="selector-tag">run</span> <span class="selector-tag">task</span> 3</span><br><span class="line">2017<span class="selector-tag">-03-04</span> 23<span class="selector-pseudo">:01</span><span class="selector-pseudo">:59.588</span> <span class="selector-tag">LockDemo</span><span class="selector-attr">[89388:3100134]</span> <span class="selector-tag">complete</span> <span class="selector-tag">task</span> 3</span><br></pre></td></tr></table></figure>
<p>8、GCD中“栅栏函数”：dispatch_barrier_async</p>
<p>dispatch_barrier_async函数的作用与barrier的意思相同，在进程管理中起到一个栅栏的作用，它等待所有位于barrier函数之前的操作执行完毕后执行，并且在barrier函数执行之后，barrier函数之后的操作才会得到执行，该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用。</p>
<p>dispatch_barrier_async函数的作用：</p>
<p>（1）实现高效率的数据库访问和文件访问</p>
<p>（2）避免数据竞争</p>
<p>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----4"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码打印结果总是1 2 –&gt; barrier –&gt;3 4，即1、2总在barrier之前打印，3、4总在barrier之后打印，其中1、2 由于并行处理先后顺序不定，当然3、4也一样。</p>
<p>四、<strong>综合demo</strong></p>
<p>先看下面代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> configData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)configData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.dataSource = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataSource addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Obj - %i"</span>, i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户在点击start按钮后，会在一个全局的queue里面对构造的数据进行遍历，为了模拟实际场景中网络请求的时延，每次循环让当前线程休息0.05s。这样在遍历的过程中，如果用户点击了移除按钮，此时<code>self.dataSource[i]</code>执行时，因为数组已经被清空了，会报数组越界的错误。</p>
<p>解决办法：</p>
<p>（1）使用@synchronized修复</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>.dataSource) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>.dataSource) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）使用NSLock修复</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个全局变量</span></span><br><span class="line"> <span class="built_in">NSRecursiveLock</span>* rLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line"> - (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [rLock lock];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        [rLock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    [rLock lock];</span><br><span class="line">    [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    [rLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）使用dispatch_semaphore_signal修复</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）使用dispatch_barrier_async修复</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.threadsafe.sing"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataSource.count; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.05</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.dataSource[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)removeAllObjs:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.dataSource removeAllObjects];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/582/">https://imlifengfeng.github.io/article/582/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://imlifengfeng.github.io/article/582/" data-id="cjpc8qs8i006g4ts62uxtsxcw" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3aQY7DMAhA0dz/0um2UmX3A26lwPeqmnYSnhcIsK8Lr/ttff5ltd5/uX/y6i2HlwwZMh7L4KGsvt0HsQ90zyaxyZAhYw6DpMLV7wmMpFGerGXIkCGDhJ6rzXgKliFDhoxTCZckU5J2ow2wDBkyZjJOjcwqafRPvbgMGTIeyOBT9/9//sn5hgwZMh7FuIOrUkrW2+BlVDJkyGjNyI3SeNA5WC4eGTJkdGXw4Vdl0B8dru2ff3G3DBkyWjDIhQk+XOODM44nlzxkyJAxjZFLiJXtyJWJy+fLkCGjHYNcPOUNbbStzW3El6mhDBkymjL4iD9aJu43iPNKvbgMGTJaMPhRZb3VzDWxX94rQ4aMAYxoAj17/bSycTJkyJjAiA7Icg0nqd940bn8XxkyZDRlkMIrejwQbVOP3RmRIUPGAEY9RH5gkAsd9eIyZMhoxzg13I/O6nnOJIWpDBky5jD4ICw6PqtsU6CclSFDxhhGdOzFr27khnqBlliGDBkDGFdh7VtT3sry9hVVuDJkyGjK4AmOpNfKNoUTtAwZMkYy+HEmeQ7/NnfgKkOGjK6MO7iiB5O5sKJbJkOGjN6MytgrelTJqfXmVoYMGf0YPMnWW9ZKGXrgDEGGDBkPZ/DEFxjW47B4uMtfypAhQ0Yq4ZKLGqeeLEOGDBmkpOPlIEeSQ1YZMmTMYUQPAwgpdyEsl45lyJDRm3FqlsVfnMMcuHAmQ4aM5zFeSo2dO/bMGCwAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a class="pre" href="/article/588/">iOS XCTest单元测试</a><a class="next" href="/article/548/">iOS Core Animation详解</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/article/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/article/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/article/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/article/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/article/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/article/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">李峰峰博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>