<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS开发之深复制和浅复制 | imlifengfeng</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS开发之深复制和浅复制</h1><a id="logo" href="/.">imlifengfeng</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS开发之深复制和浅复制</h1><div class="post-meta">Dec 4, 2016<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p><strong>1**</strong>、概述**</p>
<p>对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。</p>
<p>如下图：</p>
<p><img src="/images/2016/12/103648_Nn5O_2448717.png" alt="103648_nn5o_2448717"></p>
<p>再简单些说：<strong>浅复制就是指针拷贝；深复制就是内容拷贝。</strong></p>
<hr>
<p><strong>2**</strong>、集合的浅复制<strong>** (shallow copy)</strong></p>
<p>集合的浅复制有非常多种方法。当你进行浅复制时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。</p>
<p>现在让我们看三个浅复制的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *shallowCopyArray = [someArray copyWithZone:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSSet</span> *shallowCopySet = [<span class="built_in">NSSet</span> mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *shallowCopyDict =</span><br><span class="line">[[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p><strong>2**</strong>、集合的深复制<strong>** (deep copy)</strong></p>
<p>集合的深复制有两种方法。</p>
<p><strong>方法一：</strong></p>
<p>可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span>  shallowCopyDict  =</span><br><span class="line">[[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深复制到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。</p>
<p><strong>方法二：</strong></p>
<p>将集合进行归档(archive)，然后解档(unarchive)，如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *trueDeepCopyArray =</span><br><span class="line">[<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:oldArray]];</span><br></pre></td></tr></table></figure>
<p><strong>3**</strong>、集合的单层深复制<strong>** (one-level-deep copy)</strong></p>
<p>看到这里，有同学会问：如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，苹果官网文档有这样一句话描述：</p>
<p>This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy…</p>
<p>If you need a true deep copy, such as when you have an array of arrays…</p>
<p>从文中可以看出，苹果认为这种复制不是真正的深复制，而是将其称为单层深复制(one-level-deep copy)。因此，网上有人对浅复制、深复制、单层深复制做了概念区分。</p>
<p><strong>浅复制**</strong>(shallow copy)<strong>**：</strong>在浅复制操作时，对于被复制对象的每一层都是指针复制。</p>
<p><strong>深复制**</strong>(one-level-deep copy)<strong>**：</strong>在深复制操作时，对于被复制对象，至少有一层是深复制。</p>
<p><strong>完全复制**</strong>(real-deep copy)<strong>**：</strong>在完全复制操作时，对于被复制对象的每一层都是对象复制。</p>
<p>当然，这些都是概念性的东西，没有必要纠结于此。只要知道进行拷贝操作时，被拷贝的是指针还是内容即可。</p>
<p><strong>4**</strong>、系统对象的<strong><strong>copy</strong></strong>与<strong><strong>mutableCopy</strong></strong>方法**</p>
<p>不管是集合类对象，还是非集合类对象，接收到copy和mutableCopy消息时，都遵循以下准则：</p>
<p>copy返回imutable对象（不可变对象）；所以，如果对copy返回值使用mutable对象接口就会crash；</p>
<p>mutableCopy返回mutable对象；</p>
<p>下面将针对非集合类对象和集合类对象的copy和mutableCopy方法进行具体的阐述</p>
<p><strong>（**</strong>1<strong><strong>）非集合类对象的</strong></strong>copy<strong><strong>与</strong></strong>mutableCopy**</p>
<p>系统非集合类对象指的是 NSString, NSNumber … 之类的对象。下面先看个非集合类immutable对象拷贝的例子</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @<span class="string">"origin"</span>;</span><br><span class="line">NSString *stringCopy = [<span class="built_in">string</span> copy];</span><br><span class="line">NSMutableString *stringMCopy = [<span class="built_in">string</span> mutableCopy];</span><br></pre></td></tr></table></figure>
<p>通过查看内存，可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；</p>
<p>再看mutable对象拷贝例子：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *string = [NSMutableString stringWithString: @<span class="string">"origin"</span>];</span><br><span class="line"><span class="comment">//copy</span></span><br><span class="line">NSString *stringCopy = [<span class="built_in">string</span> copy];</span><br><span class="line">NSMutableString *mStringCopy = [<span class="built_in">string</span> copy];</span><br><span class="line">NSMutableString *stringMCopy = [<span class="built_in">string</span> mutableCopy];</span><br><span class="line"><span class="comment">//change value</span></span><br><span class="line">[mStringCopy appendString:@<span class="string">"mm"</span>]; <span class="comment">//crash</span></span><br><span class="line">[<span class="built_in">string</span> appendString:@<span class="string">" origion!"</span>];</span><br><span class="line">[stringMCopy appendString:@<span class="string">"!!"</span>];</span><br></pre></td></tr></table></figure>
<p>运行以上代码，会在第7行crash，原因就是 copy 返回的对象是 immutable 对象。注释第7行后再运行，查看内存，发现 string、stringCopy、mStringCopy、stringMCopy 四个对象的内存地址都不一样，说明此时都是做内容拷贝。</p>
<p>综上两个例子，我们可以得出结论：</p>
<p><strong>在非集合类对象中：对**</strong>immutable<strong><strong>对象进行</strong></strong>copy<strong><strong>操作，是指针复制，</strong></strong>mutableCopy<strong><strong>操作时内容复制；对</strong></strong>mutable<strong><strong>对象进行</strong></strong>copy<strong><strong>和</strong></strong>mutableCopy<strong>**都是内容复制。</strong></p>
<p><strong>用代码简单表示如下：</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">immutableObject copy</span>] <span class="comment">// 浅复制</span></span><br><span class="line">[<span class="meta">immutableObject mutableCopy</span>] <span class="comment">//深复制</span></span><br><span class="line">[<span class="meta">mutableObject copy</span>] <span class="comment">//深复制</span></span><br><span class="line">[<span class="meta">mutableObject mutableCopy</span>] <span class="comment">//深复制</span></span><br></pre></td></tr></table></figure>
<p><strong>（**</strong>2<strong><strong>）集合类对象的</strong></strong>copy<strong><strong>与</strong></strong>mutableCopy**</p>
<p>集合类对象是指NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用copy和mutableCopy的一个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@[<span class="string">@"a"</span>, <span class="string">@"b"</span>], @[<span class="string">@"c"</span>, <span class="string">@"d"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *copyArray = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure>
<p>查看内容，可以看到copyArray和array的地址是一样的，而mCopyArray和array的地址是不同的。说明copy操作进行了指针拷贝，mutableCopy进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝array这个对象，array集合内部的元素仍然是指针拷贝。这和上面的非集合immutable对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看mutable对象拷贝的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array =</span><br><span class="line">[<span class="built_in">NSMutableArray</span> arrayWithObjects:[<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"a"</span>],<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *copyArray = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure>
<p>查看内存，如我们所料，copyArray、mCopyArray和array的内存地址都不一样，说明copyArray、mCopyArray都对array进行了内容拷贝。</p>
<p>同样，我们可以得出结论：</p>
<p><strong>在集合类对象中，对**</strong>immutable<strong><strong>对象进行</strong></strong>copy<strong><strong>，是指针复制，</strong></strong>mutableCopy<strong><strong>是内容复制；对</strong></strong>mutable<strong><strong>对象进行</strong></strong>copy<strong><strong>和</strong></strong>mutableCopy<strong>**都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。</strong></p>
<p><strong>用代码简单表示如下：</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">immutableObject copy</span>] <span class="comment">// 浅复制</span></span><br><span class="line">[<span class="meta">immutableObject mutableCopy</span>] <span class="comment">//单层深复制</span></span><br><span class="line">[<span class="meta">mutableObject copy</span>] <span class="comment">//单层深复制</span></span><br><span class="line">[<span class="meta">mutableObject mutableCopy</span>] <span class="comment">//单层深复制</span></span><br></pre></td></tr></table></figure>
<p>这个代码结论和非集合类的非常相似。</p>
<p>最后说个题外的东西，在搜集资料的过程中，发现一个有可能犯错的点：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *<span class="keyword">str</span> = @<span class="string">"string"</span>;</span><br><span class="line"><span class="keyword">str</span> = @<span class="string">"newString"</span>;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，在执行第二行代码后，内存地址发生了变化。乍一看，有点意外。按照 C 语言的经验，初始化一个字符串之后，字符串的首地址就被确定下来，不管之后如何修改字符串内容，这个地址都不会改变。但此处第二行并不是对 str 指向的内存地址重新赋值，因为赋值操作符左边的 str 是一个指针，也就是说此处修改的是内存地址。</p>
<p>所以第二行应该这样理解：将@”newStirng”当做一个新的对象，将这段对象的内存地址赋值给str。</p>
<p>如下的两个方法查看内存地址</p>
<p><strong>方法一</strong>：p str （会打印对象本身的内存地址和对象内容）</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(lldb)</span> p str</span><br><span class="line"><span class="comment">(NSString *)</span> $<span class="number">0</span> = <span class="number">0</span>x<span class="number">000000010</span>c<span class="number">913680</span> @<span class="string">"a"</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong>po &amp;str （打印的是引用对象的指针所在的地址）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lldb</span>) po &amp;str</span><br><span class="line"><span class="number">0</span>x00007fff532fb6c0</span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2016/12/04/21/">http://www.imlifengfeng.com/2016/12/04/21/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><div class="tags"><a href="/tags/浅复制/">浅复制</a><a href="/tags/深复制/">深复制</a></div><div class="post-nav"><a class="pre" href="/2016/12/04/32/">iOS单元测试详解</a><a class="next" href="/2016/12/04/19/">TabHost页和子Activity之间的通讯</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.imlifengfeng.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">imlifengfeng.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>