<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS Runtime之六：Method Swizzling | 李峰峰博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS Runtime之六：Method Swizzling</h1><a id="logo" href="/.">李峰峰博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS Runtime之六：Method Swizzling</h1><div class="post-meta">Dec 27, 2016<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>一、<strong>概述</strong></p>
<p>Objective-C 中的 Method Swizzling 是一项异常强大的技术，它可以允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。</p>
<p>Method Swizzling 是一把双刃剑，使用得当可以让我们非常轻松地实现复杂的功能，而如果一旦误用，它也很可能会给我们的程序带来毁灭性的伤害。但是我们不能因噎废食，当我们理解了Method Swizzling原理之后，它将会变成我们强大的武器。</p>
<p>二、<strong>Method Swizzling 的原理</strong></p>
<p>在上篇博文中我们讲过在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。所以下面两个方法在 runtime 看来就是同一个方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>viewWillAppear:<span class="params">(BOOL)</span>animated;</span><br><span class="line">- <span class="params">(void)</span>viewWillAppear:<span class="params">(NSString *)</span>string;</span><br></pre></td></tr></table></figure>
<p>而下面两个方法却是可以共存的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>viewWillAppear:<span class="params">(BOOL)</span>animated;</span><br><span class="line">+ <span class="params">(void)</span>viewWillAppear:<span class="params">(BOOL)</span>animated;</span><br></pre></td></tr></table></figure>
<p>因为实例方法和类方法是分别保存在类对象和元类对象中的。</p>
<p>原则上，方法的名称 <code>name</code> 和方法的实现 <code>imp</code> 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。如下图所示：</p>
<p>[caption id=”attachment_401” align=”alignnone” width=”600”]<img src="/images/2016/12/270478-efc2eea5e79a172f.png" alt="270478-efc2eea5e79a172f"> 图一[/caption]</p>
<p>[caption id=”attachment_402” align=”alignnone” width=”600”]<img src="/images/2016/12/270478-998fcd4ad6c248da.png" alt="270478-998fcd4ad6c248da"> 图二[/caption]</p>
<p>上面图一中selector2原本对应着IMP2，但是为了更方便的实现特定业务需求，我们在图二中添加了selector3和IMP3，并且让selector2指向了IMP3，而selector3则指向了IMP2，这样就实现了“方法互换”。</p>
<p>在OC语言的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP(一个IMP可以对应多个SEL)，通过这个IMP找到对应的方法调用。</p>
<p>在每个类中都有一个Dispatch Table，这个Dispatch Table本质是将类中的SEL和IMP(可以理解为函数指针)进行对应。而我们的Method Swizzling就是对这个table进行了操作，让SEL对应另一个IMP。</p>
<p>三、<strong>Method Swizzling使用</strong></p>
<p>想必大家都用过友盟统计，我们需要在每个页面的 view controller 中添加如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillAppear:</span>(BOOL)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillAppear:</span>animated];</span><br><span class="line">    [MobClick <span class="string">beginLogPageView:</span>@<span class="string">"PageOne"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillDisappear:</span>(BOOL)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillDisappear:</span>animated];</span><br><span class="line">    [MobClick <span class="string">endLogPageView:</span>@<span class="string">"PageOne"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最简单的方法，直接简单粗暴的在每个控制器中加入统计，复制、粘贴、复制、粘贴…<br>实际上非常不建议使用这种方法的，不仅消耗时间而且以后非常难以维护。那我们有其他什么好的办法吗？</p>
<p>当然我们还可以用以下两种方法：</p>
<p>（1）直接修改每个页面的 view controller 代码，简单粗暴。</p>
<p>（2）子类化 view controller ，并让我们的 view controller 都继承这些子类。</p>
<p>第 1 种方式的缺点是不仅会产生大量重复的代码，而且还很容易遗漏某些页面，非常难维护；第 2 种方式稍微好一点，但是也同样需要我们子类化 UIViewController 、UITableViewController 和 UITabBarController 等不同类型的 view controller 。</p>
<p>除此之外还有什么比较简单优雅的解决方案吗？答案是肯定的，Method Swizzling 就是解决此类问题的最佳方式。</p>
<p>在实现Method Swizzling时，核心代码主要就是一个runtime的C语言API：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BJC_EXPORT void method_exchangeImplementations(<span class="function"><span class="keyword">Method</span> <span class="title">m1</span>, <span class="title">Method</span> <span class="title">m2</span>) </span></span><br><span class="line"><span class="function"> __<span class="title">OSX_AVAILABLE_STARTING</span><span class="params">(__MAC_10_5, __IPHONE_2_0)</span>;</span></span><br></pre></td></tr></table></figure>
<p>下面我们通过<code>Method Swizzling</code>简单的实现上面那个添加统计的需求。</p>
<p>我们先给UIViewController添加一个Category，然后在Category中的+(void)load方法中添加Method Swizzling方法，我们用来替换的方法也写在这个Category中。由于load类方法是程序运行时这个类被加载到内存中就调用的一个方法，执行比较早，并且不需要我们手动调用。而且这个方法具有唯一性，也就是只会被调用一次，不用担心资源抢夺的问题。</p>
<p>定义Method Swizzling中我们自定义的方法时，需要注意尽量加前缀，以防止和其他地方命名冲突，Method Swizzling的替换方法命名一定要是唯一的，至少在被替换的类中必须是唯一的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"UIViewController+swizzling.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">swizzling</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// 通过class_getInstanceMethod()函数从当前对象中的method list获取method结构体，如果是类方法就使用class_getClassMethod()函数获取。</span></span><br><span class="line">    Method fromMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidLoad));</span><br><span class="line">    Method toMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzlingViewDidLoad));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  我们在这里使用class_addMethod()函数对Method Swizzling做了一层验证，如果self没有实现被交换的方法，会导致失败。</span></span><br><span class="line"><span class="comment">     *  而且self没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。</span></span><br><span class="line"><span class="comment">     *  所以我们在这里通过class_addMethod()的验证，如果self实现了这个方法，class_addMethod()函数将会返回NO，我们就可以对其进行交换了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzlingViewDidLoad), method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) &#123;</span><br><span class="line">        method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己实现的方法，也就是和self的viewDidLoad方法进行交换的方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)swizzlingViewDidLoad &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="keyword">self</span>.class];</span><br><span class="line">    <span class="comment">// 我们在这里加一个判断，将系统的UIViewController的对象剔除掉</span></span><br><span class="line">    <span class="keyword">if</span>(![str containsString:<span class="string">@"UI"</span>])&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"统计打点 : %@"</span>, <span class="keyword">self</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> swizzlingViewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>不知道大家注意没有，swizzlingViewDidLoad方法中又调用了[self swizzlingViewDidLoad];，这难道不会产生递归调用吗？</p>
<p>实际上是不会的，Method Swizzling的实现原理可以理解为”方法互换“。假设我们将A和B两个方法进行互换，向A方法发送消息时执行的却是B方法，向B方法发送消息时执行的是A方法。</p>
<p>例如我们上面的代码，系统调用UIViewController的viewDidLoad方法时，实际上执行的是我们实现的swizzlingViewDidLoad方法。而我们在swizzlingViewDidLoad方法内部调用[self swizzlingViewDidLoad];时，执行的是UIViewController的viewDidLoad方法。</p>
<p>四、<strong>Method Swizzling类簇</strong></p>
<p>在我们项目开发过程中，经常因为NSArray数组越界或者NSDictionary的key或者value值为nil等问题导致的崩溃，我们可以尝试使用前面知识对NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等类进行Method Swizzling，但是结果发现Method Swizzling根本就不起作用，到底为什么呢？</p>
<p>这是因为Method Swizzling对NSArray这些的类簇是不起作用的。因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex:方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。</p>
<p>所以也就是我们对NSArray类进行操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。</p>
<p>下面我们实现了防止NSArray因为调用objectAtIndex:方法，取下标时数组越界导致的崩溃：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+ MyArray.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"objc/runtime.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> <span class="title">MyArray</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    Method fromMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(objectAtIndex:));</span><br><span class="line">    Method toMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(my_objectAtIndex:));</span><br><span class="line">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)my_objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count<span class="number">-1</span> &lt; index) &#123;</span><br><span class="line">        <span class="comment">// 这里做一下异常处理，不然都不知道出错了。</span></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> my_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// 在崩溃后会打印崩溃信息，方便我们调试。</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"---------- %s Crash Because Method %s  ----------\n"</span>, class_getName(<span class="keyword">self</span>.class), __func__);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [exception callStackSymbols]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">@finally</span> &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> my_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>也就是说__NSArrayI才是NSArray真正的类。我们可以通过runtime函数获取真正的类：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_getClass</span><span class="params">(<span class="string">"__NSArrayI"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>下面我们列举一些常用的类簇的“真身”：</p>
<p><img src="/images/2016/12/Snip20161227_1.png" alt="snip20161227_1"></p>
<p>五、<strong>Method Swizzling使用注意事项</strong></p>
<p>1、Swizzling应该总是在+load中执行 </p>
<p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<p>2、Swizzling应该总是在dispatch_once中执行</p>
<p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>
<p>3、Method Swizzling有成熟的第三方框架可用</p>
<p>在项目中我们肯定会在很多地方用到<code>Method Swizzling</code>，而且在使用这个特性时有很多需要注意的地方。我们可以将<code>Method Swizzling</code>封装起来，也可以使用一些比较成熟的第三方。<br>在这里我推荐<strong>Github</strong>上星最多的一个第三方－<a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">jrswizzle</a></p>
<p>里面核心就两个类，代码看起来非常清爽。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JRSwizzle</span>)</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)jr_swizzleMethod:(SEL)origSel_ withMethod:(SEL)altSel_ error:(<span class="built_in">NSError</span>**)error_;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)jr_swizzleClassMethod:(SEL)origSel_ withClassMethod:(SEL)altSel_ error:(<span class="built_in">NSError</span>**)error_;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MethodSwizzle类</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/objc.h&gt;</span></span></span><br><span class="line"><span class="built_in">BOOL</span> ClassMethodSwizzle(Class klass, SEL origSel, SEL altSel);</span><br><span class="line"><span class="built_in">BOOL</span> MethodSwizzle(Class klass, SEL origSel, SEL altSel);</span><br></pre></td></tr></table></figure>
<p>具体使用方法大家自己研究。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>imlifengfeng</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2016/12/27/400/">https://imlifengfeng.github.io/2016/12/27/400/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>原创文章，转载请注明来源</li></ul></div><br><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/Runtime/">Runtime</a><a href="/tags/Method-Swizzling/">Method Swizzling</a></div><div class="post-nav"><a class="pre" href="/2016/12/27/404/">iOS Runtime之七：拾遗</a><a class="next" href="/2016/12/26/398/">iOS Runtime之五：方法与消息</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'c364198c7db8ed6a1011',
  clientSecret: '7613c9d1c4706bdebff2c7adf84efdf98839ec7d',
  repo: 'imlifengfeng.github.io',
  owner: 'imlifengfeng',
  admin: ['imlifengfeng'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://imlifengfeng.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/03/714/">iOS 的组件化开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/692/">iOS逆向工程之fishhook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/677/">iOS逆向工程之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/674/">Swift算法实现之归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/672/">Swift算法实现之快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/669/">Swift算法实现之翻转二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/31/661/">Swift算法实现之二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/658/">Swift算法实现之栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/654/">Swift算法实现之查找第K大的元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/652/">Swift算法实现之数组中出现次数超过一半的数字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">李峰峰博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>